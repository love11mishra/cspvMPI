!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
++	cil/ocamlutil/pretty.ml	/^let (++) d1 d2 = Concat (d1, d2)$/;"	f
++	cil/ocamlutil/pretty.mli	/^val (++)         : doc -> doc -> doc $/;"	f
-sourcedir	cil/debian/rules	/^	dh_install --list-missing --sourcedir=$(CURDIR)\/debian\/tmp$/;"	m
::	cil/obj/x86_LINUX/clexer.ml	/^  | value::rest ->$/;"	f
::	cil/obj/x86_LINUX/cparser.ml	/^  | value::rest ->$/;"	f
<	cil/src/cil.ml	/^	    if value < Int64.zero then$/;"	f	value:xform_switch_stmt
A	cil/src/cil.ml	1;"	M
A	cil/src/frontc/cabs2cil.ml	1;"	M
AAddrOf	cil/src/cil.mli	/^  | AAddrOf of attrparam                 (** & a **)$/;"	C	type:attrparam
AAlignOf	cil/src/cil.mli	/^  | AAlignOf of typ$/;"	C	type:attrparam
AAlignOfE	cil/src/cil.mli	/^  | AAlignOfE of attrparam$/;"	C	type:attrparam
AAlignOfS	cil/src/cil.mli	/^  | AAlignOfS of typsig$/;"	C	type:attrparam
ABinOp	cil/src/cil.mli	/^  | ABinOp of binop * attrparam * attrparam$/;"	C	type:attrparam
ACons	cil/src/cil.mli	/^  | ACons of string * attrparam list       (** Constructed attributes. These $/;"	C	type:attrparam
ADD	cil/src/frontc/cabs.ml	/^    ADD | SUB | MUL | DIV | MOD$/;"	C	type:binary_operator
ADD	src/base/basic_types.h	/^enum binary_op_t { ADD, SUBTRACT, MULTIPLY, CONCRETE };$/;"	e	enum:crest::ops::binary_op_t
ADDROF	cil/src/frontc/cabs.ml	/^    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF$/;"	C	type:unary_operator
ADD_ASSIGN	cil/src/frontc/cabs.ml	/^  | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN$/;"	C	type:binary_operator
ADot	cil/src/cil.mli	/^  | ADot of attrparam * string           (** a.foo **)$/;"	C	type:attrparam
AE	cil/src/ext/availexps.ml	1;"	M
AE	cil/src/ext/availexpslv.ml	1;"	M
AIndex	cil/src/cil.mli	/^  | AIndex of attrparam * attrparam      (** a1[a2] *)$/;"	C	type:attrparam
AInt	cil/src/cil.mli	/^  | AInt of int                          (** An integer constant *)$/;"	C	type:attrparam
ALIGNOF	cil/obj/x86_LINUX/cparser.ml	/^  | ALIGNOF of (Cabs.cabsloc)$/;"	C	type:token
ALIGNOF	cil/obj/x86_LINUX/cparser.mli	/^  | ALIGNOF of (Cabs.cabsloc)$/;"	C	type:token
ALIGNOF	cil/obj/x86_LINUX/formatparse.ml	/^  | ALIGNOF$/;"	C	type:token
ALIGNOF	cil/obj/x86_LINUX/formatparse.mli	/^  | ALIGNOF$/;"	C	type:token
AND	cil/obj/x86_LINUX/cparser.ml	/^  | AND of (Cabs.cabsloc)$/;"	C	type:token
AND	cil/obj/x86_LINUX/cparser.mli	/^  | AND of (Cabs.cabsloc)$/;"	C	type:token
AND	cil/obj/x86_LINUX/formatparse.ml	/^  | AND$/;"	C	type:token
AND	cil/obj/x86_LINUX/formatparse.mli	/^  | AND$/;"	C	type:token
AND	cil/src/frontc/cabs.ml	/^  | AND | OR$/;"	C	type:binary_operator
AND_AND	cil/obj/x86_LINUX/cparser.ml	/^  | AND_AND of (Cabs.cabsloc)$/;"	C	type:token
AND_AND	cil/obj/x86_LINUX/cparser.mli	/^  | AND_AND of (Cabs.cabsloc)$/;"	C	type:token
AND_AND	cil/obj/x86_LINUX/formatparse.ml	/^  | AND_AND$/;"	C	type:token
AND_AND	cil/obj/x86_LINUX/formatparse.mli	/^  | AND_AND$/;"	C	type:token
AND_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | AND_EQ$/;"	C	type:token
AND_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | AND_EQ$/;"	C	type:token
AND_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | AND_EQ$/;"	C	type:token
AND_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | AND_EQ$/;"	C	type:token
APFound	cil/src/ext/pta/golf.ml	/^exception APFound      (* raised if an alias pair is found, a control$/;"	e
APFound	cil/src/ext/pta/olf.ml	/^exception APFound      (* raised if an alias pair is found, a control$/;"	e
AQuestion	cil/src/cil.mli	/^  | AQuestion of attrparam * attrparam * attrparam (** a1 ? a2 : a3 **)$/;"	C	type:attrparam
AR	cil/lib/Cilly.pm	/^package AR;$/;"	p
ARCHOS	cil/Makefile	/^   ARCHOS=x86_LINUX$/;"	m
ARCHOS	cil/config.mk	/^export ARCHOS=x86_LINUX$/;"	m
ARG_A	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_A of (string)$/;"	C	type:token
ARG_A	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_A of (string)$/;"	C	type:token
ARG_E	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_E of (string)$/;"	C	type:token
ARG_E	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_E of (string)$/;"	C	type:token
ARG_F	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_F of (string)$/;"	C	type:token
ARG_F	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_F of (string)$/;"	C	type:token
ARG_I	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_I of (string)$/;"	C	type:token
ARG_I	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_I of (string)$/;"	C	type:token
ARG_P	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_P of (string)$/;"	C	type:token
ARG_P	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_P of (string)$/;"	C	type:token
ARG_S	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_S of (string)$/;"	C	type:token
ARG_S	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_S of (string)$/;"	C	type:token
ARG_b	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_b of (string)$/;"	C	type:token
ARG_b	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_b of (string)$/;"	C	type:token
ARG_c	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_c of (string)$/;"	C	type:token
ARG_c	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_c of (string)$/;"	C	type:token
ARG_d	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_d of (string)$/;"	C	type:token
ARG_d	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_d of (string)$/;"	C	type:token
ARG_e	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_e of (string)$/;"	C	type:token
ARG_e	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_e of (string)$/;"	C	type:token
ARG_eo	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_eo of (string)$/;"	C	type:token
ARG_eo	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_eo of (string)$/;"	C	type:token
ARG_f	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_f of (string)$/;"	C	type:token
ARG_f	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_f of (string)$/;"	C	type:token
ARG_g	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_g of (string)$/;"	C	type:token
ARG_g	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_g of (string)$/;"	C	type:token
ARG_i	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_i of (string)$/;"	C	type:token
ARG_i	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_i of (string)$/;"	C	type:token
ARG_k	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_k of (string)$/;"	C	type:token
ARG_k	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_k of (string)$/;"	C	type:token
ARG_l	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_l of (string)$/;"	C	type:token
ARG_l	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_l of (string)$/;"	C	type:token
ARG_lo	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_lo of (string)$/;"	C	type:token
ARG_lo	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_lo of (string)$/;"	C	type:token
ARG_o	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_o of (string)$/;"	C	type:token
ARG_o	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_o of (string)$/;"	C	type:token
ARG_p	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_p of (string)$/;"	C	type:token
ARG_p	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_p of (string)$/;"	C	type:token
ARG_s	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_s of (string)$/;"	C	type:token
ARG_s	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_s of (string)$/;"	C	type:token
ARG_t	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_t of (string)$/;"	C	type:token
ARG_t	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_t of (string)$/;"	C	type:token
ARG_u	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_u of (string)$/;"	C	type:token
ARG_u	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_u of (string)$/;"	C	type:token
ARG_v	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_v of (string)$/;"	C	type:token
ARG_v	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_v of (string)$/;"	C	type:token
ARG_va	cil/obj/x86_LINUX/formatparse.ml	/^  | ARG_va of (string)$/;"	C	type:token
ARG_va	cil/obj/x86_LINUX/formatparse.mli	/^  | ARG_va of (string)$/;"	C	type:token
ARROW	cil/obj/x86_LINUX/cparser.ml	/^  | ARROW$/;"	C	type:token
ARROW	cil/obj/x86_LINUX/cparser.mli	/^  | ARROW$/;"	C	type:token
ARROW	cil/obj/x86_LINUX/formatparse.ml	/^  | ARROW$/;"	C	type:token
ARROW	cil/obj/x86_LINUX/formatparse.mli	/^  | ARROW$/;"	C	type:token
ASM	cil/obj/x86_LINUX/cparser.ml	/^  | ASM of (Cabs.cabsloc)$/;"	C	type:token
ASM	cil/obj/x86_LINUX/cparser.mli	/^  | ASM of (Cabs.cabsloc)$/;"	C	type:token
ASM	cil/obj/x86_LINUX/formatparse.ml	/^  | ASM$/;"	C	type:token
ASM	cil/obj/x86_LINUX/formatparse.mli	/^  | ASM$/;"	C	type:token
ASM	cil/src/frontc/cabs.ml	/^ | ASM of attribute list * (* typically only volatile and const *)$/;"	C	type:statement
ASSIGN	cil/src/frontc/cabs.ml	/^  | ASSIGN$/;"	C	type:binary_operator
ASizeOf	cil/src/cil.mli	/^  | ASizeOf of typ                       (** A way to talk about types *)$/;"	C	type:attrparam
ASizeOfE	cil/src/cil.mli	/^  | ASizeOfE of attrparam$/;"	C	type:attrparam
ASizeOfS	cil/src/cil.mli	/^  | ASizeOfS of typsig                   (** Replacement for ASizeOf in type$/;"	C	type:attrparam
AStar	cil/src/cil.mli	/^  | AStar of attrparam                   (** * a *)$/;"	C	type:attrparam
AStr	cil/src/cil.mli	/^  | AStr of string                       (** A string constant *)$/;"	C	type:attrparam
ATINDEXRANGE_INIT	cil/src/frontc/cabs.ml	/^  | ATINDEXRANGE_INIT of expression * expression$/;"	C	type:initwhat
ATINDEX_INIT	cil/src/frontc/cabs.ml	/^  | ATINDEX_INIT of expression * initwhat$/;"	C	type:initwhat
ATTRIBUTE	cil/obj/x86_LINUX/cparser.ml	/^  | ATTRIBUTE of (Cabs.cabsloc)$/;"	C	type:token
ATTRIBUTE	cil/obj/x86_LINUX/cparser.mli	/^  | ATTRIBUTE of (Cabs.cabsloc)$/;"	C	type:token
ATTRIBUTE	cil/obj/x86_LINUX/formatparse.ml	/^  | ATTRIBUTE$/;"	C	type:token
ATTRIBUTE	cil/obj/x86_LINUX/formatparse.mli	/^  | ATTRIBUTE$/;"	C	type:token
ATTRIBUTE_USED	cil/obj/x86_LINUX/cparser.ml	/^  | ATTRIBUTE_USED of (Cabs.cabsloc)$/;"	C	type:token
ATTRIBUTE_USED	cil/obj/x86_LINUX/cparser.mli	/^  | ATTRIBUTE_USED of (Cabs.cabsloc)$/;"	C	type:token
AT_EXPR	cil/obj/x86_LINUX/cparser.ml	/^  | AT_EXPR of (Cabs.cabsloc)$/;"	C	type:token
AT_EXPR	cil/obj/x86_LINUX/cparser.mli	/^  | AT_EXPR of (Cabs.cabsloc)$/;"	C	type:token
AT_NAME	cil/obj/x86_LINUX/cparser.ml	/^  | AT_NAME$/;"	C	type:token
AT_NAME	cil/obj/x86_LINUX/cparser.mli	/^  | AT_NAME$/;"	C	type:token
AT_SPECIFIER	cil/obj/x86_LINUX/cparser.ml	/^  | AT_SPECIFIER of (Cabs.cabsloc)$/;"	C	type:token
AT_SPECIFIER	cil/obj/x86_LINUX/cparser.mli	/^  | AT_SPECIFIER of (Cabs.cabsloc)$/;"	C	type:token
AT_TRANSFORM	cil/obj/x86_LINUX/cparser.ml	/^  | AT_TRANSFORM of (Cabs.cabsloc)$/;"	C	type:token
AT_TRANSFORM	cil/obj/x86_LINUX/cparser.mli	/^  | AT_TRANSFORM of (Cabs.cabsloc)$/;"	C	type:token
AT_TRANSFORMEXPR	cil/obj/x86_LINUX/cparser.ml	/^  | AT_TRANSFORMEXPR of (Cabs.cabsloc)$/;"	C	type:token
AT_TRANSFORMEXPR	cil/obj/x86_LINUX/cparser.mli	/^  | AT_TRANSFORMEXPR of (Cabs.cabsloc)$/;"	C	type:token
AUTO	cil/obj/x86_LINUX/cparser.ml	/^  | AUTO of (Cabs.cabsloc)$/;"	C	type:token
AUTO	cil/obj/x86_LINUX/cparser.mli	/^  | AUTO of (Cabs.cabsloc)$/;"	C	type:token
AUTO	cil/obj/x86_LINUX/formatparse.ml	/^  | AUTO$/;"	C	type:token
AUTO	cil/obj/x86_LINUX/formatparse.mli	/^  | AUTO$/;"	C	type:token
AUTO	cil/src/frontc/cabs.ml	/^    NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER$/;"	C	type:storage
AUnOp	cil/src/cil.mli	/^  | AUnOp of unop * attrparam$/;"	C	type:attrparam
AddrOf	cil/src/cil.mli	/^  | AddrOf     of lval                 $/;"	C	type:exp
AfterPattern	cil/bin/patcher	/^      AfterPattern:$/;"	l
AliasInfo	cil/src/ext/partial.ml	1;"	M
Align	cil/ocamlutil/pretty.ml	/^  | Align$/;"	C	type:doc
AlignOf	cil/src/cil.mli	/^  | AlignOf    of typ                   $/;"	C	type:exp
AlignOfE	cil/src/cil.mli	/^  | AlignOfE   of exp  $/;"	C	type:exp
Alpha	cil/ocamlutil/alpha.ml	1;"	M
Alpha	cil/ocamlutil/alpha.mli	1;"	M
Aman	cil/ocamlutil/pretty.ml	/^type algo = George | Aman | Gap$/;"	C	type:algo
AppendToString	src/base/symbolic_expression.cc	/^void SymbolicExpr::AppendToString(string* s, int tp) const {$/;"	f	class:crest::SymbolicExpr
AppendToString	src/base/symbolic_predicate.cc	/^void SymbolicPred::AppendToString(string* s) const {$/;"	f	class:crest::SymbolicPred
AppendVars	src/base/symbolic_expression.cc	/^void SymbolicExpr::AppendVars(set<var_t>* vars) const {$/;"	f	class:crest::SymbolicExpr
AppendVars	src/base/symbolic_predicate.h	/^  void AppendVars(set<var_t>* vars) const {$/;"	f	class:crest::SymbolicPred
ApplyBinaryOp	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyBinaryOp(id_t id, binary_op_t op, value_t value) {$/;"	f	class:crest::SymbolicInterpreter
ApplyCompareOp	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyCompareOp(id_t id, compare_op_t op, value_t value) {$/;"	f	class:crest::SymbolicInterpreter
ApplyLogPC	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyLogPC(int x) {$/;"	f	class:crest::SymbolicInterpreter
ApplyLogSpec	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyLogSpec(char *op,int *op1,int *op2) {$/;"	f	class:crest::SymbolicInterpreter
ApplyLogState	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyLogState(int x, int r_w, int line, char *varname=NULL, int val=0) {\/\/aakanksha$/;"	f	class:crest::SymbolicInterpreter
ApplyLogState_1	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyLogState_1(int x) {$/;"	f	class:crest::SymbolicInterpreter
ApplyUnaryOp	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ApplyUnaryOp(id_t id, unary_op_t op, value_t value) {$/;"	f	class:crest::SymbolicInterpreter
Asm	cil/src/cil.mli	/^  | Asm        of attributes * (* Really only const and volatile can appear $/;"	C	type:instr
Astslicer	cil/src/ext/astslicer.ml	1;"	M
Attr	cil/src/cil.mli	/^and attribute = Attr of string * attrparam list$/;"	C	type:attribute
AttrFunType	cil/src/cil.mli	/^  | AttrFunType of bool $/;"	C	type:attributeClass
AttrName	cil/src/cil.mli	/^    AttrName of bool $/;"	C	type:attributeClass
AttrType	cil/src/cil.mli	/^  | AttrType  (** Attribute of a type *)$/;"	C	type:attributeClass
AvailableExps	cil/src/ext/availexps.ml	1;"	M
AvailableExps	cil/src/ext/availexpslv.ml	1;"	M
Availexps	cil/src/ext/availexps.ml	1;"	M
Availexpslv	cil/src/ext/availexpslv.ml	1;"	M
B	cil/src/ext/pta/golf.ml	1;"	M
B	cil/src/ext/pta/olf.ml	1;"	M
B	cil/src/ext/pta/steensgaard.ml	1;"	M
B	cil/src/ext/ssa.ml	1;"	M
BAND	cil/src/frontc/cabs.ml	/^  | BAND | BOR | XOR | SHL | SHR$/;"	C	type:binary_operator
BAND_ASSIGN	cil/src/frontc/cabs.ml	/^  | BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN$/;"	C	type:binary_operator
BASE_BASIC_TYPES_H__	src/base/basic_types.h	12;"	d
BASE_LIBS	src/Makefile	/^BASE_LIBS = base\/basic_types.o base\/symbolic_execution.o \\$/;"	m
BASE_SYMBOLIC_EXECUTION_H__	src/base/symbolic_execution.h	12;"	d
BASE_SYMBOLIC_EXPRESSION_H__	src/base/symbolic_expression.h	12;"	d
BASE_SYMBOLIC_INTERPRETER_H__	src/base/symbolic_interpreter.h	12;"	d
BASE_SYMBOLIC_PATH_H__	src/base/symbolic_path.h	12;"	d
BASE_SYMBOLIC_PREDICATE_H__	src/base/symbolic_predicate.h	12;"	d
BASE_YICES_SOLVER_H__	src/base/yices_solver.h	12;"	d
BExpr	cil/src/frontc/patch.ml	/^  | BExpr of string * expression$/;"	C	type:binding
BI	cil/ocamlutil/clist.ml	/^  | BI of int$/;"	C	type:boxedInt
BINARY	cil/src/frontc/cabs.ml	/^  | BINARY of binary_operator * expression * expression$/;"	C	type:expression
BINCIL_TAR_GZ	cil/Makefile	/^BINCIL_TAR_GZ:=cil-win32-1.3.6.tar.gz$/;"	m
BINDISTRIB_BIN	cil/Makefile	/^BINDISTRIB_BIN = CilConfig.pm.in cilly cilly.bat.in \\$/;"	m
BINDISTRIB_LIB	cil/Makefile	/^BINDISTRIB_LIB = Cilly.pm KeptFile.pm OutputFile.pm TempFile.pm$/;"	m
BINDISTRIB_OBJ	cil/Makefile	/^BINDISTRIB_OBJ = cilly.byte.exe cilly.asm.exe$/;"	m
BINDISTRIB_ROOT	cil/Makefile	/^BINDISTRIB_ROOT = README LICENSE$/;"	m
BINDISTRIB_SMALL1	cil/Makefile	/^BINDISTRIB_SMALL1=hello.c $/;"	m
BINTEMP_DIR	cil/Makefile	/^BINTEMP_DIR = TEMP_cil-bindistrib$/;"	m
BINTOP_DIR	cil/Makefile	/^BINTOP_DIR = $(BINTEMP_DIR)\/cil$/;"	m
BITWISE_NOT	src/base/basic_types.h	/^enum unary_op_t { NEGATE, LOGICAL_NOT, BITWISE_NOT };$/;"	e	enum:crest::ops::unary_op_t
BLOCK	cil/src/frontc/cabs.ml	/^ | BLOCK of block * cabsloc$/;"	C	type:statement
BLOCKATTRIBUTE	cil/obj/x86_LINUX/cparser.ml	/^  | BLOCKATTRIBUTE$/;"	C	type:token
BLOCKATTRIBUTE	cil/obj/x86_LINUX/cparser.mli	/^  | BLOCKATTRIBUTE$/;"	C	type:token
BLOCKATTRIBUTE	cil/obj/x86_LINUX/formatparse.ml	/^  | BLOCKATTRIBUTE$/;"	C	type:token
BLOCKATTRIBUTE	cil/obj/x86_LINUX/formatparse.mli	/^  | BLOCKATTRIBUTE$/;"	C	type:token
BNOT	cil/src/frontc/cabs.ml	/^    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF$/;"	C	type:unary_operator
BName	cil/src/frontc/patch.ml	/^  | BName of string * string$/;"	C	type:binding
BOR	cil/src/frontc/cabs.ml	/^  | BAND | BOR | XOR | SHL | SHR$/;"	C	type:binary_operator
BOR_ASSIGN	cil/src/frontc/cabs.ml	/^  | BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN$/;"	C	type:binary_operator
BREAK	cil/obj/x86_LINUX/cparser.ml	/^  | BREAK of (Cabs.cabsloc)$/;"	C	type:token
BREAK	cil/obj/x86_LINUX/cparser.mli	/^  | BREAK of (Cabs.cabsloc)$/;"	C	type:token
BREAK	cil/obj/x86_LINUX/formatparse.ml	/^  | BREAK$/;"	C	type:token
BREAK	cil/obj/x86_LINUX/formatparse.mli	/^  | BREAK$/;"	C	type:token
BREAK	cil/src/frontc/cabs.ml	/^ | BREAK of cabsloc$/;"	C	type:statement
BSpecifier	cil/src/frontc/patch.ml	/^  | BSpecifier of string * spec_elem list$/;"	C	type:binding
BUILTIN_OFFSETOF	cil/obj/x86_LINUX/cparser.ml	/^  | BUILTIN_OFFSETOF of (Cabs.cabsloc)$/;"	C	type:token
BUILTIN_OFFSETOF	cil/obj/x86_LINUX/cparser.mli	/^  | BUILTIN_OFFSETOF of (Cabs.cabsloc)$/;"	C	type:token
BUILTIN_TYPES_COMPAT	cil/obj/x86_LINUX/cparser.ml	/^  | BUILTIN_TYPES_COMPAT of (Cabs.cabsloc)$/;"	C	type:token
BUILTIN_TYPES_COMPAT	cil/obj/x86_LINUX/cparser.mli	/^  | BUILTIN_TYPES_COMPAT of (Cabs.cabsloc)$/;"	C	type:token
BUILTIN_VA_ARG	cil/obj/x86_LINUX/cparser.ml	/^  | BUILTIN_VA_ARG of (Cabs.cabsloc)$/;"	C	type:token
BUILTIN_VA_ARG	cil/obj/x86_LINUX/cparser.mli	/^  | BUILTIN_VA_ARG of (Cabs.cabsloc)$/;"	C	type:token
BUILTIN_VA_ARG	cil/obj/x86_LINUX/formatparse.ml	/^  | BUILTIN_VA_ARG$/;"	C	type:token
BUILTIN_VA_ARG	cil/obj/x86_LINUX/formatparse.mli	/^  | BUILTIN_VA_ARG$/;"	C	type:token
BUILTIN_VA_LIST	cil/obj/x86_LINUX/cparser.ml	/^  | BUILTIN_VA_LIST$/;"	C	type:token
BUILTIN_VA_LIST	cil/obj/x86_LINUX/cparser.mli	/^  | BUILTIN_VA_LIST$/;"	C	type:token
BUILTIN_VA_LIST	cil/obj/x86_LINUX/formatparse.ml	/^  | BUILTIN_VA_LIST$/;"	C	type:token
BUILTIN_VA_LIST	cil/obj/x86_LINUX/formatparse.mli	/^  | BUILTIN_VA_LIST$/;"	C	type:token
BackwardsDataFlow	cil/src/ext/dataflow.ml	1;"	M
BackwardsDataFlow	cil/src/ext/dataflow.mli	1;"	M
BackwardsTransfer	cil/src/ext/dataflow.ml	1;"	M
BackwardsTransfer	cil/src/ext/dataflow.mli	1;"	M
BadBind	cil/src/frontc/patch.ml	/^exception BadBind of string$/;"	e
Bad_cache	cil/src/ext/pta/steensgaard.ml	/^exception Bad_cache$/;"	e
Bad_find	cil/src/ext/pta/uref.ml	/^exception Bad_find$/;"	e
Bad_function	cil/src/ext/pta/ptranal.ml	/^exception Bad_function$/;"	e
Bad_proj	cil/src/ext/pta/steensgaard.ml	/^exception Bad_proj$/;"	e
Bad_return	cil/src/ext/pta/ptranal.ml	/^exception Bad_return$/;"	e
Bad_type_copy	cil/src/ext/pta/steensgaard.ml	/^exception Bad_type_copy$/;"	e
BasicCallGraph	cil/src/ext/partial.ml	1;"	M
BinOp	cil/src/cil.mli	/^  | BinOp      of binop * exp * exp * typ$/;"	C	type:exp
Bitmap	cil/src/ext/bitmap.ml	1;"	M
Bitmap	cil/src/ext/bitmap.mli	1;"	M
Block	cil/src/cil.mli	/^  | Block of block                      $/;"	C	type:stmtkind
Blockinggraph	cil/src/ext/blockinggraph.ml	1;"	M
Blockinggraph	cil/src/ext/blockinggraph.mli	1;"	M
BoundedDepthFirstSearch	src/run_crest/concolic_search.cc	/^BoundedDepthFirstSearch::BoundedDepthFirstSearch$/;"	f	class:crest::BoundedDepthFirstSearch
BoundedDepthFirstSearch	src/run_crest/concolic_search.h	/^class BoundedDepthFirstSearch : public Search {$/;"	c	namespace:crest
Branch	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::Branch(id_t id, branch_id_t bid, bool pred_value) {$/;"	f	class:crest::SymbolicInterpreter
BranchIt	src/process_cfg/process_cfg.cc	/^typedef set<int>::const_iterator BranchIt;$/;"	t	file:
BranchIt	src/run_crest/concolic_search.h	/^  typedef vector<branch_id_t>::const_iterator BranchIt;$/;"	t	class:crest::Search
Break	cil/ocamlutil/pretty.ml	/^  | Break$/;"	C	type:doc
Break	cil/src/cil.mli	/^  | Break of location                   $/;"	C	type:stmtkind
C	cil/src/ext/pta/golf.ml	1;"	M
C	cil/src/ext/pta/olf.ml	1;"	M
C	cil/src/ext/pta/steensgaard.ml	1;"	M
CALL	cil/src/frontc/cabs.ml	/^  | CALL of expression * expression list$/;"	C	type:expression
CAN_GET_SPEED_FROM_OS	cil/ocamlutil/perfcount.c	103;"	d	file:
CAN_GET_SPEED_FROM_OS	cil/ocamlutil/perfcount.c	124;"	d	file:
CASE	cil/obj/x86_LINUX/cparser.ml	/^  | CASE of (Cabs.cabsloc)$/;"	C	type:token
CASE	cil/obj/x86_LINUX/cparser.mli	/^  | CASE of (Cabs.cabsloc)$/;"	C	type:token
CASE	cil/obj/x86_LINUX/formatparse.ml	/^  | CASE$/;"	C	type:token
CASE	cil/obj/x86_LINUX/formatparse.mli	/^  | CASE$/;"	C	type:token
CASE	cil/src/frontc/cabs.ml	/^ | CASE of expression * statement * cabsloc$/;"	C	type:statement
CASERANGE	cil/src/frontc/cabs.ml	/^ | CASERANGE of expression * expression * statement * cabsloc$/;"	C	type:statement
CAST	cil/src/frontc/cabs.ml	/^  | CAST of (specifier * decl_type) * init_expression$/;"	C	type:expression
CC	src/Makefile	/^CC=$(CXX) $/;"	m
CChr	cil/src/cil.mli	/^  | CChr of char   $/;"	C	type:constant
CConsL	cil/ocamlutil/clist.ml	/^  | CConsL of 'a * 'a clist$/;"	C	type:clist
CConsL	cil/ocamlutil/clist.mli	/^  | CConsL of 'a * 'a clist      (** Do not use this a lot because scanning $/;"	C	type:clist
CConsR	cil/ocamlutil/clist.ml	/^  | CConsR of 'a clist * 'a $/;"	C	type:clist
CConsR	cil/ocamlutil/clist.mli	/^  | CConsR of 'a clist * 'a $/;"	C	type:clist
CEnum	cil/src/cil.mli	/^  | CEnum of exp * string * enuminfo$/;"	C	type:constant
CFLAGS	cil/debian/rules	/^CFLAGS = -Wall -g$/;"	m
CFLAGS	src/Makefile	/^CFLAGS = -I. -I$(YICES_DIR)\/include -Wall -O2$/;"	m
CH	cil/src/ext/pta/golf.ml	1;"	M
CHAR	cil/obj/x86_LINUX/cparser.ml	/^  | CHAR of (Cabs.cabsloc)$/;"	C	type:token
CHAR	cil/obj/x86_LINUX/cparser.mli	/^  | CHAR of (Cabs.cabsloc)$/;"	C	type:token
CHAR	cil/obj/x86_LINUX/formatparse.ml	/^  | CHAR$/;"	C	type:token
CHAR	cil/obj/x86_LINUX/formatparse.mli	/^  | CHAR$/;"	C	type:token
CHAR	src/base/basic_types.h	/^enum type_t { U_CHAR = 0,       CHAR = 1,$/;"	e	enum:crest::types::type_t
CILHOME	cil/config.mk	/^export CILHOME=\/home\/aakankha\/PhD\/buggyrepo\/BugInjection\/crest\/crest-0.1.1\/cil$/;"	m
CILHTMLDEST	cil/Makefile	/^CILHTMLDEST=\/var\/www\/cil$/;"	m
CILLY_CMODULES	cil/Makefile	/^CILLY_CMODULES = perfcount$/;"	m
CILLY_FEATURES	cil/Makefile	/^CILLY_FEATURES :=$/;"	m
CILLY_LIBRARY_MODULES	cil/Makefile	/^CILLY_LIBRARY_MODULES = pretty inthash errormsg alpha trace stats util clist \\$/;"	m
CILLY_LIBS	cil/Makefile	/^CILLY_LIBS     = unix str$/;"	m
CILLY_MODULES	cil/Makefile	/^CILLY_MODULES = $(CILLY_LIBRARY_MODULES) main$/;"	m
CIL_TAR_GZ	cil/Makefile	/^CIL_TAR_GZ:=cil-1.3.6.tar.gz$/;"	m
CIRC	cil/obj/x86_LINUX/cparser.ml	/^  | CIRC$/;"	C	type:token
CIRC	cil/obj/x86_LINUX/cparser.mli	/^  | CIRC$/;"	C	type:token
CIRC	cil/obj/x86_LINUX/formatparse.ml	/^  | CIRC$/;"	C	type:token
CIRC	cil/obj/x86_LINUX/formatparse.mli	/^  | CIRC$/;"	C	type:token
CIRC_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | CIRC_EQ$/;"	C	type:token
CIRC_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | CIRC_EQ$/;"	C	type:token
CIRC_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | CIRC_EQ$/;"	C	type:token
CIRC_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | CIRC_EQ$/;"	C	type:token
CInt64	cil/src/cil.mli	/^  | CInt64 of int64 * ikind * string option $/;"	C	type:constant
CList	cil/ocamlutil/clist.ml	/^  | CList of 'a list             (* This is the only representation for empty $/;"	C	type:clist
CList	cil/ocamlutil/clist.mli	/^  | CList of 'a list             (** The only representation for the empty $/;"	C	type:clist
COLON	cil/obj/x86_LINUX/cparser.ml	/^  | COLON$/;"	C	type:token
COLON	cil/obj/x86_LINUX/cparser.mli	/^  | COLON$/;"	C	type:token
COLON	cil/obj/x86_LINUX/formatparse.ml	/^  | COLON$/;"	C	type:token
COLON	cil/obj/x86_LINUX/formatparse.mli	/^  | COLON$/;"	C	type:token
COMMA	cil/obj/x86_LINUX/cparser.ml	/^  | COMMA$/;"	C	type:token
COMMA	cil/obj/x86_LINUX/cparser.mli	/^  | COMMA$/;"	C	type:token
COMMA	cil/obj/x86_LINUX/formatparse.ml	/^  | COMMA$/;"	C	type:token
COMMA	cil/obj/x86_LINUX/formatparse.mli	/^  | COMMA$/;"	C	type:token
COMMA	cil/src/frontc/cabs.ml	/^  | COMMA of expression list$/;"	C	type:expression
COMPGOTO	cil/src/frontc/cabs.ml	/^ | COMPGOTO of expression * cabsloc (* GCC's "goto *exp" *)$/;"	C	type:statement
COMPOUND_INIT	cil/src/frontc/cabs.ml	/^  | COMPOUND_INIT of (initwhat * init_expression) list$/;"	C	type:init_expression
COMPUTATION	cil/src/frontc/cabs.ml	/^ | COMPUTATION of expression * cabsloc$/;"	C	type:statement
CONCRETE	src/base/basic_types.h	/^enum binary_op_t { ADD, SUBTRACT, MULTIPLY, CONCRETE };$/;"	e	enum:crest::ops::binary_op_t
CONST	cil/obj/x86_LINUX/cparser.ml	/^  | CONST of (Cabs.cabsloc)$/;"	C	type:token
CONST	cil/obj/x86_LINUX/cparser.mli	/^  | CONST of (Cabs.cabsloc)$/;"	C	type:token
CONST	cil/obj/x86_LINUX/formatparse.ml	/^  | CONST$/;"	C	type:token
CONST	cil/obj/x86_LINUX/formatparse.mli	/^  | CONST$/;"	C	type:token
CONSTANT	cil/src/frontc/cabs.ml	/^  | CONSTANT of constant$/;"	C	type:expression
CONST_CHAR	cil/src/frontc/cabs.ml	/^  | CONST_CHAR of int64 list$/;"	C	type:constant
CONST_FLOAT	cil/src/frontc/cabs.ml	/^  | CONST_FLOAT of string (* the textual representaton *)$/;"	C	type:constant
CONST_INT	cil/src/frontc/cabs.ml	/^  | CONST_INT of string   (* the textual representation *)$/;"	C	type:constant
CONST_STRING	cil/src/frontc/cabs.ml	/^  | CONST_STRING of string$/;"	C	type:constant
CONST_STRING_LITERALS	cil/src/machdep.c	52;"	d	file:
CONST_STRING_LITERALS	cil/src/machdep.c	60;"	d	file:
CONST_WCHAR	cil/src/frontc/cabs.ml	/^  | CONST_WCHAR of int64 list$/;"	C	type:constant
CONST_WSTRING	cil/src/frontc/cabs.ml	/^  | CONST_WSTRING of int64 list $/;"	C	type:constant
CONTINUE	cil/obj/x86_LINUX/cparser.ml	/^  | CONTINUE of (Cabs.cabsloc)$/;"	C	type:token
CONTINUE	cil/obj/x86_LINUX/cparser.mli	/^  | CONTINUE of (Cabs.cabsloc)$/;"	C	type:token
CONTINUE	cil/obj/x86_LINUX/formatparse.ml	/^  | CONTINUE$/;"	C	type:token
CONTINUE	cil/obj/x86_LINUX/formatparse.mli	/^  | CONTINUE$/;"	C	type:token
CONTINUE	cil/src/frontc/cabs.ml	/^ | CONTINUE of cabsloc$/;"	C	type:statement
CPUINFO_KEY	cil/ocamlutil/perfcount.c	128;"	d	file:
CREST_char	include/crest.h	195;"	d
CREST_char	src/libcrest/crest.h	195;"	d
CREST_char_trace	include/crest.h	203;"	d
CREST_char_trace	src/libcrest/crest.h	203;"	d
CREST_int	include/crest.h	197;"	d
CREST_int	src/libcrest/crest.h	197;"	d
CREST_intA	include/crest.h	198;"	d
CREST_intA	src/libcrest/crest.h	198;"	d
CREST_int_trace	include/crest.h	205;"	d
CREST_int_trace	src/libcrest/crest.h	205;"	d
CREST_log_pc	include/crest.h	211;"	d
CREST_log_pc	src/libcrest/crest.h	211;"	d
CREST_log_spec	include/crest.h	212;"	d
CREST_log_spec	src/libcrest/crest.h	212;"	d
CREST_log_state	include/crest.h	210;"	d
CREST_log_state	src/libcrest/crest.h	210;"	d
CREST_log_state_1	include/crest.h	209;"	d
CREST_log_state_1	src/libcrest/crest.h	209;"	d
CREST_short	include/crest.h	196;"	d
CREST_short	src/libcrest/crest.h	196;"	d
CREST_short_trace	include/crest.h	204;"	d
CREST_short_trace	src/libcrest/crest.h	204;"	d
CREST_unsigned_char	include/crest.h	192;"	d
CREST_unsigned_char	src/libcrest/crest.h	192;"	d
CREST_unsigned_char_trace	include/crest.h	200;"	d
CREST_unsigned_char_trace	src/libcrest/crest.h	200;"	d
CREST_unsigned_int	include/crest.h	194;"	d
CREST_unsigned_int	src/libcrest/crest.h	194;"	d
CREST_unsigned_int_trace	include/crest.h	202;"	d
CREST_unsigned_int_trace	src/libcrest/crest.h	202;"	d
CREST_unsigned_short	include/crest.h	193;"	d
CREST_unsigned_short	src/libcrest/crest.h	193;"	d
CREST_unsigned_short_trace	include/crest.h	201;"	d
CREST_unsigned_short_trace	src/libcrest/crest.h	201;"	d
CREST_var_map	include/crest.h	207;"	d
CREST_var_map	src/libcrest/crest.h	207;"	d
CREST_var_map_1	include/crest.h	208;"	d
CREST_var_map_1	src/libcrest/crest.h	208;"	d
CReal	cil/src/cil.mli	/^  | CReal of float * fkind * string option $/;"	C	type:constant
CST_CHAR	cil/obj/x86_LINUX/cparser.ml	/^  | CST_CHAR of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_CHAR	cil/obj/x86_LINUX/cparser.mli	/^  | CST_CHAR of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_CHAR	cil/obj/x86_LINUX/formatparse.ml	/^  | CST_CHAR of (string)$/;"	C	type:token
CST_CHAR	cil/obj/x86_LINUX/formatparse.mli	/^  | CST_CHAR of (string)$/;"	C	type:token
CST_FLOAT	cil/obj/x86_LINUX/cparser.ml	/^  | CST_FLOAT of (string * Cabs.cabsloc)$/;"	C	type:token
CST_FLOAT	cil/obj/x86_LINUX/cparser.mli	/^  | CST_FLOAT of (string * Cabs.cabsloc)$/;"	C	type:token
CST_FLOAT	cil/obj/x86_LINUX/formatparse.ml	/^  | CST_FLOAT of (string)$/;"	C	type:token
CST_FLOAT	cil/obj/x86_LINUX/formatparse.mli	/^  | CST_FLOAT of (string)$/;"	C	type:token
CST_INT	cil/obj/x86_LINUX/cparser.ml	/^  | CST_INT of (string * Cabs.cabsloc)$/;"	C	type:token
CST_INT	cil/obj/x86_LINUX/cparser.mli	/^  | CST_INT of (string * Cabs.cabsloc)$/;"	C	type:token
CST_INT	cil/obj/x86_LINUX/formatparse.ml	/^  | CST_INT of (string)$/;"	C	type:token
CST_INT	cil/obj/x86_LINUX/formatparse.mli	/^  | CST_INT of (string)$/;"	C	type:token
CST_STRING	cil/obj/x86_LINUX/cparser.ml	/^  | CST_STRING of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_STRING	cil/obj/x86_LINUX/cparser.mli	/^  | CST_STRING of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_STRING	cil/obj/x86_LINUX/formatparse.ml	/^  | CST_STRING of (string)$/;"	C	type:token
CST_STRING	cil/obj/x86_LINUX/formatparse.mli	/^  | CST_STRING of (string)$/;"	C	type:token
CST_WCHAR	cil/obj/x86_LINUX/cparser.ml	/^  | CST_WCHAR of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_WCHAR	cil/obj/x86_LINUX/cparser.mli	/^  | CST_WCHAR of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_WSTRING	cil/obj/x86_LINUX/cparser.ml	/^  | CST_WSTRING of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_WSTRING	cil/obj/x86_LINUX/cparser.mli	/^  | CST_WSTRING of (int64 list * Cabs.cabsloc)$/;"	C	type:token
CST_WSTRING	cil/obj/x86_LINUX/formatparse.ml	/^  | CST_WSTRING of (string)$/;"	C	type:token
CST_WSTRING	cil/obj/x86_LINUX/formatparse.mli	/^  | CST_WSTRING of (string)$/;"	C	type:token
CSeq	cil/ocamlutil/clist.ml	/^  | CSeq  of 'a clist * 'a clist (* We concatenate only two of them at this $/;"	C	type:clist
CSeq	cil/ocamlutil/clist.mli	/^  | CSeq of 'a clist * 'a clist (** We concatenate only two of them at this$/;"	C	type:clist
CStr	cil/src/cil.mli	/^  | CStr of string $/;"	C	type:constant
CTStruct	cil/src/check.ml	/^    CTStruct                            (* In a composite type *)$/;"	C	type:ctxType
CText	cil/ocamlutil/pretty.ml	/^  | CText    of doc * string$/;"	C	type:doc
CV_CONST	cil/src/frontc/cabs.ml	/^    CV_CONST | CV_VOLATILE | CV_RESTRICT$/;"	C	type:cvspec
CV_RESTRICT	cil/src/frontc/cabs.ml	/^    CV_CONST | CV_VOLATILE | CV_RESTRICT$/;"	C	type:cvspec
CV_VOLATILE	cil/src/frontc/cabs.ml	/^    CV_CONST | CV_VOLATILE | CV_RESTRICT$/;"	C	type:cvspec
CWStr	cil/src/cil.mli	/^  | CWStr of int64 list  $/;"	C	type:constant
CXXFLAGS	src/Makefile	/^CXXFLAGS = $(CFLAGS)$/;"	m
Cabs	cil/src/frontc/cabs.ml	1;"	M
Cabs2cil	cil/src/frontc/cabs2cil.ml	1;"	M
Cabs2cil	cil/src/frontc/cabs2cil.mli	1;"	M
CabsOnly	cil/src/frontc/frontc.mli	/^exception CabsOnly$/;"	e
Cabshelper	cil/src/frontc/cabshelper.ml	1;"	M
Cabsvisit	cil/src/frontc/cabsvisit.ml	1;"	M
Cabsvisit	cil/src/frontc/cabsvisit.mli	1;"	M
Call	cil/src/cil.mli	/^  | Call       of lval option * exp * exp list * location$/;"	C	type:instr
Call	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::Call(id_t id, function_id_t fid) {$/;"	f	class:crest::SymbolicInterpreter
CallGraph	cil/src/ext/partial.ml	1;"	M
CallGraph'	cil/src/ext/partial.ml	1;"	M
Callgraph	cil/src/ext/callgraph.ml	1;"	M
Callgraph	cil/src/ext/callgraph.mli	1;"	M
Canonicalize	cil/src/ext/canonicalize.ml	1;"	M
Canonicalize	cil/src/ext/canonicalize.mli	1;"	M
Case	cil/src/cil.mli	/^  | Case of exp * location              (** A case statement. This expression $/;"	C	type:label
CastE	cil/src/cil.mli	/^  | CastE      of typ * exp            $/;"	C	type:exp
Cfg	cil/src/ext/cfg.ml	1;"	M
Cfg	cil/src/ext/cfg.mli	1;"	M
CfgBaselineSearch	src/run_crest/concolic_search.cc	/^CfgBaselineSearch::CfgBaselineSearch(const string& program, int max_iterations)$/;"	f	class:crest::CfgBaselineSearch
CfgBaselineSearch	src/run_crest/concolic_search.h	/^class CfgBaselineSearch : public Search {$/;"	c	namespace:crest
CfgHeuristicSearch	src/run_crest/concolic_search.cc	/^CfgHeuristicSearch::CfgHeuristicSearch$/;"	f	class:crest::CfgHeuristicSearch
CfgHeuristicSearch	src/run_crest/concolic_search.h	/^class CfgHeuristicSearch : public Search {$/;"	c	namespace:crest
Check	cil/src/check.ml	1;"	M
Check	cil/src/check.mli	1;"	M
CheckPrediction	src/run_crest/concolic_search.cc	/^bool Search::CheckPrediction(const SymbolicExecution& old_ex,$/;"	f	class:crest::Search
Cil	cil/src/cil.ml	1;"	M
Cil	cil/src/cil.mli	1;"	M
CilCompiler	cil/bin/cilly	/^package CilCompiler;$/;"	p
Cillower	cil/src/cillower.ml	1;"	M
Cillower	cil/src/cillower.mli	1;"	M
Cilly	cil/lib/Cilly.pm	/^package Cilly;$/;"	p
CillyCommand	cil/bin/cilly	/^sub CillyCommand {$/;"	s
Ciloptions	cil/src/ciloptions.ml	1;"	M
Ciloptions	cil/src/ciloptions.mli	1;"	M
Ciltools	cil/src/ext/ciltools.ml	1;"	M
Cilutil	cil/src/cilutil.ml	1;"	M
Cilversion	cil/obj/x86_LINUX/cilversion.ml	1;"	M
ClearAllMaps	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ClearAllMaps()$/;"	f	class:crest::SymbolicInterpreter
ClearPredicateRegister	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ClearPredicateRegister() {$/;"	f	class:crest::SymbolicInterpreter
ClearStack	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::ClearStack(id_t id) {$/;"	f	class:crest::SymbolicInterpreter
Clexer	cil/obj/x86_LINUX/clexer.ml	1;"	M
Clexer	cil/obj/x86_LINUX/clexer.mli	1;"	M
Clexer	cil/src/frontc/clexer.mli	1;"	M
Clist	cil/ocamlutil/clist.ml	1;"	M
Clist	cil/ocamlutil/clist.mli	1;"	M
CollectNextBranches	src/run_crest/concolic_search.cc	/^void CfgHeuristicSearch::CollectNextBranches$/;"	f	class:crest::CfgHeuristicSearch
CompoundInit	cil/src/cil.mli	/^  | CompoundInit   of typ * (offset * init) list$/;"	C	type:init
Concat	cil/ocamlutil/pretty.ml	/^  | Concat   of doc * doc$/;"	C	type:doc
Cons	cil/ocamlutil/inthash.ml	/^  | Cons of int * 'a * 'a bucketlist$/;"	C	type:bucketlist
Const	cil/src/cil.mli	/^    Const      of constant              (** Constant *)$/;"	C	type:exp
ConstIt	src/base/symbolic_expression.cc	/^typedef map<var_t,value_t>::const_iterator ConstIt;$/;"	t	namespace:crest	file:
ConstMemIt	src/base/symbolic_interpreter.cc	/^    typedef map<addr_t,SymbolicExpr*>::const_iterator ConstMemIt;$/;"	t	namespace:crest	file:
Continue	cil/src/cil.mli	/^  | Continue of location                $/;"	C	type:stmtkind
Cparser	cil/obj/x86_LINUX/cparser.ml	1;"	M
Cparser	cil/obj/x86_LINUX/cparser.mli	1;"	M
Cprint	cil/src/frontc/cprint.ml	1;"	M
CreateVarMap	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::CreateVarMap(addr_t addr, string* name, int tp, string* trigger) {$/;"	f	class:crest::SymbolicInterpreter
CrestInstrument	cil/src/ext/crestInstrument.ml	1;"	M
DEBUG	cil/libstr/src/gc_content.c	31;"	d	file:
DEB_BUILD_GNU_TYPE	cil/debian/rules	/^DEB_BUILD_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)$/;"	m
DEB_HOST_GNU_TYPE	cil/debian/rules	/^DEB_HOST_GNU_TYPE   ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)$/;"	m
DECDEF	cil/src/frontc/cabs.ml	/^ | DECDEF of init_name_group * cabsloc        (* global variable(s), or function prototype *)$/;"	C	type:definition
DECLSPEC	cil/obj/x86_LINUX/cparser.ml	/^  | DECLSPEC of (Cabs.cabsloc)$/;"	C	type:token
DECLSPEC	cil/obj/x86_LINUX/cparser.mli	/^  | DECLSPEC of (Cabs.cabsloc)$/;"	C	type:token
DECLSPEC	cil/obj/x86_LINUX/formatparse.ml	/^  | DECLSPEC$/;"	C	type:token
DECLSPEC	cil/obj/x86_LINUX/formatparse.mli	/^  | DECLSPEC$/;"	C	type:token
DEFAULT	cil/obj/x86_LINUX/cparser.ml	/^  | DEFAULT of (Cabs.cabsloc)$/;"	C	type:token
DEFAULT	cil/obj/x86_LINUX/cparser.mli	/^  | DEFAULT of (Cabs.cabsloc)$/;"	C	type:token
DEFAULT	cil/obj/x86_LINUX/formatparse.ml	/^  | DEFAULT$/;"	C	type:token
DEFAULT	cil/obj/x86_LINUX/formatparse.mli	/^  | DEFAULT$/;"	C	type:token
DEFAULT	cil/src/frontc/cabs.ml	/^ | DEFAULT of statement * cabsloc$/;"	C	type:statement
DEFAULT_COMPILER	cil/config.mk	/^export DEFAULT_COMPILER=_GNUCC$/;"	m
DEFINITION	cil/src/frontc/cabs.ml	/^ | DEFINITION of definition (*definition or declaration of a variable or type*)$/;"	C	type:statement
DEPENDDIR	cil/Makefile	/^DEPENDDIR   := obj\/.depend$/;"	m
DF	cil/src/ext/liveness.ml	1;"	M
DFS	src/run_crest/concolic_search.cc	/^void BoundedDepthFirstSearch::DFS(size_t pos, int depth, SymbolicExecution& prev_ex) {$/;"	f	class:crest::BoundedDepthFirstSearch
DISTRIB_BIN	cil/Makefile	/^DISTRIB_BIN = CilConfig.pm.in cilly cilly.bat.in \\$/;"	m
DISTRIB_LIB	cil/Makefile	/^DISTRIB_LIB = Cilly.pm KeptFile.pm OutputFile.pm TempFile.pm$/;"	m
DISTRIB_OCAMLUTIL	cil/Makefile	/^DISTRIB_OCAMLUTIL = pretty.ml pretty.mli errormsg.ml errormsg.mli \\$/;"	m
DISTRIB_ROOT	cil/Makefile	/^DISTRIB_ROOT = README LICENSE INSTALL Makefile.in  \\$/;"	m
DISTRIB_SMALL1	cil/Makefile	/^DISTRIB_SMALL1=hello.c func.c init.c init1.c wchar1.c vararg1.c testharness.h $/;"	m
DISTRIB_SRC	cil/Makefile	/^DISTRIB_SRC = cilutil.ml cil.ml cil.mli check.ml check.mli \\$/;"	m
DISTRIB_SRC_EXT	cil/Makefile	/^DISTRIB_SRC_EXT = logcalls.ml logcalls.mli \\$/;"	m
DISTRIB_SRC_EXT_PTA	cil/Makefile	/^DISTRIB_SRC_EXT_PTA = setp.ml setp.mli golf.ml golf.mli \\$/;"	m
DISTRIB_SRC_FRONTC	cil/Makefile	/^DISTRIB_SRC_FRONTC = cabs.ml cabshelper.ml cprint.ml clexer.mli clexer.mll \\$/;"	m
DIV	cil/src/frontc/cabs.ml	/^    ADD | SUB | MUL | DIV | MOD$/;"	C	type:binary_operator
DIV_ASSIGN	cil/src/frontc/cabs.ml	/^  | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN$/;"	C	type:binary_operator
DO	cil/obj/x86_LINUX/cparser.ml	/^  | DO of (Cabs.cabsloc)$/;"	C	type:token
DO	cil/obj/x86_LINUX/cparser.mli	/^  | DO of (Cabs.cabsloc)$/;"	C	type:token
DO	cil/obj/x86_LINUX/formatparse.ml	/^  | DO$/;"	C	type:token
DO	cil/obj/x86_LINUX/formatparse.mli	/^  | DO$/;"	C	type:token
DOT	cil/obj/x86_LINUX/cparser.ml	/^  | DOT$/;"	C	type:token
DOT	cil/obj/x86_LINUX/cparser.mli	/^  | DOT$/;"	C	type:token
DOT	cil/obj/x86_LINUX/formatparse.ml	/^  | DOT$/;"	C	type:token
DOT	cil/obj/x86_LINUX/formatparse.mli	/^  | DOT$/;"	C	type:token
DOUBLE	cil/obj/x86_LINUX/cparser.ml	/^  | DOUBLE of (Cabs.cabsloc)$/;"	C	type:token
DOUBLE	cil/obj/x86_LINUX/cparser.mli	/^  | DOUBLE of (Cabs.cabsloc)$/;"	C	type:token
DOUBLE	cil/obj/x86_LINUX/formatparse.ml	/^  | DOUBLE$/;"	C	type:token
DOUBLE	cil/obj/x86_LINUX/formatparse.mli	/^  | DOUBLE$/;"	C	type:token
DOWHILE	cil/src/frontc/cabs.ml	/^ | DOWHILE of expression * statement * cabsloc$/;"	C	type:statement
DT	cil/src/ext/dominators.ml	1;"	M
Dataflow	cil/src/ext/dataflow.ml	1;"	M
Dataflow	cil/src/ext/dataflow.mli	1;"	M
Dataslicing	cil/src/ext/dataslicing.ml	1;"	M
Dataslicing	cil/src/ext/dataslicing.mli	1;"	M
Deadcodeelim	cil/src/ext/deadcodeelim.ml	1;"	M
Default	cil/src/cil.mli	/^  | Default of location                 (** A default statement *)$/;"	C	type:label
Default	cil/src/ext/dataflow.mli	/^    Default (** The default action *)$/;"	C	type:action
DependsOn	src/base/symbolic_expression.cc	/^bool SymbolicExpr::DependsOn(const map<var_t,type_t>& vars) const {$/;"	f	class:crest::SymbolicExpr
DependsOn	src/base/symbolic_predicate.h	/^  bool DependsOn(const map<var_t,type_t>& vars) const {$/;"	f	class:crest::SymbolicPred
Disabled	cil/ocamlutil/stats.ml	/^  | Disabled      (** Do not collect timing information *)$/;"	C	type:timerModeEnum
Disabled	cil/ocamlutil/stats.mli	/^  | Disabled      (** Do not collect timing information *)$/;"	C	type:timerModeEnum
DoBoundedBFS	src/run_crest/concolic_search.cc	/^bool CfgHeuristicSearch::DoBoundedBFS(int i, int depth, const SymbolicExecution& prev_ex) {$/;"	f	class:crest::CfgHeuristicSearch
DoMerge	cil/lib/Cilly.pm	/^      DoMerge:$/;"	l
DoSearch	src/run_crest/concolic_search.cc	/^bool CfgBaselineSearch::DoSearch(int depth, int iters, int pos,$/;"	f	class:crest::CfgBaselineSearch
DoSearch	src/run_crest/concolic_search.cc	/^bool CfgHeuristicSearch::DoSearch(int depth,$/;"	f	class:crest::CfgHeuristicSearch
DoUniformRandomPath	src/run_crest/concolic_search.cc	/^void UniformRandomSearch::DoUniformRandomPath() {$/;"	f	class:crest::UniformRandomSearch
Dom	cil/src/ext/dominators.ml	1;"	M
Dominators	cil/src/ext/dominators.ml	1;"	M
Dominators	cil/src/ext/dominators.mli	1;"	M
DumpMemory	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::DumpMemory() {$/;"	f	class:crest::SymbolicInterpreter
E	cil/obj/x86_LINUX/clexer.ml	1;"	M
E	cil/obj/x86_LINUX/cparser.ml	1;"	M
E	cil/obj/x86_LINUX/formatparse.ml	1;"	M
E	cil/ocamlutil/longarray.ml	1;"	M
E	cil/ocamlutil/util.ml	1;"	M
E	cil/src/check.ml	1;"	M
E	cil/src/cil.ml	1;"	M
E	cil/src/cillower.ml	1;"	M
E	cil/src/ciloptions.ml	1;"	M
E	cil/src/ext/astslicer.ml	1;"	M
E	cil/src/ext/availexps.ml	1;"	M
E	cil/src/ext/availexpslv.ml	1;"	M
E	cil/src/ext/blockinggraph.ml	1;"	M
E	cil/src/ext/canonicalize.ml	1;"	M
E	cil/src/ext/cfg.ml	1;"	M
E	cil/src/ext/dataslicing.ml	1;"	M
E	cil/src/ext/deadcodeelim.ml	1;"	M
E	cil/src/ext/dominators.ml	1;"	M
E	cil/src/ext/expcompare.ml	1;"	M
E	cil/src/ext/logcalls.ml	1;"	M
E	cil/src/ext/logwrites.ml	1;"	M
E	cil/src/ext/oneret.ml	1;"	M
E	cil/src/ext/predabst.ml	1;"	M
E	cil/src/ext/reachingdefs.ml	1;"	M
E	cil/src/ext/sfi.ml	1;"	M
E	cil/src/ext/simplify.ml	1;"	M
E	cil/src/ext/usedef.ml	1;"	M
E	cil/src/formatcil.ml	1;"	M
E	cil/src/frontc/cabsvisit.ml	1;"	M
E	cil/src/frontc/frontc.ml	1;"	M
E	cil/src/frontc/lexerhack.ml	1;"	M
E	cil/src/libmaincil.ml	1;"	M
E	cil/src/testcil.ml	1;"	M
E	cil/test/small1/testharness.h	15;"	d
ECHO	cil/Makefile	/^ECHO = @$/;"	m
ELLIPSIS	cil/obj/x86_LINUX/cparser.ml	/^  | ELLIPSIS$/;"	C	type:token
ELLIPSIS	cil/obj/x86_LINUX/cparser.mli	/^  | ELLIPSIS$/;"	C	type:token
ELLIPSIS	cil/obj/x86_LINUX/formatparse.ml	/^  | ELLIPSIS$/;"	C	type:token
ELLIPSIS	cil/obj/x86_LINUX/formatparse.mli	/^  | ELLIPSIS$/;"	C	type:token
ELSE	cil/obj/x86_LINUX/cparser.ml	/^  | ELSE$/;"	C	type:token
ELSE	cil/obj/x86_LINUX/cparser.mli	/^  | ELSE$/;"	C	type:token
ELSE	cil/obj/x86_LINUX/formatparse.ml	/^  | ELSE$/;"	C	type:token
ELSE	cil/obj/x86_LINUX/formatparse.mli	/^  | ELSE$/;"	C	type:token
ENUM	cil/obj/x86_LINUX/cparser.ml	/^  | ENUM of (Cabs.cabsloc)$/;"	C	type:token
ENUM	cil/obj/x86_LINUX/cparser.mli	/^  | ENUM of (Cabs.cabsloc)$/;"	C	type:token
ENUM	cil/obj/x86_LINUX/formatparse.ml	/^  | ENUM$/;"	C	type:token
ENUM	cil/obj/x86_LINUX/formatparse.mli	/^  | ENUM$/;"	C	type:token
EOF	cil/obj/x86_LINUX/cparser.ml	/^  | EOF$/;"	C	type:token
EOF	cil/obj/x86_LINUX/cparser.mli	/^  | EOF$/;"	C	type:token
EOF	cil/obj/x86_LINUX/formatparse.ml	/^  | EOF$/;"	C	type:token
EOF	cil/obj/x86_LINUX/formatparse.mli	/^  | EOF$/;"	C	type:token
EQ	cil/obj/x86_LINUX/cparser.ml	/^  | EQ$/;"	C	type:token
EQ	cil/obj/x86_LINUX/cparser.mli	/^  | EQ$/;"	C	type:token
EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | EQ$/;"	C	type:token
EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | EQ$/;"	C	type:token
EQ	cil/src/frontc/cabs.ml	/^  | EQ | NE | LT | GT | LE | GE$/;"	C	type:binary_operator
EQ	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	e	enum:crest::ops::compare_op_t
EQ_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | EQ_EQ$/;"	C	type:token
EQ_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | EQ_EQ$/;"	C	type:token
EQ_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | EQ_EQ$/;"	C	type:token
EQ_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | EQ_EQ$/;"	C	type:token
ERROR	cil/test/small1/init.c	119;"	d	file:
EXCEPT	cil/obj/x86_LINUX/cparser.ml	/^  | EXCEPT of (Cabs.cabsloc)$/;"	C	type:token
EXCEPT	cil/obj/x86_LINUX/cparser.mli	/^  | EXCEPT of (Cabs.cabsloc)$/;"	C	type:token
EXCEPTIONError	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">exception<\/span> <a name="EXCEPTIONError"><\/a>Error<\/pre>$/;"	a
EXCEPTIONLenOfArray	cil/doc/api/Cil.html	/^<pre><span class="keyword">exception<\/span> <a name="EXCEPTIONLenOfArray"><\/a>LenOfArray<\/pre>$/;"	a
EXCEPTIONNoPerfCount	cil/doc/api/Stats.html	/^<pre><span class="keyword">exception<\/span> <a name="EXCEPTIONNoPerfCount"><\/a>NoPerfCount<\/pre>$/;"	a
EXCEPTIONNotAnAttrParam	cil/doc/api/Cil.html	/^<pre><span class="keyword">exception<\/span> <a name="EXCEPTIONNotAnAttrParam"><\/a>NotAnAttrParam <span class="keyword">of<\/span> <code class="type"><a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre>$/;"	a
EXCEPTIONSizeOfError	cil/doc/api/Cil.html	/^<pre><span class="keyword">exception<\/span> <a name="EXCEPTIONSizeOfError"><\/a>SizeOfError <span class="keyword">of<\/span> <code class="type">string * <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre>$/;"	a
EXCLAM	cil/obj/x86_LINUX/cparser.ml	/^  | EXCLAM of (Cabs.cabsloc)$/;"	C	type:token
EXCLAM	cil/obj/x86_LINUX/cparser.mli	/^  | EXCLAM of (Cabs.cabsloc)$/;"	C	type:token
EXCLAM	cil/obj/x86_LINUX/formatparse.ml	/^  | EXCLAM$/;"	C	type:token
EXCLAM	cil/obj/x86_LINUX/formatparse.mli	/^  | EXCLAM$/;"	C	type:token
EXCLAM_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | EXCLAM_EQ$/;"	C	type:token
EXCLAM_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | EXCLAM_EQ$/;"	C	type:token
EXCLAM_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | EXCLAM_EQ$/;"	C	type:token
EXCLAM_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | EXCLAM_EQ$/;"	C	type:token
EXPLICIT	cil/src/frontc/cabs.ml	/^    INLINE | VIRTUAL | EXPLICIT$/;"	C	type:funspec
EXPRTRANSFORMER	cil/src/frontc/cabs.ml	/^ | EXPRTRANSFORMER of expression * expression * cabsloc$/;"	C	type:definition
EXPR_ALIGNOF	cil/src/frontc/cabs.ml	/^  | EXPR_ALIGNOF of expression$/;"	C	type:expression
EXPR_PATTERN	cil/src/frontc/cabs.ml	/^  | EXPR_PATTERN of string     (* pattern variable, and name *)$/;"	C	type:expression
EXPR_SIZEOF	cil/src/frontc/cabs.ml	/^  | EXPR_SIZEOF of expression$/;"	C	type:expression
EXTERN	cil/obj/x86_LINUX/cparser.ml	/^  | EXTERN of (Cabs.cabsloc)$/;"	C	type:token
EXTERN	cil/obj/x86_LINUX/cparser.mli	/^  | EXTERN of (Cabs.cabsloc)$/;"	C	type:token
EXTERN	cil/obj/x86_LINUX/formatparse.ml	/^  | EXTERN$/;"	C	type:token
EXTERN	cil/obj/x86_LINUX/formatparse.mli	/^  | EXTERN$/;"	C	type:token
EXTERN	cil/src/frontc/cabs.ml	/^    NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER$/;"	C	type:storage
EXTERN	include/crest.h	110;"	d
EXTERN	include/crest.h	112;"	d
EXTERN	src/libcrest/crest.h	110;"	d
EXTERN	src/libcrest/crest.h	112;"	d
EasyAlias	cil/src/ext/partial.ml	1;"	M
EasyCallGraph	cil/src/ext/partial.ml	1;"	M
Ecr	cil/src/ext/pta/uref.ml	/^    Ecr of 'a * int$/;"	C	type:urefC
Elem	cil/ocamlutil/growArray.mli	/^    Elem of 'a$/;"	C	type:fill
Empty	cil/ocamlutil/inthash.ml	/^    Empty$/;"	C	type:bucketlist
Empty	cil/ocamlutil/intmap.ml	/^    Empty$/;"	C	type:t
Empty	cil/ocamlutil/util.mli	/^  exception Empty$/;"	e	Module:STACK
End	cil/ocamlutil/intmap.ml	/^type 'a enumeration = End | More of int * 'a * 'a t * 'a enumeration$/;"	C	type:enumeration
Eof	cil/obj/x86_LINUX/clexer.ml	/^exception Eof$/;"	e
Eof	cil/obj/x86_LINUX/formatlex.ml	/^exception Eof$/;"	e
Epicenter	cil/src/ext/epicenter.ml	1;"	M
Equal	src/base/symbolic_predicate.cc	/^bool SymbolicPred::Equal(const SymbolicPred& p) const {$/;"	f	class:crest::SymbolicPred
Error	cil/ocamlutil/errormsg.ml	/^exception Error$/;"	e
Error	cil/ocamlutil/errormsg.mli	/^exception Error$/;"	e
Errormsg	cil/ocamlutil/errormsg.ml	1;"	M
Errormsg	cil/ocamlutil/errormsg.mli	1;"	M
Escape	cil/src/escape.ml	1;"	M
Escape	cil/src/escape.mli	1;"	M
ExistsTrue	cil/src/cil.ml	/^    ExistsTrue                          (* We have found it *)$/;"	C	type:existsAction
ExistsTrue	cil/src/cil.mli	/^    ExistsTrue                          (** We have found it *)$/;"	C	type:existsAction
Expcompare	cil/src/ext/expcompare.ml	1;"	M
F	cil/src/ext/pta/ptranal.ml	1;"	M
F	cil/src/main.ml	1;"	M
FC_DECL	cil/src/frontc/cabs.ml	/^ | FC_DECL of definition$/;"	C	type:for_clause
FC_EXP	cil/src/frontc/cabs.ml	/^   FC_EXP of expression$/;"	C	type:for_clause
FFloat	cil/src/cil.mli	/^    FFloat      (** [float] *)$/;"	C	type:fkind
FINALLY	cil/obj/x86_LINUX/cparser.ml	/^  | FINALLY of (Cabs.cabsloc)$/;"	C	type:token
FINALLY	cil/obj/x86_LINUX/cparser.mli	/^  | FINALLY of (Cabs.cabsloc)$/;"	C	type:token
FLOAT	cil/obj/x86_LINUX/cparser.ml	/^  | FLOAT of (Cabs.cabsloc)$/;"	C	type:token
FLOAT	cil/obj/x86_LINUX/cparser.mli	/^  | FLOAT of (Cabs.cabsloc)$/;"	C	type:token
FLOAT	cil/obj/x86_LINUX/formatparse.ml	/^  | FLOAT$/;"	C	type:token
FLOAT	cil/obj/x86_LINUX/formatparse.mli	/^  | FLOAT$/;"	C	type:token
FOR	cil/obj/x86_LINUX/cparser.ml	/^  | FOR of (Cabs.cabsloc)$/;"	C	type:token
FOR	cil/obj/x86_LINUX/cparser.mli	/^  | FOR of (Cabs.cabsloc)$/;"	C	type:token
FOR	cil/obj/x86_LINUX/formatparse.ml	/^  | FOR$/;"	C	type:token
FOR	cil/obj/x86_LINUX/formatparse.mli	/^  | FOR$/;"	C	type:token
FOR	cil/src/frontc/cabs.ml	/^ | FOR of for_clause * expression * expression * statement * cabsloc$/;"	C	type:statement
FUNCTION__	cil/obj/x86_LINUX/cparser.ml	/^  | FUNCTION__ of (Cabs.cabsloc)$/;"	C	type:token
FUNCTION__	cil/obj/x86_LINUX/cparser.mli	/^  | FUNCTION__ of (Cabs.cabsloc)$/;"	C	type:token
FUNCTION__	cil/obj/x86_LINUX/formatparse.ml	/^  | FUNCTION__$/;"	C	type:token
FUNCTION__	cil/obj/x86_LINUX/formatparse.mli	/^  | FUNCTION__$/;"	C	type:token
FUNDEF	cil/src/frontc/cabs.ml	/^   FUNDEF of single_name * block * cabsloc * cabsloc$/;"	C	type:definition
Feature_config	cil/obj/x86_LINUX/feature_config.ml	1;"	M
FindAlongCfg	src/run_crest/concolic_search.cc	/^bool CfgHeuristicSearch::FindAlongCfg(size_t i, unsigned int dist,$/;"	f	class:crest::CfgHeuristicSearch
Formatcil	cil/src/formatcil.ml	1;"	M
Formatcil	cil/src/formatcil.mli	1;"	M
Formatlex	cil/obj/x86_LINUX/formatlex.ml	1;"	M
Formatparse	cil/obj/x86_LINUX/formatparse.ml	1;"	M
Formatparse	cil/obj/x86_LINUX/formatparse.mli	1;"	M
ForwardsDataFlow	cil/src/ext/dataflow.ml	1;"	M
ForwardsDataFlow	cil/src/ext/dataflow.mli	1;"	M
ForwardsTransfer	cil/src/ext/dataflow.mli	1;"	M
FreeMap	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::FreeMap(map<addr_t,string*> z)$/;"	f	class:crest::SymbolicInterpreter
Frontc	cil/src/frontc/frontc.ml	1;"	M
Frontc	cil/src/frontc/frontc.mli	1;"	M
GAsm	cil/src/cil.mli	/^  | GAsm of string * location           (** Global asm statement. These ones $/;"	C	type:global
GCompTag	cil/src/cil.mli	/^  | GCompTag of compinfo * location     $/;"	C	type:global
GCompTagDecl	cil/src/cil.mli	/^  | GCompTagDecl of compinfo * location$/;"	C	type:global
GDefault	cil/src/ext/dataflow.mli	/^    GDefault      (** The default state *) $/;"	C	type:guardaction
GE	cil/src/frontc/cabs.ml	/^  | EQ | NE | LT | GT | LE | GE$/;"	C	type:binary_operator
GE	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	e	enum:crest::ops::compare_op_t
GETCOUNTER	cil/ocamlutil/perfcount.c	21;"	d	file:
GETCOUNTER	cil/ocamlutil/perfcount.c	24;"	d	file:
GETCOUNTER	cil/ocamlutil/perfcount.c	32;"	d	file:
GEnumTag	cil/src/cil.mli	/^  | GEnumTag of enuminfo * location$/;"	C	type:global
GEnumTagDecl	cil/src/cil.mli	/^  | GEnumTagDecl of enuminfo * location$/;"	C	type:global
GFun	cil/src/cil.mli	/^  | GFun of fundec * location           $/;"	C	type:global
GLOBASM	cil/src/frontc/cabs.ml	/^ | GLOBASM of string * cabsloc$/;"	C	type:definition
GNUCC	cil/lib/Cilly.pm	/^package GNUCC;$/;"	p
GNU_BODY	cil/src/frontc/cabs.ml	/^  | GNU_BODY of block$/;"	C	type:expression
GOTO	cil/obj/x86_LINUX/cparser.ml	/^  | GOTO of (Cabs.cabsloc)$/;"	C	type:token
GOTO	cil/obj/x86_LINUX/cparser.mli	/^  | GOTO of (Cabs.cabsloc)$/;"	C	type:token
GOTO	cil/obj/x86_LINUX/formatparse.ml	/^  | GOTO$/;"	C	type:token
GOTO	cil/obj/x86_LINUX/formatparse.mli	/^  | GOTO$/;"	C	type:token
GOTO	cil/src/frontc/cabs.ml	/^ | GOTO of string * cabsloc$/;"	C	type:statement
GPragma	cil/src/cil.mli	/^  | GPragma of attribute * location     (** Pragmas at top level. Use the same $/;"	C	type:global
GT	cil/src/frontc/cabs.ml	/^  | EQ | NE | LT | GT | LE | GE$/;"	C	type:binary_operator
GT	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	e	enum:crest::ops::compare_op_t
GText	cil/src/cil.mli	/^  | GText of string                     (** Some text (printed verbatim) at $/;"	C	type:global
GType	cil/src/cil.mli	/^  | GType of typeinfo * location    $/;"	C	type:global
GVar	cil/src/cil.mli	/^  | GVar  of varinfo * initinfo * location$/;"	C	type:global
GVarDecl	cil/src/cil.mli	/^  | GVarDecl of varinfo * location$/;"	C	type:global
Gap	cil/ocamlutil/pretty.ml	/^type algo = George | Aman | Gap$/;"	C	type:algo
George	cil/ocamlutil/pretty.ml	/^type algo = George | Aman | Gap$/;"	C	type:algo
Golf	cil/src/ext/pta/golf.ml	1;"	M
Golf	cil/src/ext/pta/golf.mli	1;"	M
GotSignal	cil/ocamlutil/util.mli	/^exception GotSignal of int$/;"	e
Goto	cil/src/cil.mli	/^  | Goto of stmt ref * location         $/;"	C	type:stmtkind
GrowArray	cil/ocamlutil/growArray.ml	1;"	M
GrowArray	cil/ocamlutil/growArray.mli	1;"	M
H	cil/obj/x86_LINUX/formatlex.ml	1;"	M
H	cil/ocamlutil/alpha.ml	1;"	M
H	cil/src/ext/epicenter.ml	1;"	M
H	cil/src/ext/pta/ptranal.ml	1;"	M
H	cil/src/ext/stackoverflow.ml	1;"	M
H	cil/src/rmtmps.ml	1;"	M
HAS_MSVC	cil/config.mk	/^export HAS_MSVC=no$/;"	m
HAVE_MKDIR	cil/config.h	20;"	d
HAVE_SELECT	cil/config.h	22;"	d
HAVE_SOCKET	cil/config.h	24;"	d
HAVE_STDLIB_H	cil/config.h	4;"	d
HAVE_STRINGS_H	cil/config.h	6;"	d
HAVE_SYS_TIME_H	cil/config.h	8;"	d
HAVE_UNISTD_H	cil/config.h	10;"	d
HandleReturn	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::HandleReturn(id_t id, value_t value) {$/;"	f	class:crest::SymbolicInterpreter
Heap	cil/src/ext/heap.ml	1;"	M
Heapify	cil/src/ext/heapify.ml	1;"	M
HybridSearch	src/run_crest/concolic_search.cc	/^HybridSearch::HybridSearch(const string& program, int max_iterations, int step_size)$/;"	f	class:crest::HybridSearch
HybridSearch	src/run_crest/concolic_search.h	/^class HybridSearch : public Search {$/;"	c	namespace:crest
IChar	cil/src/cil.mli	/^    IChar       (** [char] *)$/;"	C	type:ikind
IDENT	cil/obj/x86_LINUX/cparser.ml	/^  | IDENT of (string * Cabs.cabsloc)$/;"	C	type:token
IDENT	cil/obj/x86_LINUX/cparser.mli	/^  | IDENT of (string * Cabs.cabsloc)$/;"	C	type:token
IDENT	cil/obj/x86_LINUX/formatparse.ml	/^  | IDENT of (string)$/;"	C	type:token
IDENT	cil/obj/x86_LINUX/formatparse.mli	/^  | IDENT of (string)$/;"	C	type:token
IF	cil/obj/x86_LINUX/cparser.ml	/^  | IF of (Cabs.cabsloc)$/;"	C	type:token
IF	cil/obj/x86_LINUX/cparser.mli	/^  | IF of (Cabs.cabsloc)$/;"	C	type:token
IF	cil/obj/x86_LINUX/formatparse.ml	/^  | IF$/;"	C	type:token
IF	cil/obj/x86_LINUX/formatparse.mli	/^  | IF$/;"	C	type:token
IF	cil/src/frontc/cabs.ml	/^ | IF of expression * statement * statement * cabsloc$/;"	C	type:statement
IFDEBUG	src/base/symbolic_interpreter.cc	26;"	d	file:
IH	cil/src/ext/dataflow.ml	1;"	M
INDEX	cil/src/frontc/cabs.ml	/^  | INDEX of expression * expression$/;"	C	type:expression
INF	cil/obj/x86_LINUX/cparser.ml	/^  | INF$/;"	C	type:token
INF	cil/obj/x86_LINUX/cparser.mli	/^  | INF$/;"	C	type:token
INF	cil/obj/x86_LINUX/formatparse.ml	/^  | INF$/;"	C	type:token
INF	cil/obj/x86_LINUX/formatparse.mli	/^  | INF$/;"	C	type:token
INFIELD_INIT	cil/src/frontc/cabs.ml	/^  | INFIELD_INIT of string * initwhat$/;"	C	type:initwhat
INF_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | INF_EQ$/;"	C	type:token
INF_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | INF_EQ$/;"	C	type:token
INF_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | INF_EQ$/;"	C	type:token
INF_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | INF_EQ$/;"	C	type:token
INF_INF	cil/obj/x86_LINUX/cparser.ml	/^  | INF_INF$/;"	C	type:token
INF_INF	cil/obj/x86_LINUX/cparser.mli	/^  | INF_INF$/;"	C	type:token
INF_INF	cil/obj/x86_LINUX/formatparse.ml	/^  | INF_INF$/;"	C	type:token
INF_INF	cil/obj/x86_LINUX/formatparse.mli	/^  | INF_INF$/;"	C	type:token
INF_INF_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | INF_INF_EQ$/;"	C	type:token
INF_INF_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | INF_INF_EQ$/;"	C	type:token
INF_INF_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | INF_INF_EQ$/;"	C	type:token
INF_INF_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | INF_INF_EQ$/;"	C	type:token
INLINE	cil/obj/x86_LINUX/cparser.ml	/^  | INLINE of (Cabs.cabsloc)$/;"	C	type:token
INLINE	cil/obj/x86_LINUX/cparser.mli	/^  | INLINE of (Cabs.cabsloc)$/;"	C	type:token
INLINE	cil/obj/x86_LINUX/formatparse.ml	/^  | INLINE$/;"	C	type:token
INLINE	cil/obj/x86_LINUX/formatparse.mli	/^  | INLINE$/;"	C	type:token
INLINE	cil/src/frontc/cabs.ml	/^    INLINE | VIRTUAL | EXPLICIT$/;"	C	type:funspec
INSTALL	cil/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	cil/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INT	cil/obj/x86_LINUX/cparser.ml	/^  | INT of (Cabs.cabsloc)$/;"	C	type:token
INT	cil/obj/x86_LINUX/cparser.mli	/^  | INT of (Cabs.cabsloc)$/;"	C	type:token
INT	cil/obj/x86_LINUX/formatparse.ml	/^  | INT$/;"	C	type:token
INT	cil/obj/x86_LINUX/formatparse.mli	/^  | INT$/;"	C	type:token
INT	src/base/basic_types.h	/^	      U_INT = 4,        INT = 5,$/;"	e	enum:crest::types::type_t
INT32	cil/obj/x86_LINUX/cparser.ml	/^  | INT32 of (Cabs.cabsloc)$/;"	C	type:token
INT32	cil/obj/x86_LINUX/cparser.mli	/^  | INT32 of (Cabs.cabsloc)$/;"	C	type:token
INT32	cil/obj/x86_LINUX/formatparse.ml	/^  | INT32$/;"	C	type:token
INT32	cil/obj/x86_LINUX/formatparse.mli	/^  | INT32$/;"	C	type:token
INT64	cil/obj/x86_LINUX/cparser.ml	/^  | INT64 of (Cabs.cabsloc)$/;"	C	type:token
INT64	cil/obj/x86_LINUX/cparser.mli	/^  | INT64 of (Cabs.cabsloc)$/;"	C	type:token
INT64	cil/obj/x86_LINUX/formatparse.ml	/^  | INT64$/;"	C	type:token
INT64	cil/obj/x86_LINUX/formatparse.mli	/^  | INT64$/;"	C	type:token
If	cil/src/cil.mli	/^  | If of exp * block * block * location $/;"	C	type:stmtkind
Inconsistent	cil/src/ext/pta/golf.ml	/^exception Inconsistent (* raised if constraint system is inconsistent *)$/;"	e
Inconsistent	cil/src/ext/pta/olf.ml	/^exception Inconsistent (* raised if constraint system is inconsistent *)$/;"	e
Inconsistent	cil/src/ext/pta/steensgaard.ml	/^exception Inconsistent of string$/;"	e
IncrementalSolve	src/base/yices_solver.cc	/^bool YicesSolver::IncrementalSolve(const vector<value_t>& old_soln,$/;"	f	class:crest::YicesSolver
Instantiation_cycle	cil/src/ext/pta/steensgaard.ml	/^exception Instantiation_cycle$/;"	e
Instr	cil/src/cil.mli	/^  | Instr  of instr list               $/;"	C	type:stmtkind
Int32Op	cil/ocamlutil/util.ml	1;"	M
Int64	cil/obj/x86_LINUX/cparser.ml	/^  if (compare value (Int64.of_int 255) > 0) || (compare value Int64.zero < 0) then$/;"	v
IntHash	cil/src/ext/pta/olf.ml	1;"	M
IntSet	cil/src/ext/ssa.ml	1;"	M
InternalError	cil/obj/x86_LINUX/clexer.ml	/^exception InternalError of string$/;"	e
InternalError	cil/obj/x86_LINUX/formatlex.ml	/^exception InternalError of string$/;"	e
Inthash	cil/ocamlutil/inthash.ml	1;"	M
Inthash	cil/ocamlutil/inthash.mli	1;"	M
Intmap	cil/ocamlutil/intmap.ml	1;"	M
Intmap	cil/ocamlutil/intmap.mli	1;"	M
IsConcrete	src/base/symbolic_expression.h	/^  bool IsConcrete() const { return coeff_.empty(); }$/;"	f	class:crest::SymbolicExpr
It	src/base/symbolic_expression.cc	/^typedef map<var_t,value_t>::iterator It;$/;"	t	namespace:crest	file:
JUSTBASE	cil/src/frontc/cabs.ml	/^ | JUSTBASE                               (* Prints the declared name *)$/;"	C	type:decl_type
KeptFile	cil/lib/KeptFile.pm	/^package KeptFile;$/;"	p
L	cil/src/ext/liveness.ml	1;"	M
LA	cil/ocamlutil/growArray.ml	1;"	M
LABEL	cil/src/frontc/cabs.ml	/^ | LABEL of string * statement * cabsloc$/;"	C	type:statement
LABELADDR	cil/src/frontc/cabs.ml	/^  | LABELADDR of string  (* GCC's && Label *)$/;"	C	type:expression
LABEL__	cil/obj/x86_LINUX/cparser.ml	/^  | LABEL__$/;"	C	type:token
LABEL__	cil/obj/x86_LINUX/cparser.mli	/^  | LABEL__$/;"	C	type:token
LABEL__	cil/obj/x86_LINUX/formatparse.ml	/^  | LABEL__$/;"	C	type:token
LABEL__	cil/obj/x86_LINUX/formatparse.mli	/^  | LABEL__$/;"	C	type:token
LBRACE	cil/obj/x86_LINUX/cparser.ml	/^  | LBRACE of (Cabs.cabsloc)$/;"	C	type:token
LBRACE	cil/obj/x86_LINUX/cparser.mli	/^  | LBRACE of (Cabs.cabsloc)$/;"	C	type:token
LBRACE	cil/obj/x86_LINUX/formatparse.ml	/^  | LBRACE$/;"	C	type:token
LBRACE	cil/obj/x86_LINUX/formatparse.mli	/^  | LBRACE$/;"	C	type:token
LBRACKET	cil/obj/x86_LINUX/cparser.ml	/^  | LBRACKET$/;"	C	type:token
LBRACKET	cil/obj/x86_LINUX/cparser.mli	/^  | LBRACKET$/;"	C	type:token
LBRACKET	cil/obj/x86_LINUX/formatparse.ml	/^  | LBRACKET$/;"	C	type:token
LBRACKET	cil/obj/x86_LINUX/formatparse.mli	/^  | LBRACKET$/;"	C	type:token
LDFLAGS	src/Makefile	/^LDFLAGS = -L$(YICES_DIR)\/lib$/;"	m
LE	cil/src/frontc/cabs.ml	/^  | EQ | NE | LT | GT | LE | GE$/;"	C	type:binary_operator
LE	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	e	enum:crest::ops::compare_op_t
LIBCREST_CREST_H__	include/crest.h	13;"	d
LIBCREST_CREST_H__	src/libcrest/crest.h	13;"	d
LINKAGE	cil/src/frontc/cabs.ml	/^ | LINKAGE of string * cabsloc * definition list (* extern "C" { ... } *)$/;"	C	type:definition
LOADLIBES	src/Makefile	/^LOADLIBES = -lyices -lrt$/;"	m
LOGICAL_NOT	src/base/basic_types.h	/^enum unary_op_t { NEGATE, LOGICAL_NOT, BITWISE_NOT };$/;"	e	enum:crest::ops::unary_op_t
LONG	cil/obj/x86_LINUX/cparser.ml	/^  | LONG of (Cabs.cabsloc)$/;"	C	type:token
LONG	cil/obj/x86_LINUX/cparser.mli	/^  | LONG of (Cabs.cabsloc)$/;"	C	type:token
LONG	cil/obj/x86_LINUX/formatparse.ml	/^  | LONG$/;"	C	type:token
LONG	cil/obj/x86_LINUX/formatparse.mli	/^  | LONG$/;"	C	type:token
LONG	src/base/basic_types.h	/^	      U_LONG = 6,       LONG = 7,$/;"	e	enum:crest::types::type_t
LONGLONG	cil/src/machdep.c	51;"	d	file:
LONGLONG	cil/src/machdep.c	59;"	d	file:
LONG_LONG	src/base/basic_types.h	/^	      U_LONG_LONG = 8,  LONG_LONG = 9 };$/;"	e	enum:crest::types::type_t
LPAREN	cil/obj/x86_LINUX/cparser.ml	/^  | LPAREN of (Cabs.cabsloc)$/;"	C	type:token
LPAREN	cil/obj/x86_LINUX/cparser.mli	/^  | LPAREN of (Cabs.cabsloc)$/;"	C	type:token
LPAREN	cil/obj/x86_LINUX/formatparse.ml	/^  | LPAREN$/;"	C	type:token
LPAREN	cil/obj/x86_LINUX/formatparse.mli	/^  | LPAREN$/;"	C	type:token
LT	cil/src/frontc/cabs.ml	/^  | EQ | NE | LT | GT | LE | GE$/;"	C	type:binary_operator
LT	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	e	enum:crest::ops::compare_op_t
Label	cil/src/cil.mli	/^    Label of string * location * bool   $/;"	C	type:label
LaunchProgram	src/run_crest/concolic_search.cc	/^void Search::LaunchProgram(const vector<value_t>& inputs) {$/;"	f	class:crest::Search
LeftFlush	cil/ocamlutil/pretty.ml	/^  | LeftFlush$/;"	C	type:doc
LenOfArray	cil/src/cil.ml	/^exception LenOfArray$/;"	e
LenOfArray	cil/src/cil.mli	/^exception LenOfArray$/;"	e
Lexerhack	cil/src/frontc/lexerhack.ml	1;"	M
Libmaincil	cil/src/libmaincil.ml	1;"	M
Line	cil/ocamlutil/pretty.ml	/^  | Line $/;"	C	type:doc
Link	cil/src/ext/pta/uref.ml	/^  | Link of 'a uref$/;"	C	type:urefC
Liveness	cil/src/ext/liveness.ml	1;"	M
Load	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::Load(id_t id, addr_t addr, value_t value) {$/;"	f	class:crest::SymbolicInterpreter
Logcalls	cil/src/ext/logcalls.ml	1;"	M
Logcalls	cil/src/ext/logcalls.mli	1;"	M
Logwrites	cil/src/ext/logwrites.ml	1;"	M
Longarray	cil/ocamlutil/longarray.ml	1;"	M
Longarray	cil/ocamlutil/longarray.mli	1;"	M
Loop	cil/src/cil.mli	/^  | Loop of block * location * (stmt option) * (stmt option)$/;"	C	type:stmtkind
Lval	cil/src/cil.mli	/^  | Lval       of lval                  (** Lvalue *)$/;"	C	type:exp
MAKE.cil	cil/debian/rules	/^MAKE.cil = $(MAKE) -f Makefile.cil$/;"	m
MEMBEROF	cil/src/frontc/cabs.ml	/^  | MEMBEROF of expression * string$/;"	C	type:expression
MEMBEROFPTR	cil/src/frontc/cabs.ml	/^  | MEMBEROFPTR of expression * string$/;"	C	type:expression
MEMOF	cil/src/frontc/cabs.ml	/^    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF$/;"	C	type:unary_operator
METHODdBlock	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODdBlock"><\/a>dBlock : <code class="type">out_channel -> int -> <a href="Cil.html#TYPEblock">block<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
METHODdGlobal	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODdGlobal"><\/a>dGlobal : <code class="type">out_channel -> <a href="Cil.html#TYPEglobal">global<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
METHODdInit	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODdInit"><\/a>dInit : <code class="type">out_channel -> int -> <a href="Cil.html#TYPEinit">init<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
METHODdStmt	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODdStmt"><\/a>dStmt : <code class="type">out_channel -> int -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
METHODpAttr	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpAttr"><\/a>pAttr : <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> * bool<\/code><\/pre><div class="info">$/;"	a
METHODpAttrParam	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpAttrParam"><\/a>pAttrParam : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpAttrs	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpAttrs"><\/a>pAttrs : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpBlock	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpBlock"><\/a>pBlock : <code class="type">unit -> <a href="Cil.html#TYPEblock">block<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpExp	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpExp"><\/a>pExp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpFieldDecl	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpFieldDecl"><\/a>pFieldDecl : <code class="type">unit -> <a href="Cil.html#TYPEfieldinfo">fieldinfo<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpGlobal	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpGlobal"><\/a>pGlobal : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpInit	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpInit"><\/a>pInit : <code class="type">unit -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpInstr	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpInstr"><\/a>pInstr : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpLabel	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpLabel"><\/a>pLabel : <code class="type">unit -> <a href="Cil.html#TYPElabel">label<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpLineDirective	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpLineDirective"><\/a>pLineDirective : <code class="type">?forcefile:bool -> <a href="Cil.html#TYPElocation">location<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpLval	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpLval"><\/a>pLval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpOffset	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpOffset"><\/a>pOffset : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpStmt	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpStmt"><\/a>pStmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpStmtKind	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpStmtKind"><\/a>pStmtKind : <code class="type"><a href="Cil.html#TYPEstmt">stmt<\/a> -> unit -> <a href="Cil.html#TYPEstmtkind">stmtkind<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpType	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpType"><\/a>pType : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> option -> unit -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODpVar	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODpVar"><\/a>pVar : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODqueueInstr	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODqueueInstr"><\/a>queueInstr : <code class="type"><a href="Cil.html#TYPEinstr">instr<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
METHODsetCurrentFormals	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODsetCurrentFormals"><\/a>setCurrentFormals : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> list -> unit<\/code><\/pre><pre><span class="keyword">method<\/span> <a name="METHODsetPrintInstrTerminator"><\/a>setPrintInstrTerminator : <code class="type">string -> unit<\/code><\/pre><pre><span class="keyword">method<\/span> <a name="METHODgetPrintInstrTerminator"><\/a>getPrintInstrTerminator : <code class="type">unit -> string<\/code><\/pre><pre><span class="keyword">method<\/span> <a name="METHODpVDecl"><\/a>pVDecl : <code class="type">unit -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
METHODstartTemps	cil/doc/api/Cil.descriptiveCilPrinter.html	/^<pre><span class="keyword">method<\/span> <a name="METHODstartTemps"><\/a>startTemps : <code class="type">unit -> unit<\/code><\/pre><pre><span class="keyword">method<\/span> <a name="METHODstopTemps"><\/a>stopTemps : <code class="type">unit -> unit<\/code><\/pre><pre><span class="keyword">method<\/span> <a name="METHODpTemps"><\/a>pTemps : <code class="type">unit -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><\/body><\/html>/;"	a
METHODunqueueInstr	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODunqueueInstr"><\/a>unqueueInstr : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr<\/a> list<\/code><\/pre><div class="info">$/;"	a
METHODvattr	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvattr"><\/a>vattr : <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> -> <a href="Cil.html#TYPEattribute">attribute<\/a> list <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvattrparam	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvattrparam"><\/a>vattrparam : <code class="type"><a href="Cil.html#TYPEattrparam">attrparam<\/a> -> <a href="Cil.html#TYPEattrparam">attrparam<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvblock	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvblock"><\/a>vblock : <code class="type"><a href="Cil.html#TYPEblock">block<\/a> -> <a href="Cil.html#TYPEblock">block<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvexpr	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvexpr"><\/a>vexpr : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvfunc	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvfunc"><\/a>vfunc : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> <a href="Cil.html#TYPEfundec">fundec<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvglob	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvglob"><\/a>vglob : <code class="type"><a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Cil.html#TYPEglobal">global<\/a> list <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvinit	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvinit"><\/a>vinit : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Cil.html#TYPEinit">init<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvinitoffs	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvinitoffs"><\/a>vinitoffs : <code class="type"><a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvinst	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvinst"><\/a>vinst : <code class="type"><a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Cil.html#TYPEinstr">instr<\/a> list <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvlval	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvlval"><\/a>vlval : <code class="type"><a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPElval">lval<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvoffs	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvoffs"><\/a>voffs : <code class="type"><a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvstmt	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvstmt"><\/a>vstmt : <code class="type"><a href="Cil.html#TYPEstmt">stmt<\/a> -> <a href="Cil.html#TYPEstmt">stmt<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvtype	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvtype"><\/a>vtype : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvvdec	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvvdec"><\/a>vvdec : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
METHODvvrbl	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">method<\/span> <a name="METHODvvrbl"><\/a>vvrbl : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a> <a href="Cil.html#TYPEvisitAction">visitAction<\/a><\/code><\/pre><div class="info">$/;"	a
MINUS	cil/obj/x86_LINUX/cparser.ml	/^  | MINUS of (Cabs.cabsloc)$/;"	C	type:token
MINUS	cil/obj/x86_LINUX/cparser.mli	/^  | MINUS of (Cabs.cabsloc)$/;"	C	type:token
MINUS	cil/obj/x86_LINUX/formatparse.ml	/^  | MINUS$/;"	C	type:token
MINUS	cil/obj/x86_LINUX/formatparse.mli	/^  | MINUS$/;"	C	type:token
MINUS	cil/src/frontc/cabs.ml	/^    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF$/;"	C	type:unary_operator
MINUS_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | MINUS_EQ$/;"	C	type:token
MINUS_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | MINUS_EQ$/;"	C	type:token
MINUS_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | MINUS_EQ$/;"	C	type:token
MINUS_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | MINUS_EQ$/;"	C	type:token
MINUS_MINUS	cil/obj/x86_LINUX/cparser.ml	/^  | MINUS_MINUS of (Cabs.cabsloc)$/;"	C	type:token
MINUS_MINUS	cil/obj/x86_LINUX/cparser.mli	/^  | MINUS_MINUS of (Cabs.cabsloc)$/;"	C	type:token
MINUS_MINUS	cil/obj/x86_LINUX/formatparse.ml	/^  | MINUS_MINUS$/;"	C	type:token
MINUS_MINUS	cil/obj/x86_LINUX/formatparse.mli	/^  | MINUS_MINUS$/;"	C	type:token
MOD	cil/src/frontc/cabs.ml	/^    ADD | SUB | MUL | DIV | MOD$/;"	C	type:binary_operator
MOD_ASSIGN	cil/src/frontc/cabs.ml	/^  | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN$/;"	C	type:binary_operator
MSASM	cil/obj/x86_LINUX/cparser.ml	/^  | MSASM of (string * Cabs.cabsloc)$/;"	C	type:token
MSASM	cil/obj/x86_LINUX/cparser.mli	/^  | MSASM of (string * Cabs.cabsloc)$/;"	C	type:token
MSASM	cil/obj/x86_LINUX/formatparse.ml	/^  | MSASM of (string)$/;"	C	type:token
MSASM	cil/obj/x86_LINUX/formatparse.mli	/^  | MSASM of (string)$/;"	C	type:token
MSATTR	cil/obj/x86_LINUX/cparser.ml	/^  | MSATTR of (string * Cabs.cabsloc)$/;"	C	type:token
MSATTR	cil/obj/x86_LINUX/cparser.mli	/^  | MSATTR of (string * Cabs.cabsloc)$/;"	C	type:token
MSATTR	cil/obj/x86_LINUX/formatparse.ml	/^  | MSATTR of (string)$/;"	C	type:token
MSATTR	cil/obj/x86_LINUX/formatparse.mli	/^  | MSATTR of (string)$/;"	C	type:token
MSLIB	cil/lib/Cilly.pm	/^package MSLIB;$/;"	p
MSLINK	cil/lib/Cilly.pm	/^package MSLINK;$/;"	p
MSVC	cil/lib/Cilly.pm	/^package MSVC;$/;"	p
MUL	cil/src/frontc/cabs.ml	/^    ADD | SUB | MUL | DIV | MOD$/;"	C	type:binary_operator
MULTIPLY	src/base/basic_types.h	/^enum binary_op_t { ADD, SUBTRACT, MULTIPLY, CONCRETE };$/;"	e	enum:crest::ops::binary_op_t
MUL_ASSIGN	cil/src/frontc/cabs.ml	/^  | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN$/;"	C	type:binary_operator
Machdep	cil/obj/x86_LINUX/machdep.ml	1;"	M
Main	cil/src/main.ml	1;"	M
Make	cil/src/ext/pta/setp.ml	1;"	M
Make	cil/src/ext/pta/setp.mli	1;"	M
MakeMapPrinter	cil/ocamlutil/pretty.ml	1;"	M
MakeMapPrinter	cil/ocamlutil/pretty.mli	1;"	M	function:++
MakePartial	cil/src/ext/partial.ml	1;"	M
MakeSetPrinter	cil/ocamlutil/pretty.ml	1;"	M
MakeSetPrinter	cil/ocamlutil/pretty.mli	1;"	M
Mark	cil/ocamlutil/pretty.ml	/^  | Mark$/;"	C	type:doc
Mem	cil/src/cil.mli	/^  | Mem        of exp        $/;"	C	type:lhost
MergeCommand	cil/bin/cilly	/^sub MergeCommand {$/;"	s
Mergecil	cil/src/mergecil.ml	1;"	M
Mergecil	cil/src/mergecil.mli	1;"	M
MinCflDistance	src/run_crest/concolic_search.cc	/^size_t CfgHeuristicSearch::MinCflDistance$/;"	f	class:crest::CfgHeuristicSearch
More	cil/ocamlutil/intmap.ml	/^type 'a enumeration = End | More of int * 'a * 'a t * 'a enumeration$/;"	C	type:enumeration
NAMED_TYPE	cil/obj/x86_LINUX/cparser.ml	/^  | NAMED_TYPE of (string * Cabs.cabsloc)$/;"	C	type:token
NAMED_TYPE	cil/obj/x86_LINUX/cparser.mli	/^  | NAMED_TYPE of (string * Cabs.cabsloc)$/;"	C	type:token
NAMED_TYPE	cil/obj/x86_LINUX/formatparse.ml	/^  | NAMED_TYPE of (string)$/;"	C	type:token
NAMED_TYPE	cil/obj/x86_LINUX/formatparse.mli	/^  | NAMED_TYPE of (string)$/;"	C	type:token
NATIVECAML	cil/Makefile	/^  NATIVECAML := 1$/;"	m
NE	cil/src/frontc/cabs.ml	/^  | EQ | NE | LT | GT | LE | GE$/;"	C	type:binary_operator
NEGATE	src/base/basic_types.h	/^enum unary_op_t { NEGATE, LOGICAL_NOT, BITWISE_NOT };$/;"	e	enum:crest::ops::unary_op_t
NEQ	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	e	enum:crest::ops::compare_op_t
NESTED	cil/test/small1/init.c	/^} NESTED;$/;"	t	typeref:struct:__anon1	file:
NEXT_INIT	cil/src/frontc/cabs.ml	/^    NEXT_INIT$/;"	C	type:initwhat
NIIndirect	cil/src/ext/callgraph.mli	/^  | NIIndirect of string (* Indirect nodes have a string associated to them. $/;"	C	type:nodeinfo
NIVar	cil/src/ext/callgraph.mli	/^    NIVar of Cil.varinfo * bool ref $/;"	C	type:nodeinfo
NOP	cil/src/frontc/cabs.ml	/^   NOP of cabsloc$/;"	C	type:statement
NOT	cil/src/frontc/cabs.ml	/^    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF$/;"	C	type:unary_operator
NOTHING	cil/src/frontc/cabs.ml	/^    NOTHING$/;"	C	type:expression
NO_INIT	cil/src/frontc/cabs.ml	/^  | NO_INIT$/;"	C	type:init_expression
NO_STORAGE	cil/src/frontc/cabs.ml	/^    NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER$/;"	C	type:storage
NVar	cil/src/frontc/cabsvisit.mli	/^    NVar                                (** Variable or function prototype $/;"	C	type:nameKind
NeculaFolding	cil/src/ext/partial.ml	1;"	M
Neg	cil/src/cil.mli	/^    Neg                                 (** Unary minus *)$/;"	C	type:unop
Negate	src/base/symbolic_expression.cc	/^void SymbolicExpr::Negate() {$/;"	f	class:crest::SymbolicExpr
Negate	src/base/symbolic_predicate.cc	/^void SymbolicPred::Negate() {$/;"	f	class:crest::SymbolicPred
NegateCompareOp	src/base/basic_types.cc	/^compare_op_t NegateCompareOp(compare_op_t op) {$/;"	f	namespace:crest
NewInput	src/base/symbolic_interpreter.cc	/^    value_t SymbolicInterpreter::NewInput(type_t type, addr_t addr) {$/;"	f	class:crest::SymbolicInterpreter
NewInputValue	src/base/symbolic_interpreter.cc	/^    value_t SymbolicInterpreter::NewInputValue(type_t type, addr_t addr, value_t v) {$/;"	f	class:crest::SymbolicInterpreter
NextPatch	cil/bin/patcher	/^      NextPatch:$/;"	l
NextPattern	cil/bin/patcher	/^  NextPattern:$/;"	l
Nil	cil/ocamlutil/pretty.ml	/^    Nil$/;"	C	type:doc
NoCheckGlobalIds	cil/src/check.mli	/^    NoCheckGlobalIds   (* Do not check that the global ids have the proper $/;"	C	type:checkFlags
NoContents	cil/src/ext/pta/golf.ml	/^exception NoContents$/;"	e
NoContents	cil/src/ext/pta/olf.ml	/^exception NoContents$/;"	e
NoMatch	cil/src/frontc/patch.ml	/^exception NoMatch$/;"	e
NoOffset	cil/src/cil.mli	/^  | NoOffset          (** No offset. Can be applied to any lvalue and does $/;"	C	type:offset
NoPerfCount	cil/ocamlutil/stats.mli	/^exception NoPerfCount$/;"	e
NoStorage	cil/src/cil.mli	/^    NoStorage     (** The default storage. Nothing is printed  *)$/;"	C	type:storage
No_contents	cil/src/ext/pta/steensgaard.ml	/^exception No_contents$/;"	e
Node	cil/ocamlutil/intmap.ml	/^  | Node of 'a t * int * 'a * 'a t * int$/;"	C	type:t
NotAScript	cil/lib/Cilly.pm	/^      NotAScript:$/;"	l
NotAnAttrParam	cil/src/cil.ml	/^exception NotAnAttrParam of exp$/;"	e
NotAnAttrParam	cil/src/cil.mli	/^exception NotAnAttrParam of exp$/;"	e
Not_an_integer	cil/src/ext/ciltools.ml	/^exception Not_an_integer$/;"	e
NullSolver	cil/src/ext/predabst.ml	1;"	M
NullTranslator	cil/src/ext/predabst.ml	1;"	M
OBJDIR	cil/Makefile	/^OBJDIR      := obj\/$(ARCHOS)$/;"	m
OCAML_CIL_C_LIB_MODULES	cil/Makefile	/^OCAML_CIL_C_LIB_MODULES := $(CILLY_MODULES:main=) libmaincil$/;"	m
OCAML_CIL_LIB_CMODULES	cil/Makefile	/^OCAML_CIL_LIB_CMODULES := perfcount$/;"	m
OCAML_CIL_LIB_MODULES	cil/Makefile	/^OCAML_CIL_LIB_MODULES := $(CILLY_LIBRARY_MODULES) $/;"	m
ODOC_FILES	cil/Makefile	/^ODOC_FILES =        ocamlutil\/pretty.mli ocamlutil\/errormsg.mli \\$/;"	m
ONLYTYPEDEF	cil/src/frontc/cabs.ml	/^ | ONLYTYPEDEF of specifier * cabsloc$/;"	C	type:definition
OR	cil/src/frontc/cabs.ml	/^  | AND | OR$/;"	C	type:binary_operator
Olf	cil/src/ext/pta/olf.ml	1;"	M
Olf	cil/src/ext/pta/olf.mli	1;"	M
Oneret	cil/src/ext/oneret.ml	1;"	M
Oneret	cil/src/ext/oneret.mli	1;"	M
Options	cil/lib/Cilly.pm	/^Options:$/;"	l
OutputFile	cil/lib/OutputFile.pm	/^package OutputFile;$/;"	p
P	cil/src/ext/callgraph.ml	1;"	M
P	cil/src/mergecil.ml	1;"	M
PA	cil/src/ext/predabst.ml	1;"	M
PACKAGE	cil/libstr/confdefs.h	2;"	d
PAREN	cil/src/frontc/cabs.ml	/^  | PAREN of expression$/;"	C	type:expression
PERCENT	cil/obj/x86_LINUX/cparser.ml	/^  | PERCENT$/;"	C	type:token
PERCENT	cil/obj/x86_LINUX/cparser.mli	/^  | PERCENT$/;"	C	type:token
PERCENT	cil/obj/x86_LINUX/formatparse.ml	/^  | PERCENT$/;"	C	type:token
PERCENT	cil/obj/x86_LINUX/formatparse.mli	/^  | PERCENT$/;"	C	type:token
PERCENT_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | PERCENT_EQ$/;"	C	type:token
PERCENT_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | PERCENT_EQ$/;"	C	type:token
PERCENT_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | PERCENT_EQ$/;"	C	type:token
PERCENT_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | PERCENT_EQ$/;"	C	type:token
PH	cil/src/ext/pta/golf.ml	1;"	M
PIPE	cil/obj/x86_LINUX/cparser.ml	/^  | PIPE$/;"	C	type:token
PIPE	cil/obj/x86_LINUX/cparser.mli	/^  | PIPE$/;"	C	type:token
PIPE	cil/obj/x86_LINUX/formatparse.ml	/^  | PIPE$/;"	C	type:token
PIPE	cil/obj/x86_LINUX/formatparse.mli	/^  | PIPE$/;"	C	type:token
PIPE_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | PIPE_EQ$/;"	C	type:token
PIPE_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | PIPE_EQ$/;"	C	type:token
PIPE_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | PIPE_EQ$/;"	C	type:token
PIPE_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | PIPE_EQ$/;"	C	type:token
PIPE_PIPE	cil/obj/x86_LINUX/cparser.ml	/^  | PIPE_PIPE$/;"	C	type:token
PIPE_PIPE	cil/obj/x86_LINUX/cparser.mli	/^  | PIPE_PIPE$/;"	C	type:token
PIPE_PIPE	cil/obj/x86_LINUX/formatparse.ml	/^  | PIPE_PIPE$/;"	C	type:token
PIPE_PIPE	cil/obj/x86_LINUX/formatparse.mli	/^  | PIPE_PIPE$/;"	C	type:token
PLUS	cil/obj/x86_LINUX/cparser.ml	/^  | PLUS of (Cabs.cabsloc)$/;"	C	type:token
PLUS	cil/obj/x86_LINUX/cparser.mli	/^  | PLUS of (Cabs.cabsloc)$/;"	C	type:token
PLUS	cil/obj/x86_LINUX/formatparse.ml	/^  | PLUS$/;"	C	type:token
PLUS	cil/obj/x86_LINUX/formatparse.mli	/^  | PLUS$/;"	C	type:token
PLUS	cil/src/frontc/cabs.ml	/^    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF$/;"	C	type:unary_operator
PLUS_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | PLUS_EQ$/;"	C	type:token
PLUS_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | PLUS_EQ$/;"	C	type:token
PLUS_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | PLUS_EQ$/;"	C	type:token
PLUS_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | PLUS_EQ$/;"	C	type:token
PLUS_PLUS	cil/obj/x86_LINUX/cparser.ml	/^  | PLUS_PLUS of (Cabs.cabsloc)$/;"	C	type:token
PLUS_PLUS	cil/obj/x86_LINUX/cparser.mli	/^  | PLUS_PLUS of (Cabs.cabsloc)$/;"	C	type:token
PLUS_PLUS	cil/obj/x86_LINUX/formatparse.ml	/^  | PLUS_PLUS$/;"	C	type:token
PLUS_PLUS	cil/obj/x86_LINUX/formatparse.mli	/^  | PLUS_PLUS$/;"	C	type:token
POSDECR	cil/src/frontc/cabs.ml	/^  | PREINCR | PREDECR | POSINCR | POSDECR$/;"	C	type:unary_operator
POSINCR	cil/src/frontc/cabs.ml	/^  | PREINCR | PREDECR | POSINCR | POSDECR$/;"	C	type:unary_operator
PRAGMA	cil/obj/x86_LINUX/cparser.ml	/^  | PRAGMA of (Cabs.cabsloc)$/;"	C	type:token
PRAGMA	cil/obj/x86_LINUX/cparser.mli	/^  | PRAGMA of (Cabs.cabsloc)$/;"	C	type:token
PRAGMA	cil/obj/x86_LINUX/formatparse.ml	/^  | PRAGMA$/;"	C	type:token
PRAGMA	cil/obj/x86_LINUX/formatparse.mli	/^  | PRAGMA$/;"	C	type:token
PRAGMA	cil/src/frontc/cabs.ml	/^ | PRAGMA of expression * cabsloc$/;"	C	type:definition
PRAGMA_EOL	cil/obj/x86_LINUX/cparser.ml	/^  | PRAGMA_EOL$/;"	C	type:token
PRAGMA_EOL	cil/obj/x86_LINUX/cparser.mli	/^  | PRAGMA_EOL$/;"	C	type:token
PRAGMA_LINE	cil/obj/x86_LINUX/cparser.ml	/^  | PRAGMA_LINE of (string * Cabs.cabsloc)$/;"	C	type:token
PRAGMA_LINE	cil/obj/x86_LINUX/cparser.mli	/^  | PRAGMA_LINE of (string * Cabs.cabsloc)$/;"	C	type:token
PREDECR	cil/src/frontc/cabs.ml	/^  | PREINCR | PREDECR | POSINCR | POSDECR$/;"	C	type:unary_operator
PREINCR	cil/src/frontc/cabs.ml	/^  | PREINCR | PREDECR | POSINCR | POSDECR$/;"	C	type:unary_operator
PRETTY_FUNCTION__	cil/obj/x86_LINUX/cparser.ml	/^  | PRETTY_FUNCTION__ of (Cabs.cabsloc)$/;"	C	type:token
PRETTY_FUNCTION__	cil/obj/x86_LINUX/cparser.mli	/^  | PRETTY_FUNCTION__ of (Cabs.cabsloc)$/;"	C	type:token
PRETTY_FUNCTION__	cil/obj/x86_LINUX/formatparse.ml	/^  | PRETTY_FUNCTION__$/;"	C	type:token
PRETTY_FUNCTION__	cil/obj/x86_LINUX/formatparse.mli	/^  | PRETTY_FUNCTION__$/;"	C	type:token
Parse	src/base/symbolic_execution.cc	/^bool SymbolicExecution::Parse(istream& s) {$/;"	f	class:crest::SymbolicExecution
Parse	src/base/symbolic_expression.cc	/^bool SymbolicExpr::Parse(istream& s) {$/;"	f	class:crest::SymbolicExpr
Parse	src/base/symbolic_path.cc	/^bool SymbolicPath::Parse(istream& s) {$/;"	f	class:crest::SymbolicPath
Parse	src/base/symbolic_predicate.cc	/^bool SymbolicPred::Parse(istream& s) {$/;"	f	class:crest::SymbolicPred
ParseError	cil/src/frontc/frontc.mli	/^exception ParseError of string$/;"	e
Partial	cil/src/ext/partial.ml	1;"	M
PartialAlgorithm	cil/src/ext/partial.ml	1;"	M
Patch	cil/src/frontc/patch.ml	1;"	M
Patch	cil/src/frontc/patch.mli	1;"	M
Path	cil/src/ext/pta/golf.ml	1;"	M
PlusA	cil/src/cil.mli	/^    PlusA                               (** arithmetic + *)$/;"	C	type:binop
PolyOrderedType	cil/src/ext/pta/setp.ml	1;"	M
PolyOrderedType	cil/src/ext/pta/setp.mli	1;"	M
PostOrder	cil/src/ext/dominators.ml	/^type order = PreOrder | PostOrder$/;"	C	type:order
PostOrder	cil/src/ext/dominators.mli	/^type order = PreOrder | PostOrder$/;"	C	type:order
PreOrder	cil/src/ext/dominators.ml	/^type order = PreOrder | PostOrder$/;"	C	type:order
PreOrder	cil/src/ext/dominators.mli	/^type order = PreOrder | PostOrder$/;"	C	type:order
PredFlow	cil/src/ext/predabst.ml	1;"	M
PredIt	src/base/yices_solver.cc	/^typedef vector<const SymbolicPred*>::const_iterator PredIt;$/;"	t	namespace:crest	file:
Predabst	cil/src/ext/predabst.ml	1;"	M
Pretty	cil/ocamlutil/pretty.ml	1;"	M
Pretty	cil/ocamlutil/pretty.mli	1;"	M
PrintStats	src/run_crest/concolic_search.cc	/^void CfgHeuristicSearch::PrintStats() {$/;"	f	class:crest::CfgHeuristicSearch
Ptranal	cil/src/ext/pta/ptranal.ml	1;"	M
Ptranal	cil/src/ext/pta/ptranal.mli	1;"	M
PtranalAlias	cil/src/ext/partial.ml	1;"	M
Push	src/base/symbolic_path.cc	/^void SymbolicPath::Push(branch_id_t bid) {$/;"	f	class:crest::SymbolicPath
Push	src/base/symbolic_path.cc	/^void SymbolicPath::Push(branch_id_t bid, SymbolicPred* constraint) {$/;"	f	class:crest::SymbolicPath
PushConcrete	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::PushConcrete(value_t value) {$/;"	f	class:crest::SymbolicInterpreter
PushSymbolic	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::PushSymbolic(SymbolicExpr* expr, value_t value) {$/;"	f	class:crest::SymbolicInterpreter
QUEST	cil/obj/x86_LINUX/cparser.ml	/^  | QUEST$/;"	C	type:token
QUEST	cil/obj/x86_LINUX/cparser.mli	/^  | QUEST$/;"	C	type:token
QUEST	cil/obj/x86_LINUX/formatparse.ml	/^  | QUEST$/;"	C	type:token
QUEST	cil/obj/x86_LINUX/formatparse.mli	/^  | QUEST$/;"	C	type:token
QUESTION	cil/src/frontc/cabs.ml	/^  | QUESTION of expression * expression * expression$/;"	C	type:expression
RBRACE	cil/obj/x86_LINUX/cparser.ml	/^  | RBRACE of (Cabs.cabsloc)$/;"	C	type:token
RBRACE	cil/obj/x86_LINUX/cparser.mli	/^  | RBRACE of (Cabs.cabsloc)$/;"	C	type:token
RBRACE	cil/obj/x86_LINUX/formatparse.ml	/^  | RBRACE$/;"	C	type:token
RBRACE	cil/obj/x86_LINUX/formatparse.mli	/^  | RBRACE$/;"	C	type:token
RBRACKET	cil/obj/x86_LINUX/cparser.ml	/^  | RBRACKET$/;"	C	type:token
RBRACKET	cil/obj/x86_LINUX/cparser.mli	/^  | RBRACKET$/;"	C	type:token
RBRACKET	cil/obj/x86_LINUX/formatparse.ml	/^  | RBRACKET$/;"	C	type:token
RBRACKET	cil/obj/x86_LINUX/formatparse.mli	/^  | RBRACKET$/;"	C	type:token
RD	cil/src/ext/reachingdefs.ml	1;"	M
RDCall	cil/src/ext/reachingdefs.ml	/^type rhs = RDExp of exp | RDCall of instr$/;"	C	type:rhs
RDExp	cil/src/ext/reachingdefs.ml	/^type rhs = RDExp of exp | RDCall of instr$/;"	C	type:rhs
REGISTER	cil/obj/x86_LINUX/cparser.ml	/^  | REGISTER of (Cabs.cabsloc)$/;"	C	type:token
REGISTER	cil/obj/x86_LINUX/cparser.mli	/^  | REGISTER of (Cabs.cabsloc)$/;"	C	type:token
REGISTER	cil/obj/x86_LINUX/formatparse.ml	/^  | REGISTER$/;"	C	type:token
REGISTER	cil/obj/x86_LINUX/formatparse.mli	/^  | REGISTER$/;"	C	type:token
REGISTER	cil/src/frontc/cabs.ml	/^    NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER$/;"	C	type:storage
RESTRICT	cil/obj/x86_LINUX/cparser.ml	/^  | RESTRICT of (Cabs.cabsloc)$/;"	C	type:token
RESTRICT	cil/obj/x86_LINUX/cparser.mli	/^  | RESTRICT of (Cabs.cabsloc)$/;"	C	type:token
RESTRICT	cil/obj/x86_LINUX/formatparse.ml	/^  | RESTRICT$/;"	C	type:token
RESTRICT	cil/obj/x86_LINUX/formatparse.mli	/^  | RESTRICT$/;"	C	type:token
RETURN	cil/obj/x86_LINUX/cparser.ml	/^  | RETURN of (Cabs.cabsloc)$/;"	C	type:token
RETURN	cil/obj/x86_LINUX/cparser.mli	/^  | RETURN of (Cabs.cabsloc)$/;"	C	type:token
RETURN	cil/obj/x86_LINUX/formatparse.ml	/^  | RETURN$/;"	C	type:token
RETURN	cil/obj/x86_LINUX/formatparse.mli	/^  | RETURN$/;"	C	type:token
RETURN	cil/src/frontc/cabs.ml	/^ | RETURN of expression * cabsloc$/;"	C	type:statement
RPAREN	cil/obj/x86_LINUX/cparser.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	cil/obj/x86_LINUX/cparser.mli	/^  | RPAREN$/;"	C	type:token
RPAREN	cil/obj/x86_LINUX/formatparse.ml	/^  | RPAREN$/;"	C	type:token
RPAREN	cil/obj/x86_LINUX/formatparse.mli	/^  | RPAREN$/;"	C	type:token
RUN_CREST_CONCOLIC_SEARCH_H__	src/run_crest/concolic_search.h	12;"	d
RandomInput	src/run_crest/concolic_search.cc	/^void Search::RandomInput(const map<var_t,type_t>& vars, vector<value_t>* input) {$/;"	f	class:crest::Search
RandomInputSearch	src/run_crest/concolic_search.cc	/^RandomInputSearch::RandomInputSearch(const string& program, int max_iterations)$/;"	f	class:crest::RandomInputSearch
RandomInputSearch	src/run_crest/concolic_search.h	/^class RandomInputSearch : public Search {$/;"	c	namespace:crest
RandomLocalSearch	src/run_crest/concolic_search.cc	/^void HybridSearch::RandomLocalSearch(SymbolicExecution *ex, size_t start, size_t end) {$/;"	f	class:crest::HybridSearch
RandomSearch	src/run_crest/concolic_search.cc	/^RandomSearch::RandomSearch(const string& program, int max_iterations)$/;"	f	class:crest::RandomSearch
RandomSearch	src/run_crest/concolic_search.h	/^class RandomSearch : public Search {$/;"	c	namespace:crest
RandomStep	src/run_crest/concolic_search.cc	/^bool HybridSearch::RandomStep(SymbolicExecution *ex, size_t start, size_t end) {$/;"	f	class:crest::HybridSearch
ReachedTop	cil/src/ext/pta/olf.ml	/^exception ReachedTop   (* raised if top (from an undefined function)$/;"	e
ReachingDef	cil/src/ext/reachingdefs.ml	1;"	M
Reachingdefs	cil/src/ext/reachingdefs.ml	1;"	M
Return	cil/src/cil.mli	/^  | Return of exp option * location     $/;"	C	type:stmtkind
Return	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::Return(id_t id) {$/;"	f	class:crest::SymbolicInterpreter
Rmtmps	cil/src/rmtmps.ml	1;"	M
Rmtmps	cil/src/rmtmps.mli	1;"	M
Run	src/run_crest/concolic_search.cc	/^void BoundedDepthFirstSearch::Run() {$/;"	f	class:crest::BoundedDepthFirstSearch
Run	src/run_crest/concolic_search.cc	/^void CfgBaselineSearch::Run() {$/;"	f	class:crest::CfgBaselineSearch
Run	src/run_crest/concolic_search.cc	/^void CfgHeuristicSearch::Run() {$/;"	f	class:crest::CfgHeuristicSearch
Run	src/run_crest/concolic_search.cc	/^void HybridSearch::Run() {$/;"	f	class:crest::HybridSearch
Run	src/run_crest/concolic_search.cc	/^void RandomInputSearch::Run() {$/;"	f	class:crest::RandomInputSearch
Run	src/run_crest/concolic_search.cc	/^void RandomSearch::Run() {$/;"	f	class:crest::RandomSearch
Run	src/run_crest/concolic_search.cc	/^void UniformRandomSearch::Run() {$/;"	f	class:crest::UniformRandomSearch
RunProgram	src/run_crest/concolic_search.cc	/^void Search::RunProgram(const vector<value_t>& inputs, SymbolicExecution* ex) {$/;"	f	class:crest::Search
S	cil/src/ext/pta/setp.ml	1;"	M
S	cil/src/ext/pta/setp.mli	1;"	M
SDefault	cil/src/ext/dataflow.mli	/^    SDefault   (** The default action *)$/;"	C	type:stmtaction
SEMICOLON	cil/obj/x86_LINUX/cparser.ml	/^  | SEMICOLON of (Cabs.cabsloc)$/;"	C	type:token
SEMICOLON	cil/obj/x86_LINUX/cparser.mli	/^  | SEMICOLON of (Cabs.cabsloc)$/;"	C	type:token
SEMICOLON	cil/obj/x86_LINUX/formatparse.ml	/^  | SEMICOLON$/;"	C	type:token
SEMICOLON	cil/obj/x86_LINUX/formatparse.mli	/^  | SEMICOLON$/;"	C	type:token
SEQUENCE	cil/src/frontc/cabs.ml	/^ | SEQUENCE of statement * statement * cabsloc$/;"	C	type:statement
SHL	cil/src/frontc/cabs.ml	/^  | BAND | BOR | XOR | SHL | SHR$/;"	C	type:binary_operator
SHL_ASSIGN	cil/src/frontc/cabs.ml	/^  | BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN$/;"	C	type:binary_operator
SHORT	cil/obj/x86_LINUX/cparser.ml	/^  | SHORT of (Cabs.cabsloc)$/;"	C	type:token
SHORT	cil/obj/x86_LINUX/cparser.mli	/^  | SHORT of (Cabs.cabsloc)$/;"	C	type:token
SHORT	cil/obj/x86_LINUX/formatparse.ml	/^  | SHORT$/;"	C	type:token
SHORT	cil/obj/x86_LINUX/formatparse.mli	/^  | SHORT$/;"	C	type:token
SHORT	src/base/basic_types.h	/^	      U_SHORT = 2,      SHORT = 3,$/;"	e	enum:crest::types::type_t
SHR	cil/src/frontc/cabs.ml	/^  | BAND | BOR | XOR | SHL | SHR$/;"	C	type:binary_operator
SHR_ASSIGN	cil/src/frontc/cabs.ml	/^  | BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN$/;"	C	type:binary_operator
SI	src/libcrest/crest.cc	/^static SymbolicInterpreter* SI;$/;"	v	file:
SIGNED	cil/obj/x86_LINUX/cparser.ml	/^  | SIGNED of (Cabs.cabsloc)$/;"	C	type:token
SIGNED	cil/obj/x86_LINUX/cparser.mli	/^  | SIGNED of (Cabs.cabsloc)$/;"	C	type:token
SIGNED	cil/obj/x86_LINUX/formatparse.ml	/^  | SIGNED$/;"	C	type:token
SIGNED	cil/obj/x86_LINUX/formatparse.mli	/^  | SIGNED$/;"	C	type:token
SINGLE_INIT	cil/src/frontc/cabs.ml	/^  | SINGLE_INIT of expression$/;"	C	type:init_expression
SIZEOF	cil/obj/x86_LINUX/cparser.ml	/^  | SIZEOF of (Cabs.cabsloc)$/;"	C	type:token
SIZEOF	cil/obj/x86_LINUX/cparser.mli	/^  | SIZEOF of (Cabs.cabsloc)$/;"	C	type:token
SIZEOF	cil/obj/x86_LINUX/formatparse.ml	/^  | SIZEOF$/;"	C	type:token
SIZEOF	cil/obj/x86_LINUX/formatparse.mli	/^  | SIZEOF$/;"	C	type:token
SLASH	cil/obj/x86_LINUX/cparser.ml	/^  | SLASH$/;"	C	type:token
SLASH	cil/obj/x86_LINUX/cparser.mli	/^  | SLASH$/;"	C	type:token
SLASH	cil/obj/x86_LINUX/formatparse.ml	/^  | SLASH$/;"	C	type:token
SLASH	cil/obj/x86_LINUX/formatparse.mli	/^  | SLASH$/;"	C	type:token
SLASH_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | SLASH_EQ$/;"	C	type:token
SLASH_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | SLASH_EQ$/;"	C	type:token
SLASH_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | SLASH_EQ$/;"	C	type:token
SLASH_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | SLASH_EQ$/;"	C	type:token
SOLVER	cil/src/ext/predabst.ml	1;"	M
STACK	cil/ocamlutil/util.mli	1;"	M
STAR	cil/obj/x86_LINUX/cparser.ml	/^  | STAR of (Cabs.cabsloc)$/;"	C	type:token
STAR	cil/obj/x86_LINUX/cparser.mli	/^  | STAR of (Cabs.cabsloc)$/;"	C	type:token
STAR	cil/obj/x86_LINUX/formatparse.ml	/^  | STAR$/;"	C	type:token
STAR	cil/obj/x86_LINUX/formatparse.mli	/^  | STAR$/;"	C	type:token
STAR_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | STAR_EQ$/;"	C	type:token
STAR_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | STAR_EQ$/;"	C	type:token
STAR_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | STAR_EQ$/;"	C	type:token
STAR_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | STAR_EQ$/;"	C	type:token
STATIC	cil/obj/x86_LINUX/cparser.ml	/^  | STATIC of (Cabs.cabsloc)$/;"	C	type:token
STATIC	cil/obj/x86_LINUX/cparser.mli	/^  | STATIC of (Cabs.cabsloc)$/;"	C	type:token
STATIC	cil/obj/x86_LINUX/formatparse.ml	/^  | STATIC$/;"	C	type:token
STATIC	cil/obj/x86_LINUX/formatparse.mli	/^  | STATIC$/;"	C	type:token
STATIC	cil/src/frontc/cabs.ml	/^    NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER$/;"	C	type:storage
STR	cil/test/small1/init.c	/^} STR;$/;"	t	typeref:struct:s	file:
STRUCT	cil/obj/x86_LINUX/cparser.ml	/^  | STRUCT of (Cabs.cabsloc)$/;"	C	type:token
STRUCT	cil/obj/x86_LINUX/cparser.mli	/^  | STRUCT of (Cabs.cabsloc)$/;"	C	type:token
STRUCT	cil/obj/x86_LINUX/formatparse.ml	/^  | STRUCT$/;"	C	type:token
STRUCT	cil/obj/x86_LINUX/formatparse.mli	/^  | STRUCT$/;"	C	type:token
SUB	cil/src/frontc/cabs.ml	/^    ADD | SUB | MUL | DIV | MOD$/;"	C	type:binary_operator
SUBTRACT	src/base/basic_types.h	/^enum binary_op_t { ADD, SUBTRACT, MULTIPLY, CONCRETE };$/;"	e	enum:crest::ops::binary_op_t
SUB_ASSIGN	cil/src/frontc/cabs.ml	/^  | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN$/;"	C	type:binary_operator
SUCCESS	cil/test/small1/testharness.h	16;"	d
SUP	cil/obj/x86_LINUX/cparser.ml	/^  | SUP$/;"	C	type:token
SUP	cil/obj/x86_LINUX/cparser.mli	/^  | SUP$/;"	C	type:token
SUP	cil/obj/x86_LINUX/formatparse.ml	/^  | SUP$/;"	C	type:token
SUP	cil/obj/x86_LINUX/formatparse.mli	/^  | SUP$/;"	C	type:token
SUP_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | SUP_EQ$/;"	C	type:token
SUP_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | SUP_EQ$/;"	C	type:token
SUP_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | SUP_EQ$/;"	C	type:token
SUP_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | SUP_EQ$/;"	C	type:token
SUP_SUP	cil/obj/x86_LINUX/cparser.ml	/^  | SUP_SUP$/;"	C	type:token
SUP_SUP	cil/obj/x86_LINUX/cparser.mli	/^  | SUP_SUP$/;"	C	type:token
SUP_SUP	cil/obj/x86_LINUX/formatparse.ml	/^  | SUP_SUP$/;"	C	type:token
SUP_SUP	cil/obj/x86_LINUX/formatparse.mli	/^  | SUP_SUP$/;"	C	type:token
SUP_SUP_EQ	cil/obj/x86_LINUX/cparser.ml	/^  | SUP_SUP_EQ$/;"	C	type:token
SUP_SUP_EQ	cil/obj/x86_LINUX/cparser.mli	/^  | SUP_SUP_EQ$/;"	C	type:token
SUP_SUP_EQ	cil/obj/x86_LINUX/formatparse.ml	/^  | SUP_SUP_EQ$/;"	C	type:token
SUP_SUP_EQ	cil/obj/x86_LINUX/formatparse.mli	/^  | SUP_SUP_EQ$/;"	C	type:token
SWITCH	cil/obj/x86_LINUX/cparser.ml	/^  | SWITCH of (Cabs.cabsloc)$/;"	C	type:token
SWITCH	cil/obj/x86_LINUX/cparser.mli	/^  | SWITCH of (Cabs.cabsloc)$/;"	C	type:token
SWITCH	cil/obj/x86_LINUX/formatparse.ml	/^  | SWITCH$/;"	C	type:token
SWITCH	cil/obj/x86_LINUX/formatparse.mli	/^  | SWITCH$/;"	C	type:token
SWITCH	cil/src/frontc/cabs.ml	/^ | SWITCH of expression * statement * cabsloc$/;"	C	type:statement
ScoredBranch	src/run_crest/concolic_search.cc	/^typedef pair<size_t,int> ScoredBranch;$/;"	t	namespace:crest::__anon11	file:
ScoredBranchComp	src/run_crest/concolic_search.cc	/^struct ScoredBranchComp$/;"	s	namespace:crest::__anon11	file:
Search	src/run_crest/concolic_search.cc	/^Search::Search(const string& program, int max_iterations)$/;"	f	class:crest::Search
Search	src/run_crest/concolic_search.h	/^class Search {$/;"	c	namespace:crest
Serialize	src/base/symbolic_execution.cc	/^void SymbolicExecution::Serialize(string* s) const {$/;"	f	class:crest::SymbolicExecution
Serialize	src/base/symbolic_expression.cc	/^void SymbolicExpr::Serialize(string* s) const {$/;"	f	class:crest::SymbolicExpr
Serialize	src/base/symbolic_path.cc	/^void SymbolicPath::Serialize(string* s) const {$/;"	f	class:crest::SymbolicPath
Serialize	src/base/symbolic_predicate.cc	/^void SymbolicPred::Serialize(string* s) const {$/;"	f	class:crest::SymbolicPred
Set	cil/src/cil.mli	/^    Set        of lval * exp * location  $/;"	C	type:instr
Setp	cil/src/ext/pta/setp.ml	1;"	M
Setp	cil/src/ext/pta/setp.mli	1;"	M
Sfi	cil/src/ext/sfi.ml	1;"	M
Signed	cil/src/ext/ciltools.ml	/^type sign = Signed | Unsigned $/;"	C	type:sign
Simplemem	cil/src/ext/simplemem.ml	1;"	M
Simplify	cil/src/ext/simplify.ml	1;"	M
SingleInit	cil/src/cil.mli	/^  | SingleInit   of exp   (** A single initializer *)$/;"	C	type:init
Size	src/base/symbolic_expression.h	/^  size_t Size() const { return (1 + coeff_.size()); }$/;"	f	class:crest::SymbolicExpr
SizeOf	cil/src/cil.mli	/^  | SizeOf     of typ                   $/;"	C	type:exp
SizeOfE	cil/src/cil.mli	/^  | SizeOfE    of exp                   $/;"	C	type:exp
SizeOfStr	cil/src/cil.mli	/^  | SizeOfStr  of string$/;"	C	type:exp
SkipChildren	cil/src/cil.mli	/^    SkipChildren                        (** Do not visit the children. Return $/;"	C	type:visitAction
SkipChildren	cil/src/frontc/cabsvisit.mli	/^    SkipChildren                        (* Do not visit the children. Return $/;"	C	type:visitAction
SkipUntilReturn	src/run_crest/concolic_search.cc	/^void CfgHeuristicSearch::SkipUntilReturn(const vector<branch_id_t> path, size_t* pos) {$/;"	f	class:crest::CfgHeuristicSearch
Solve	src/base/yices_solver.cc	/^bool YicesSolver::Solve(const map<var_t,type_t>& vars,$/;"	f	class:crest::YicesSolver
SolveAlongCfg	src/run_crest/concolic_search.cc	/^bool CfgHeuristicSearch::SolveAlongCfg(size_t i, unsigned int max_dist,$/;"	f	class:crest::CfgHeuristicSearch
SolveAtBranch	src/run_crest/concolic_search.cc	/^bool Search::SolveAtBranch(const SymbolicExecution& ex,$/;"	f	class:crest::Search
SolveRandomBranch	src/run_crest/concolic_search.cc	/^  bool RandomSearch::SolveRandomBranch(vector<value_t>* next_input, size_t* idx) {$/;"	f	class:crest::RandomSearch
SolveUncoveredBranches	src/run_crest/concolic_search.cc	/^void RandomSearch::SolveUncoveredBranches(size_t i, int depth,$/;"	f	class:crest::RandomSearch
Solver	cil/src/ext/predabst.ml	1;"	M
SomethingElse	cil/ocamlutil/clist.ml	/^  | SomethingElse$/;"	C	type:boxedInt
SpecAttr	cil/src/frontc/cabs.ml	/^  | SpecAttr of attribute       (* __attribute__ *)$/;"	C	type:spec_elem
SpecCV	cil/src/frontc/cabs.ml	/^  | SpecCV of cvspec            (* const\/volatile *)$/;"	C	type:spec_elem
SpecInline	cil/src/frontc/cabs.ml	/^  | SpecInline$/;"	C	type:spec_elem
SpecPattern	cil/src/frontc/cabs.ml	/^  | SpecPattern of string       (* specifier pattern variable *)$/;"	C	type:spec_elem
SpecStorage	cil/src/frontc/cabs.ml	/^  | SpecStorage of storage$/;"	C	type:spec_elem
SpecType	cil/src/frontc/cabs.ml	/^  | SpecType of typeSpecifier$/;"	C	type:spec_elem
SpecTypedef	cil/src/frontc/cabs.ml	/^    SpecTypedef          $/;"	C	type:spec_elem
Ssa	cil/src/ext/ssa.ml	1;"	M
Ssa	cil/src/ext/ssa.mli	1;"	M
Stack	cil/ocamlutil/util.mli	1;"	M
StackElem	src/base/symbolic_interpreter.h	/^  struct StackElem {$/;"	s	class:crest::SymbolicInterpreter
Stackoverflow	cil/src/ext/stackoverflow.ml	1;"	M
Stackoverflow	cil/src/ext/stackoverflow.mli	1;"	M
StartOf	cil/src/cil.mli	/^  | StartOf    of lval   $/;"	C	type:exp
Stats	cil/ocamlutil/stats.ml	1;"	M
Stats	cil/ocamlutil/stats.mli	1;"	M
Steensgaard	cil/src/ext/pta/steensgaard.ml	1;"	M
Steensgaard	cil/src/ext/pta/steensgaard.mli	1;"	M
Store	src/base/symbolic_interpreter.cc	/^    void SymbolicInterpreter::Store(id_t id, addr_t addr) {$/;"	f	class:crest::SymbolicInterpreter
StringSet	cil/src/ext/ssa.ml	1;"	M
Subterm	cil/src/ext/pta/steensgaard.ml	/^exception Subterm$/;"	e
Susp	cil/ocamlutil/growArray.mli	/^  | Susp of (int -> 'a)$/;"	C	type:fill
Swap	src/base/symbolic_execution.cc	/^void SymbolicExecution::Swap(SymbolicExecution& se) {$/;"	f	class:crest::SymbolicExecution
Swap	src/base/symbolic_path.cc	/^void SymbolicPath::Swap(SymbolicPath& sp) {$/;"	f	class:crest::SymbolicPath
Switch	cil/src/cil.mli	/^  | Switch of exp * block * (stmt list) * location  $/;"	C	type:stmtkind
SymbolicExecution	src/base/symbolic_execution.cc	/^SymbolicExecution::SymbolicExecution() { }$/;"	f	class:crest::SymbolicExecution
SymbolicExecution	src/base/symbolic_execution.cc	/^SymbolicExecution::SymbolicExecution(bool pre_allocate)$/;"	f	class:crest::SymbolicExecution
SymbolicExecution	src/base/symbolic_execution.h	/^class SymbolicExecution {$/;"	c	namespace:crest
SymbolicExpr	src/base/symbolic_expression.cc	/^SymbolicExpr::SymbolicExpr() : const_(0) { }$/;"	f	class:crest::SymbolicExpr
SymbolicExpr	src/base/symbolic_expression.cc	/^SymbolicExpr::SymbolicExpr(const SymbolicExpr& e)$/;"	f	class:crest::SymbolicExpr
SymbolicExpr	src/base/symbolic_expression.cc	/^SymbolicExpr::SymbolicExpr(value_t c) : const_(c) { }$/;"	f	class:crest::SymbolicExpr
SymbolicExpr	src/base/symbolic_expression.cc	/^SymbolicExpr::SymbolicExpr(value_t c, var_t v) : const_(0) {$/;"	f	class:crest::SymbolicExpr
SymbolicExpr	src/base/symbolic_expression.h	/^class SymbolicExpr {$/;"	c	namespace:crest
SymbolicInterpreter	src/base/symbolic_interpreter.cc	/^    SymbolicInterpreter::SymbolicInterpreter()$/;"	f	class:crest::SymbolicInterpreter
SymbolicInterpreter	src/base/symbolic_interpreter.cc	/^    SymbolicInterpreter::SymbolicInterpreter(const vector<value_t>& input)$/;"	f	class:crest::SymbolicInterpreter
SymbolicInterpreter	src/base/symbolic_interpreter.h	/^class SymbolicInterpreter {$/;"	c	namespace:crest
SymbolicPath	src/base/symbolic_path.cc	/^SymbolicPath::SymbolicPath() { }$/;"	f	class:crest::SymbolicPath
SymbolicPath	src/base/symbolic_path.cc	/^SymbolicPath::SymbolicPath(bool pre_allocate) {$/;"	f	class:crest::SymbolicPath
SymbolicPath	src/base/symbolic_path.h	/^class SymbolicPath {$/;"	c	namespace:crest
SymbolicPred	src/base/symbolic_predicate.cc	/^SymbolicPred::SymbolicPred()$/;"	f	class:crest::SymbolicPred
SymbolicPred	src/base/symbolic_predicate.cc	/^SymbolicPred::SymbolicPred(compare_op_t op, SymbolicExpr* expr)$/;"	f	class:crest::SymbolicPred
SymbolicPred	src/base/symbolic_predicate.h	/^class SymbolicPred {$/;"	c	namespace:crest
Symex	cil/src/ext/partial.ml	1;"	M
TArray	cil/src/cil.mli	/^  | TArray of typ * exp option * attributes$/;"	C	type:typ
TBuiltin_va_list	cil/src/cil.mli	/^  | TBuiltin_va_list of attributes$/;"	C	type:typ
TComp	cil/src/cil.mli	/^  | TComp of compinfo * attributes$/;"	C	type:typ
TEMP_DIR	cil/Makefile	/^TEMP_DIR = TEMP_cil-distrib$/;"	m
TESTCILARG	cil/Makefile	/^TESTCILARG=       --testcil "bash gcctestcil"$/;"	m
TESTCILARG	cil/Makefile	/^TESTCILARG=--MSVC --testcil "bash msvctestcil"$/;"	m
TESTS	test/Makefile	/^TESTS = simple function math concrete_return uniform_test$/;"	m
TEXINPUTS	cil/Makefile	/^	cd doc ; TEXINPUTS="$$TEXINPUTS:\/usr\/local\/lib\/ocaml\/ocamldoc:\/usr\/lib\/ocaml\/ocamldoc" pdflatex cil-api.tex$/;"	m
TEnum	cil/src/cil.mli	/^  | TEnum of enuminfo * attributes$/;"	C	type:typ
TFloat	cil/src/cil.mli	/^  | TFloat of fkind * attributes $/;"	C	type:typ
TFun	cil/src/cil.mli	/^  | TFun of typ * (string * typ * attributes) list option * bool * attributes$/;"	C	type:typ
THEN	cil/obj/x86_LINUX/formatparse.ml	/^  | THEN$/;"	C	type:token
THEN	cil/obj/x86_LINUX/formatparse.mli	/^  | THEN$/;"	C	type:token
THREAD	cil/obj/x86_LINUX/cparser.ml	/^  | THREAD of (Cabs.cabsloc)$/;"	C	type:token
THREAD	cil/obj/x86_LINUX/cparser.mli	/^  | THREAD of (Cabs.cabsloc)$/;"	C	type:token
TILDE	cil/obj/x86_LINUX/cparser.ml	/^  | TILDE of (Cabs.cabsloc)$/;"	C	type:token
TILDE	cil/obj/x86_LINUX/cparser.mli	/^  | TILDE of (Cabs.cabsloc)$/;"	C	type:token
TILDE	cil/obj/x86_LINUX/formatparse.ml	/^  | TILDE$/;"	C	type:token
TILDE	cil/obj/x86_LINUX/formatparse.mli	/^  | TILDE$/;"	C	type:token
TInt	cil/src/cil.mli	/^  | TInt of ikind * attributes $/;"	C	type:typ
TNamed	cil/src/cil.mli	/^  | TNamed of typeinfo * attributes $/;"	C	type:typ
TOP_DIR	cil/Makefile	/^TOP_DIR = $(TEMP_DIR)\/cil$/;"	m
TPtr	cil/src/cil.mli	/^  | TPtr of typ * attributes  $/;"	C	type:typ
TRANSFORMER	cil/src/frontc/cabs.ml	/^ | TRANSFORMER of definition * definition list * cabsloc$/;"	C	type:definition
TRANSLATOR	cil/src/ext/predabst.ml	1;"	M
TRY	cil/obj/x86_LINUX/cparser.ml	/^  | TRY of (Cabs.cabsloc)$/;"	C	type:token
TRY	cil/obj/x86_LINUX/cparser.mli	/^  | TRY of (Cabs.cabsloc)$/;"	C	type:token
TRY_EXCEPT	cil/src/frontc/cabs.ml	/^ | TRY_EXCEPT of block * expression * block * cabsloc$/;"	C	type:statement
TRY_FINALLY	cil/src/frontc/cabs.ml	/^ | TRY_FINALLY of block * block * cabsloc$/;"	C	type:statement
TSArray	cil/src/cil.mli	/^    TSArray of typsig * int64 option * attribute list$/;"	C	type:typsig
TSBase	cil/src/cil.mli	/^  | TSBase of typ$/;"	C	type:typsig
TSComp	cil/src/cil.mli	/^  | TSComp of bool * string * attribute list$/;"	C	type:typsig
TSEnum	cil/src/cil.mli	/^  | TSEnum of string * attribute list$/;"	C	type:typsig
TSFun	cil/src/cil.mli	/^  | TSFun of typsig * typsig list * bool * attribute list$/;"	C	type:typsig
TSPtr	cil/src/cil.mli	/^  | TSPtr of typsig * attribute list$/;"	C	type:typsig
TVoid	cil/src/cil.mli	/^    TVoid of attributes   (** Void type. Also predefined as {!Cil.voidType} *)$/;"	C	type:typ
TYPEDEF	cil/obj/x86_LINUX/cparser.ml	/^  | TYPEDEF of (Cabs.cabsloc)$/;"	C	type:token
TYPEDEF	cil/obj/x86_LINUX/cparser.mli	/^  | TYPEDEF of (Cabs.cabsloc)$/;"	C	type:token
TYPEDEF	cil/obj/x86_LINUX/formatparse.ml	/^  | TYPEDEF$/;"	C	type:token
TYPEDEF	cil/obj/x86_LINUX/formatparse.mli	/^  | TYPEDEF$/;"	C	type:token
TYPEDEF	cil/src/frontc/cabs.ml	/^ | TYPEDEF of name_group * cabsloc$/;"	C	type:definition
TYPEOF	cil/obj/x86_LINUX/cparser.ml	/^  | TYPEOF of (Cabs.cabsloc)$/;"	C	type:token
TYPEOF	cil/obj/x86_LINUX/cparser.mli	/^  | TYPEOF of (Cabs.cabsloc)$/;"	C	type:token
TYPEOF	cil/obj/x86_LINUX/formatparse.ml	/^  | TYPEOF$/;"	C	type:token
TYPEOF	cil/obj/x86_LINUX/formatparse.mli	/^  | TYPEOF$/;"	C	type:token
TYPE_ALIGNOF	cil/src/frontc/cabs.ml	/^  | TYPE_ALIGNOF of specifier * decl_type$/;"	C	type:expression
TYPE_SIZEOF	cil/src/frontc/cabs.ml	/^  | TYPE_SIZEOF of specifier * decl_type$/;"	C	type:expression
TYPE_SIZE_T	cil/config.h	26;"	d
TYPE_WCHAR_T	cil/config.h	28;"	d
TYPEaction	cil/doc/api/Dataflow.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEaction"><\/a><code class="type">'a<\/code> action = <\/code><table class="typetable">$/;"	a
TYPEalphaTableData	cil/doc/api/Alpha.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEalphaTableData"><\/a><code class="type">'a<\/code> alphaTableData <\/pre>$/;"	a
TYPEattribute	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEattribute"><\/a><code class="type"><\/code>attribute = <\/code><table class="typetable">$/;"	a
TYPEattributeClass	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEattributeClass"><\/a><code class="type"><\/code>attributeClass = <\/code><table class="typetable">$/;"	a
TYPEattributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEattributes"><\/a><code class="type"><\/code>attributes = <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> list<\/code> <\/pre>$/;"	a
TYPEattrparam	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEattrparam"><\/a><code class="type"><\/code>attrparam = <\/code><table class="typetable">$/;"	a
TYPEbinop	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEbinop"><\/a><code class="type"><\/code>binop = <\/code><table class="typetable">$/;"	a
TYPEblock	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEblock"><\/a><code class="type"><\/code>block = {<\/code><table class="typetable">$/;"	a
TYPEcilPrinter	cil/doc/api/Cil.cilPrinter.html	/^<pre><span class="keyword">class type<\/span> <a name="TYPEcilPrinter"><\/a>cilPrinter = <code class="code">object<\/code> <a href="Cil.cilPrinter.html">..<\/a> <code class="code">end<\/code><\/pre>A printer interface for CIL trees. Create instantiations of $/;"	a
TYPEcilPrinter	cil/doc/api/Cil.html	/^<pre><span class="keyword">class type<\/span> <a name="TYPEcilPrinter"><\/a><a href="Cil.cilPrinter.html">cilPrinter<\/a> = <code class="code">object<\/code> <a href="Cil.cilPrinter.html">..<\/a> <code class="code">end<\/code><\/pre><div class="info">$/;"	a
TYPEcilVisitor	cil/doc/api/Cil.cilVisitor.html	/^<pre><span class="keyword">class type<\/span> <a name="TYPEcilVisitor"><\/a>cilVisitor = <code class="code">object<\/code> <a href="Cil.cilVisitor.html">..<\/a> <code class="code">end<\/code><\/pre>A visitor interface for traversing CIL trees. Create instantiations of $/;"	a
TYPEcilVisitor	cil/doc/api/Cil.html	/^<pre><span class="keyword">class type<\/span> <a name="TYPEcilVisitor"><\/a><a href="Cil.cilVisitor.html">cilVisitor<\/a> = <code class="code">object<\/code> <a href="Cil.cilVisitor.html">..<\/a> <code class="code">end<\/code><\/pre><div class="info">$/;"	a
TYPEclist	cil/doc/api/Clist.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEclist"><\/a><code class="type">'a<\/code> clist = <\/code><table class="typetable">$/;"	a
TYPEcomment	cil/doc/api/Cil.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEcomment"><\/a><code class="type"><\/code>comment = <code class="type"><a href="Cil.html#TYPElocation">location<\/a> * string<\/code> <\/pre>$/;"	a
TYPEcompinfo	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEcompinfo"><\/a><code class="type"><\/code>compinfo = {<\/code><table class="typetable">$/;"	a
TYPEconstant	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEconstant"><\/a><code class="type"><\/code>constant = <\/code><table class="typetable">$/;"	a
TYPEdefaultCilPrinterClass	cil/doc/api/Cil.defaultCilPrinterClass.html	/^<pre><span class="keyword">class<\/span> <a name="TYPEdefaultCilPrinterClass"><\/a>defaultCilPrinterClass : <code class="type"><\/code><code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a><\/code><\/pre><hr width="100%">$/;"	a
TYPEdefaultCilPrinterClass	cil/doc/api/Cil.html	/^<pre><span class="keyword">class<\/span> <a name="TYPEdefaultCilPrinterClass"><\/a><a href="Cil.defaultCilPrinterClass.html">defaultCilPrinterClass<\/a> : <code class="type"><\/code><code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdefaultCilPrinter"><\/a>defaultCilPrinter : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a><\/code><\/pre><pre><span class="keyword">class<\/span> <a name="TYPEplainCilPrinterClass"><\/a><a href="Cil.plainCilPrinterClass.html">plainCilPrinterClass<\/a> : <code class="type"><\/code><code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a><\/code><\/pre><div class="info">$/;"	a
TYPEdescriptiveCilPrinter	cil/doc/api/Cil.descriptiveCilPrinter.html	/^<pre><span class="keyword">class type<\/span> <a name="TYPEdescriptiveCilPrinter"><\/a>descriptiveCilPrinter = <code class="code">object<\/code> <a href="Cil.descriptiveCilPrinter.html">..<\/a> <code class="code">end<\/code><\/pre><b>Inherits<\/b><ul>$/;"	a
TYPEdescriptiveCilPrinterClass	cil/doc/api/Cil.descriptiveCilPrinterClass.html	/^<pre><span class="keyword">class<\/span> <a name="TYPEdescriptiveCilPrinterClass"><\/a>descriptiveCilPrinterClass : <code class="type"><\/code><code class="type"><a href="Cil.descriptiveCilPrinter.html">descriptiveCilPrinter<\/a><\/code><\/pre>Like defaultCilPrinterClass, but instead of temporary variable$/;"	a
TYPEdoc	cil/doc/api/Pretty.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEdoc"><\/a><code class="type"><\/code>doc <\/pre>$/;"	a
TYPEelt	cil/doc/api/Pretty.MakeSetPrinter.html	/^<pre><span class="keyword">module<\/span> MakeSetPrinter: <div class="sig_block"><code class="code">functor (<\/code><code class="code">Set<\/code><code class="code"> : <\/code><code class="code">sig<\/code><div class="sig_block"><pre><span class="keyword">type<\/span> <a name="TYPEelt"><\/a><code class="type"><\/code>elt <\/pre>$/;"	a
TYPEelt	cil/doc/api/Pretty.html	/^<pre><span class="keyword">module<\/span> <a href="Pretty.MakeSetPrinter.html">MakeSetPrinter<\/a>: <div class="sig_block"><code class="code">functor (<\/code><code class="code">Set<\/code><code class="code"> : <\/code><code class="code">sig<\/code><div class="sig_block"><pre><span class="keyword">type<\/span> <a name="TYPEelt"><\/a><code class="type"><\/code>elt <\/pre>$/;"	a
TYPEenuminfo	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEenuminfo"><\/a><code class="type"><\/code>enuminfo = {<\/code><table class="typetable">$/;"	a
TYPEexistsAction	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEexistsAction"><\/a><code class="type"><\/code>existsAction = <\/code><table class="typetable">$/;"	a
TYPEexp	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEexp"><\/a><code class="type"><\/code>exp = <\/code><table class="typetable">$/;"	a
TYPEfeatureDescr	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEfeatureDescr"><\/a><code class="type"><\/code>featureDescr = {<\/code><table class="typetable">$/;"	a
TYPEfieldinfo	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEfieldinfo"><\/a><code class="type"><\/code>fieldinfo = {<\/code><table class="typetable">$/;"	a
TYPEfile	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEfile"><\/a><code class="type"><\/code>file = {<\/code><table class="typetable">$/;"	a
TYPEfkind	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEfkind"><\/a><code class="type"><\/code>fkind = <\/code><table class="typetable">$/;"	a
TYPEformatArg	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEformatArg"><\/a><code class="type"><\/code>formatArg = <\/code><table class="typetable">$/;"	a
TYPEfundec	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEfundec"><\/a><code class="type"><\/code>fundec = {<\/code><table class="typetable">$/;"	a
TYPEglobal	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEglobal"><\/a><code class="type"><\/code>global = <\/code><table class="typetable">$/;"	a
TYPEguardaction	cil/doc/api/Dataflow.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEguardaction"><\/a><code class="type">'a<\/code> guardaction = <\/code><table class="typetable">$/;"	a
TYPEikind	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEikind"><\/a><code class="type"><\/code>ikind = <\/code><table class="typetable">$/;"	a
TYPEinit	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEinit"><\/a><code class="type"><\/code>init = <\/code><table class="typetable">$/;"	a
TYPEinitinfo	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEinitinfo"><\/a><code class="type"><\/code>initinfo = {<\/code><table class="typetable">$/;"	a
TYPEinstr	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEinstr"><\/a><code class="type"><\/code>instr = <\/code><table class="typetable">$/;"	a
TYPEkey	cil/doc/api/Pretty.MakeMapPrinter.html	/^<pre><span class="keyword">module<\/span> MakeMapPrinter: <div class="sig_block"><code class="code">functor (<\/code><code class="code">Map<\/code><code class="code"> : <\/code><code class="code">sig<\/code><div class="sig_block"><pre><span class="keyword">type<\/span> <a name="TYPEkey"><\/a><code class="type"><\/code>key <\/pre>$/;"	a
TYPElabel	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPElabel"><\/a><code class="type"><\/code>label = <\/code><table class="typetable">$/;"	a
TYPElhost	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPElhost"><\/a><code class="type"><\/code>lhost = <\/code><table class="typetable">$/;"	a
TYPElineDirectiveStyle	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPElineDirectiveStyle"><\/a><code class="type"><\/code>lineDirectiveStyle = <\/code><table class="typetable">$/;"	a
TYPElocation	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPElocation"><\/a><code class="type"><\/code>location = {<\/code><table class="typetable">$/;"	a
TYPElval	cil/doc/api/Cil.html	/^<pre><span class="keyword">type<\/span> <a name="TYPElval"><\/a><code class="type"><\/code>lval = <code class="type"><a href="Cil.html#TYPElhost">lhost<\/a> * <a href="Cil.html#TYPEoffset">offset<\/a><\/code> <\/pre>$/;"	a
TYPEnopCilVisitor	cil/doc/api/Cil.html	/^<pre><span class="keyword">class<\/span> <a name="TYPEnopCilVisitor"><\/a><a href="Cil.nopCilVisitor.html">nopCilVisitor<\/a> : <code class="type"><\/code><code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a><\/code><\/pre><div class="info">$/;"	a
TYPEnopCilVisitor	cil/doc/api/Cil.nopCilVisitor.html	/^<pre><span class="keyword">class<\/span> <a name="TYPEnopCilVisitor"><\/a>nopCilVisitor : <code class="type"><\/code><code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a><\/code><\/pre>Default Visitor. Traverses the CIL tree without modifying anything<br>$/;"	a
TYPEoffset	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEoffset"><\/a><code class="type"><\/code>offset = <\/code><table class="typetable">$/;"	a
TYPEorder	cil/doc/api/Dominators.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEorder"><\/a><code class="type"><\/code>order = <\/code><table class="typetable">$/;"	a
TYPEplainCilPrinterClass	cil/doc/api/Cil.plainCilPrinterClass.html	/^<pre><span class="keyword">class<\/span> <a name="TYPEplainCilPrinterClass"><\/a>plainCilPrinterClass : <code class="type"><\/code><code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a><\/code><\/pre>These are pretty-printers that will show you more details on the internal $/;"	a
TYPEstmt	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEstmt"><\/a><code class="type"><\/code>stmt = {<\/code><table class="typetable">$/;"	a
TYPEstmtaction	cil/doc/api/Dataflow.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEstmtaction"><\/a><code class="type">'a<\/code> stmtaction = <\/code><table class="typetable">$/;"	a
TYPEstmtkind	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEstmtkind"><\/a><code class="type"><\/code>stmtkind = <\/code><table class="typetable">$/;"	a
TYPEstorage	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEstorage"><\/a><code class="type"><\/code>storage = <\/code><table class="typetable">$/;"	a
TYPEt	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEt"><\/a><code class="type"><\/code>t <\/pre>$/;"	a
TYPEt	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEt"><\/a><code class="type"><\/code>t <\/pre>$/;"	a
TYPEt	cil/doc/api/Pretty.MakeMapPrinter.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEt"><\/a><code class="type">'a<\/code> t <\/pre>$/;"	a
TYPEt	cil/doc/api/Pretty.MakeSetPrinter.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEt"><\/a><code class="type"><\/code>t <\/pre>$/;"	a
TYPEt	cil/doc/api/Pretty.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEt"><\/a><code class="type">'a<\/code> t <\/pre>$/;"	a
TYPEt	cil/doc/api/Pretty.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEt"><\/a><code class="type"><\/code>t <\/pre>$/;"	a
TYPEtimerModeEnum	cil/doc/api/Stats.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEtimerModeEnum"><\/a><code class="type"><\/code>timerModeEnum = <\/code><table class="typetable">$/;"	a
TYPEtree	cil/doc/api/Dominators.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEtree"><\/a><code class="type"><\/code>tree <\/pre>$/;"	a
TYPEtyp	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEtyp"><\/a><code class="type"><\/code>typ = <\/code><table class="typetable">$/;"	a
TYPEtypeinfo	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEtypeinfo"><\/a><code class="type"><\/code>typeinfo = {<\/code><table class="typetable">$/;"	a
TYPEtypsig	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEtypsig"><\/a><code class="type"><\/code>typsig = <\/code><table class="typetable">$/;"	a
TYPEundoAlphaElement	cil/doc/api/Alpha.html	/^<pre><span class="keyword">type<\/span> <a name="TYPEundoAlphaElement"><\/a><code class="type">'a<\/code> undoAlphaElement <\/pre>$/;"	a
TYPEunop	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEunop"><\/a><code class="type"><\/code>unop = <\/code><table class="typetable">$/;"	a
TYPEvarinfo	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEvarinfo"><\/a><code class="type"><\/code>varinfo = {<\/code><table class="typetable">$/;"	a
TYPEvisitAction	cil/doc/api/Cil.html	/^<br><code><span class="keyword">type<\/span> <a name="TYPEvisitAction"><\/a><code class="type">'a<\/code> visitAction = <\/code><table class="typetable">$/;"	a
TempFile	cil/lib/TempFile.pm	/^package TempFile;$/;"	p
TermIt	src/base/symbolic_expression.h	/^  typedef map<var_t,value_t>::const_iterator TermIt;$/;"	t	class:crest::SymbolicExpr
Testcil	cil/src/testcil.ml	1;"	M
Text	cil/ocamlutil/pretty.ml	/^  | Text     of string$/;"	C	type:doc
ToMerge	cil/lib/Cilly.pm	/^          ToMerge:$/;"	l
Trace	cil/ocamlutil/trace.ml	1;"	M
Trace	cil/ocamlutil/trace.mli	1;"	M
TryExcept	cil/src/cil.mli	/^  | TryExcept of block * (instr list * exp) * block * location$/;"	C	type:stmtkind
TryFinally	cil/src/cil.mli	/^  | TryFinally of block * block * location$/;"	C	type:stmtkind
Tvoid	cil/src/frontc/cabs.ml	/^    Tvoid                             (* Type specifier ISO 6.7.2 *)$/;"	C	type:typeSpecifier
U	cil/src/ext/pta/golf.ml	1;"	M
U	cil/src/ext/pta/olf.ml	1;"	M
U	cil/src/ext/pta/steensgaard.ml	1;"	M
UNARY	cil/src/frontc/cabs.ml	/^  | UNARY of unary_operator * expression$/;"	C	type:expression
UNION	cil/obj/x86_LINUX/cparser.ml	/^  | UNION of (Cabs.cabsloc)$/;"	C	type:token
UNION	cil/obj/x86_LINUX/cparser.mli	/^  | UNION of (Cabs.cabsloc)$/;"	C	type:token
UNION	cil/obj/x86_LINUX/formatparse.ml	/^  | UNION$/;"	C	type:token
UNION	cil/obj/x86_LINUX/formatparse.mli	/^  | UNION$/;"	C	type:token
UNSAFE	cil/Makefile	/^  UNSAFE     := 1$/;"	m
UNSIGNED	cil/obj/x86_LINUX/cparser.ml	/^  | UNSIGNED of (Cabs.cabsloc)$/;"	C	type:token
UNSIGNED	cil/obj/x86_LINUX/cparser.mli	/^  | UNSIGNED of (Cabs.cabsloc)$/;"	C	type:token
UNSIGNED	cil/obj/x86_LINUX/formatparse.ml	/^  | UNSIGNED$/;"	C	type:token
UNSIGNED	cil/obj/x86_LINUX/formatparse.mli	/^  | UNSIGNED$/;"	C	type:token
U_CHAR	src/base/basic_types.h	/^enum type_t { U_CHAR = 0,       CHAR = 1,$/;"	e	enum:crest::types::type_t
U_INT	src/base/basic_types.h	/^	      U_INT = 4,        INT = 5,$/;"	e	enum:crest::types::type_t
U_LONG	src/base/basic_types.h	/^	      U_LONG = 6,       LONG = 7,$/;"	e	enum:crest::types::type_t
U_LONG_LONG	src/base/basic_types.h	/^	      U_LONG_LONG = 8,  LONG_LONG = 9 };$/;"	e	enum:crest::types::type_t
U_SHORT	src/base/basic_types.h	/^	      U_SHORT = 2,      SHORT = 3,$/;"	e	enum:crest::types::type_t
UnOp	cil/src/cil.mli	/^  | UnOp       of unop * exp * typ     $/;"	C	type:exp
Unalign	cil/ocamlutil/pretty.ml	/^  | Unalign  $/;"	C	type:doc
UniformRandomSearch	src/run_crest/concolic_search.cc	/^UniformRandomSearch::UniformRandomSearch(const string& program,$/;"	f	class:crest::UniformRandomSearch
UniformRandomSearch	src/run_crest/concolic_search.h	/^class UniformRandomSearch : public Search {$/;"	c	namespace:crest
UnknownLocation	cil/src/ext/pta/golf.ml	/^exception UnknownLocation$/;"	e
UnknownLocation	cil/src/ext/pta/golf.mli	/^exception UnknownLocation$/;"	e
UnknownLocation	cil/src/ext/pta/olf.ml	/^exception UnknownLocation$/;"	e
UnknownLocation	cil/src/ext/pta/olf.mli	/^exception UnknownLocation$/;"	e
UnknownLocation	cil/src/ext/pta/ptranal.mli	/^exception UnknownLocation$/;"	e
Unmark	cil/ocamlutil/pretty.ml	/^  | Unmark$/;"	C	type:doc
Unsigned	cil/src/ext/ciltools.ml	/^type sign = Signed | Unsigned $/;"	C	type:sign
Unspecified	cil/src/ext/astslicer.ml	/^type mark = Wanted | Unwanted | Unspecified$/;"	C	type:mark
Unwanted	cil/src/ext/astslicer.ml	/^type mark = Wanted | Unwanted | Unspecified$/;"	C	type:mark
UpdateBranchDistances	src/run_crest/concolic_search.cc	/^void CfgHeuristicSearch::UpdateBranchDistances() {$/;"	f	class:crest::CfgHeuristicSearch
UpdateCoverage	src/run_crest/concolic_search.cc	/^bool Search::UpdateCoverage(const SymbolicExecution& ex) {$/;"	f	class:crest::Search
UpdateCoverage	src/run_crest/concolic_search.cc	/^bool Search::UpdateCoverage(const SymbolicExecution& ex,$/;"	f	class:crest::Search
Uref	cil/src/ext/pta/uref.ml	1;"	M
Uref	cil/src/ext/pta/uref.mli	1;"	M
Usage	cil/bin/patcher	/^Usage: patcher [options] args$/;"	l
Usedef	cil/src/ext/usedef.ml	1;"	M
Util	cil/ocamlutil/util.ml	1;"	M
Util	cil/ocamlutil/util.mli	1;"	M
VAL(++)	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VAL(++)"><\/a>(++) : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALaddAttribute	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALaddAttribute"><\/a>addAttribute : <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALaddAttributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALaddAttributes"><\/a>addAttributes : <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> list -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALaddOffset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALaddOffset"><\/a>addOffset : <code class="type"><a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a><\/code><\/pre><div class="info">$/;"	a
VALaddOffsetLval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALaddOffsetLval"><\/a>addOffsetLval : <code class="type"><a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPElval">lval<\/a><\/code><\/pre><div class="info">$/;"	a
VALalign	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALalign"><\/a>align : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALalignOf_int	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALalignOf_int"><\/a>alignOf_int : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> int<\/code><\/pre><div class="info">$/;"	a
VALappend	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALappend"><\/a>append : <code class="type">'a <a href="Clist.html#TYPEclist">clist<\/a> -> 'a <a href="Clist.html#TYPEclist">clist<\/a> -> 'a <a href="Clist.html#TYPEclist">clist<\/a><\/code><\/pre><div class="info">$/;"	a
VALargsToList	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALargsToList"><\/a>argsToList : <code class="type">(string * <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEattributes">attributes<\/a>) list option -><br>       (string * <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEattributes">attributes<\/a>) list<\/code><\/pre><div class="info">$/;"	a
VALattributeHash	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALattributeHash"><\/a>attributeHash : <code class="type">(string, <a href="Cil.html#TYPEattributeClass">attributeClass<\/a>) Hashtbl.t<\/code><\/pre><div class="info">$/;"	a
VALauto_printer	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALauto_printer"><\/a>auto_printer : <code class="type">string -> 'a<\/code><\/pre><div class="info">$/;"	a
VALbitsOffset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALbitsOffset"><\/a>bitsOffset : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> int * int<\/code><\/pre><div class="info">$/;"	a
VALbitsSizeOf	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALbitsSizeOf"><\/a>bitsSizeOf : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> int<\/code><\/pre><div class="info">$/;"	a
VALbreak	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALbreak"><\/a>break : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALbug	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALbug"><\/a>bug : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALbug	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALbug"><\/a>bug : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALbuiltinFunctions	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALbuiltinFunctions"><\/a>builtinFunctions : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEtyp">typ<\/a> list * bool) Hashtbl.t<\/code><\/pre><div class="info">$/;"	a
VALbuiltinLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALbuiltinLoc"><\/a>builtinLoc : <code class="type"><a href="Cil.html#TYPElocation">location<\/a><\/code><\/pre><div class="info">$/;"	a
VALcExp	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcExp"><\/a>cExp : <code class="type">string -> (string * <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a>) list -> <a href="Cil.html#TYPEexp">Cil.exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALcInstr	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcInstr"><\/a>cInstr : <code class="type">string -> <a href="Cil.html#TYPElocation">Cil.location<\/a> -> (string * <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a>) list -> <a href="Cil.html#TYPEinstr">Cil.instr<\/a><\/code><\/pre><div class="info">$/;"	a
VALcLval	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcLval"><\/a>cLval : <code class="type">string -> (string * <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a>) list -> <a href="Cil.html#TYPElval">Cil.lval<\/a><\/code><\/pre><div class="info">$/;"	a
VALcStmt	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcStmt"><\/a>cStmt : <code class="type">string -><br>       (string -> <a href="Cil.html#TYPEtyp">Cil.typ<\/a> -> <a href="Cil.html#TYPEvarinfo">Cil.varinfo<\/a>) -><br>       <a href="Cil.html#TYPElocation">Cil.location<\/a> -> (string * <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a>) list -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALcStmts"><\/a>cStmts : <code class="type">string -><br>       (string -> <a href="Cil.html#TYPEtyp">Cil.typ<\/a> -> <a href="Cil.html#TYPEvarinfo">Cil.varinfo<\/a>) -><br>       <a href="Cil.html#TYPElocation">Cil.location<\/a> -> (string * <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a>) list -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALcType	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcType"><\/a>cType : <code class="type">string -> (string * <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a>) list -> <a href="Cil.html#TYPEtyp">Cil.typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALcfgFun	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALcfgFun"><\/a>cfgFun : <code class="type"><a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> int<\/code><\/pre><div class="info">$/;"	a
VALcharConstToInt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcharConstToInt"><\/a>charConstToInt : <code class="type">char -> <a href="Cil.html#TYPEconstant">constant<\/a><\/code><\/pre><div class="info">$/;"	a
VALcharPtrType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcharPtrType"><\/a>charPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALcharType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcharType"><\/a>charType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALchar_is_unsigned	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALchar_is_unsigned"><\/a>char_is_unsigned : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALcheckBeforeAppend	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALcheckBeforeAppend"><\/a>checkBeforeAppend : <code class="type">'a <a href="Clist.html#TYPEclist">clist<\/a> -> 'a <a href="Clist.html#TYPEclist">clist<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALchildren	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALchildren"><\/a>children : <code class="type"><a href="Dominators.html#TYPEtree">tree<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALchr	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALchr"><\/a>chr : <code class="type">char -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALcilVersion	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcilVersion"><\/a>cilVersion : <code class="type">string<\/code><\/pre><div class="info">$/;"	a
VALcilVersionMajor	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcilVersionMajor"><\/a>cilVersionMajor : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALcilVersionMinor"><\/a>cilVersionMinor : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALcilVersionRevision"><\/a>cilVersionRevision : <code class="type">int<\/code><\/pre><br>$/;"	a
VALclearCFGinfo	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALclearCFGinfo"><\/a>clearCFGinfo : <code class="type"><a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALclearFileCFG	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALclearFileCFG"><\/a>clearFileCFG : <code class="type"><a href="Cil.html#TYPEfile">Cil.file<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALcombinePredecessors	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALcombinePredecessors"><\/a>combinePredecessors : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -><br>       old:<a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -><br>       <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> option<\/code><\/pre><div class="info">$/;"	a
VALcombineStmtStartData	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALcombineStmtStartData"><\/a>combineStmtStartData : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -><br>       old:<a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> -><br>       <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> option<\/code><\/pre><div class="info">$/;"	a
VALcombineSuccessors	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALcombineSuccessors"><\/a>combineSuccessors : <code class="type"><a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> -><br>       <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a><\/code><\/pre><div class="info">$/;"	a
VALcompFullName	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcompFullName"><\/a>compFullName : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo<\/a> -> string<\/code><\/pre><div class="info">$/;"	a
VALcompactStmts	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcompactStmts"><\/a>compactStmts : <code class="type"><a href="Cil.html#TYPEstmt">stmt<\/a> list -> <a href="Cil.html#TYPEstmt">stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALcompareLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcompareLoc"><\/a>compareLoc : <code class="type"><a href="Cil.html#TYPElocation">location<\/a> -> <a href="Cil.html#TYPElocation">location<\/a> -> int<\/code><\/pre><div class="info">$/;"	a
VALcompute	cil/doc/api/Dataflow.BackwardsDataFlow.html	/^<pre><span class="keyword">val<\/span> <a name="VALcompute"><\/a>compute : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
VALcompute	cil/doc/api/Dataflow.ForwardsDataFlow.html	/^<pre><span class="keyword">val<\/span> <a name="VALcompute"><\/a>compute : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
VALcomputeCFGInfo	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcomputeCFGInfo"><\/a>computeCFGInfo : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> bool -> unit<\/code><\/pre><div class="info">$/;"	a
VALcomputeDomTree	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALcomputeDomTree"><\/a>computeDomTree : <code class="type">?doCFG:bool -> <a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> option Inthash.t * <a href="Dominators.html#TYPEtree">tree<\/a><\/code><\/pre><div class="info">$/;"	a
VALcomputeFileCFG	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALcomputeFileCFG"><\/a>computeFileCFG : <code class="type"><a href="Cil.html#TYPEfile">Cil.file<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALcomputeFirstPredecessor	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALcomputeFirstPredecessor"><\/a>computeFirstPredecessor : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a><\/code><\/pre><div class="info">$/;"	a
VALcomputeIDom	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALcomputeIDom"><\/a>computeIDom : <code class="type">?doCFG:bool -> <a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> option Inthash.t<\/code><\/pre><div class="info">$/;"	a
VALconcat	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALconcat"><\/a>concat : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALtext"><\/a>text : <code class="type">string -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALconstFold	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALconstFold"><\/a>constFold : <code class="type">bool -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALconstFoldBinOp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALconstFoldBinOp"><\/a>constFoldBinOp : <code class="type">bool -> <a href="Cil.html#TYPEbinop">binop<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALconstFoldVisitor	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALconstFoldVisitor"><\/a>constFoldVisitor : <code class="type">bool -> <a href="Cil.cilVisitor.html">cilVisitor<\/a><\/code><\/pre><div class="info">$/;"	a
VALcopy	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALcopy"><\/a>copy : <code class="type"><a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a><\/code><\/pre><div class="info">$/;"	a
VALcopyCompInfo	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcopyCompInfo"><\/a>copyCompInfo : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo<\/a> -> string -> <a href="Cil.html#TYPEcompinfo">compinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALcopyFunction	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcopyFunction"><\/a>copyFunction : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> string -> <a href="Cil.html#TYPEfundec">fundec<\/a><\/code><\/pre><div class="info">$/;"	a
VALcopyVarinfo	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcopyVarinfo"><\/a>copyVarinfo : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> string -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALcountNewLines	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALcountNewLines"><\/a>countNewLines : <code class="type">int ref<\/code><\/pre><div class="info">$/;"	a
VALcurrentGlobal	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcurrentGlobal"><\/a>currentGlobal : <code class="type"><a href="Cil.html#TYPEglobal">global<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALcurrentLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALcurrentLoc"><\/a>currentLoc : <code class="type"><a href="Cil.html#TYPElocation">location<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALdExp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdExp"><\/a>dExp : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALdExp	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdExp"><\/a>dExp : <code class="type">string -> <a href="Cil.html#TYPEexp">Cil.exp<\/a> -> <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a> list option<\/code><\/pre><div class="info">$/;"	a
VALdGlobal	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdGlobal"><\/a>dGlobal : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> <a href="Cil.html#TYPElocation">location<\/a> -> <a href="Cil.html#TYPEglobal">global<\/a><\/code><\/pre><div class="info">$/;"	a
VALdInstr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdInstr"><\/a>dInstr : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> <a href="Cil.html#TYPElocation">location<\/a> -> <a href="Cil.html#TYPEinstr">instr<\/a><\/code><\/pre><div class="info">$/;"	a
VALdInstr	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdInstr"><\/a>dInstr : <code class="type">string -> <a href="Cil.html#TYPEinstr">Cil.instr<\/a> -> <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a> list option<\/code><\/pre><div class="info">$/;"	a
VALdLval	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdLval"><\/a>dLval : <code class="type">string -> <a href="Cil.html#TYPElval">Cil.lval<\/a> -> <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a> list option<\/code><\/pre><div class="info">$/;"	a
VALdType	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdType"><\/a>dType : <code class="type">string -> <a href="Cil.html#TYPEtyp">Cil.typ<\/a> -> <a href="Cil.html#TYPEformatArg">Cil.formatArg<\/a> list option<\/code><\/pre><div class="info">$/;"	a
VALd_attr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_attr"><\/a>d_attr : <code class="type">unit -> <a href="Cil.html#TYPEattribute">attribute<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_attrlist	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_attrlist"><\/a>d_attrlist : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_attrparam	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_attrparam"><\/a>d_attrparam : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_binop	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_binop"><\/a>d_binop : <code class="type">unit -> <a href="Cil.html#TYPEbinop">binop<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_block	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_block"><\/a>d_block : <code class="type">unit -> <a href="Cil.html#TYPEblock">block<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_const	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_const"><\/a>d_const : <code class="type">unit -> <a href="Cil.html#TYPEconstant">constant<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_exp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_exp"><\/a>d_exp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_fkind	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_fkind"><\/a>d_fkind : <code class="type">unit -> <a href="Cil.html#TYPEfkind">fkind<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_formatarg	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_formatarg"><\/a>d_formatarg : <code class="type">unit -> <a href="Cil.html#TYPEformatArg">formatArg<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_global	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_global"><\/a>d_global : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_ikind	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_ikind"><\/a>d_ikind : <code class="type">unit -> <a href="Cil.html#TYPEikind">ikind<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_init	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_init"><\/a>d_init : <code class="type">unit -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_instr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_instr"><\/a>d_instr : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_int32	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_int32"><\/a>d_int32 : <code class="type">int32 -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_label	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_label"><\/a>d_label : <code class="type">unit -> <a href="Cil.html#TYPElabel">label<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_list	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_list"><\/a>d_list : <code class="type">string -> (unit -> 'a -> <a href="Pretty.html#TYPEdoc">doc<\/a>) -> unit -> 'a list -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_loc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_loc"><\/a>d_loc : <code class="type">unit -> <a href="Cil.html#TYPElocation">location<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_loc	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_loc"><\/a>d_loc : <code class="type">unit -> <a href="Errormsg.html#TYPElocation">location<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALd_hloc"><\/a>d_hloc : <code class="type">unit -> <a href="Errormsg.html#TYPElocation">location<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALgetLocation"><\/a>getLocation : <code class="type">unit -> <a href="Errormsg.html#TYPElocation">location<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALparse_error"><\/a>parse_error : <code class="type">string -> 'a<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALlocUnknown"><\/a>locUnknown : <code class="type"><a href="Errormsg.html#TYPElocation">location<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_lval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_lval"><\/a>d_lval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_map	cil/doc/api/Pretty.MakeMapPrinter.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_map"><\/a>d_map : <code class="type">?dmaplet:(<a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -><br>       string -><br>       (unit -> Map.key -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -><br>       (unit -> 'a -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> unit -> 'a Map.t -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_offset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_offset"><\/a>d_offset : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> unit -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_plainexp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_plainexp"><\/a>d_plainexp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_plaininit	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_plaininit"><\/a>d_plaininit : <code class="type">unit -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_plainlval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_plainlval"><\/a>d_plainlval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_plaintype	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_plaintype"><\/a>d_plaintype : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_set	cil/doc/api/Pretty.MakeSetPrinter.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_set"><\/a>d_set : <code class="type">string -> (unit -> Set.elt -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> unit -> Set.t -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_stmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_stmt"><\/a>d_stmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_storage	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_storage"><\/a>d_storage : <code class="type">unit -> <a href="Cil.html#TYPEstorage">storage<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_thisloc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_thisloc"><\/a>d_thisloc : <code class="type">unit -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_type	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_type"><\/a>d_type : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_typsig	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_typsig"><\/a>d_typsig : <code class="type">unit -> <a href="Cil.html#TYPEtypsig">typsig<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALd_unop	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALd_unop"><\/a>d_unop : <code class="type">unit -> <a href="Cil.html#TYPEunop">unop<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdd_exp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdd_exp"><\/a>dd_exp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdebug	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdebug"><\/a>debug : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALdebug	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdebug"><\/a>debug : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALdebugFlag	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALdebugFlag"><\/a>debugFlag : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALderefStarLevel	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALderefStarLevel"><\/a>derefStarLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALindexLevel"><\/a>indexLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALarrowLevel"><\/a>arrowLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALaddrOfLevel"><\/a>addrOfLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALadditiveLevel"><\/a>additiveLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALcomparativeLevel"><\/a>comparativeLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALbitwiseLevel"><\/a>bitwiseLevel : <code class="type">int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALgetParenthLevel"><\/a>getParenthLevel : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> int<\/code><\/pre><div class="info">$/;"	a
VALdescriptiveCilPrinter	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdescriptiveCilPrinter"><\/a>descriptiveCilPrinter : <code class="type"><a href="Cil.descriptiveCilPrinter.html">descriptiveCilPrinter<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALprinterForMaincil"><\/a>printerForMaincil : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALdn_exp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdn_exp"><\/a>dn_exp : <code class="type">unit -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdn_lval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdn_lval"><\/a>dn_lval : <code class="type">unit -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_init"><\/a>dn_init : <code class="type">unit -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_type"><\/a>dn_type : <code class="type">unit -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_global"><\/a>dn_global : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_attrlist"><\/a>dn_attrlist : <code class="type">unit -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_attr"><\/a>dn_attr : <code class="type">unit -> <a href="Cil.html#TYPEattribute">attribute<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_attrparam"><\/a>dn_attrparam : <code class="type">unit -> <a href="Cil.html#TYPEattrparam">attrparam<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_stmt"><\/a>dn_stmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALdn_instr"><\/a>dn_instr : <code class="type">unit -> <a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALd_shortglobal"><\/a>d_shortglobal : <code class="type">unit -> <a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdoGuard	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdoGuard"><\/a>doGuard : <code class="type"><a href="Cil.html#TYPEexp">Cil.exp<\/a> -><br>       <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -><br>       <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> <a href="Dataflow.html#TYPEguardaction">Dataflow.guardaction<\/a><\/code><\/pre><div class="info">$/;"	a
VALdoInstr	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdoInstr"><\/a>doInstr : <code class="type"><a href="Cil.html#TYPEinstr">Cil.instr<\/a> -><br>       <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> <a href="Dataflow.html#TYPEaction">Dataflow.action<\/a><\/code><\/pre><div class="info">$/;"	a
VALdoInstr	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdoInstr"><\/a>doInstr : <code class="type"><a href="Cil.html#TYPEinstr">Cil.instr<\/a> -><br>       <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -> <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> <a href="Dataflow.html#TYPEaction">Dataflow.action<\/a><\/code><\/pre><div class="info">$/;"	a
VALdoStmt	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdoStmt"><\/a>doStmt : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> <a href="Dataflow.html#TYPEaction">Dataflow.action<\/a><\/code><\/pre><div class="info">$/;"	a
VALdoStmt	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALdoStmt"><\/a>doStmt : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -><br>       <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -><br>       <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> <a href="Dataflow.html#TYPEstmtaction">Dataflow.stmtaction<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocAlphaTable	cil/doc/api/Alpha.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocAlphaTable"><\/a>docAlphaTable : <code class="type">unit -><br>       (string, 'a <a href="Alpha.html#TYPEalphaTableData">alphaTableData<\/a> ref) Hashtbl.t -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocArray	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocArray"><\/a>docArray : <code class="type">?sep:<a href="Pretty.html#TYPEdoc">doc<\/a> -><br>       (int -> 'a -> <a href="Pretty.html#TYPEdoc">doc<\/a>) -> unit -> 'a array -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocCList	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocCList"><\/a>docCList : <code class="type"><a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> ('a -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> unit -> 'a <a href="Clist.html#TYPEclist">clist<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocList	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocList"><\/a>docList : <code class="type">?sep:<a href="Pretty.html#TYPEdoc">doc<\/a> -> ('a -> <a href="Pretty.html#TYPEdoc">doc<\/a>) -> unit -> 'a list -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocMap	cil/doc/api/Pretty.MakeMapPrinter.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocMap"><\/a>docMap : <code class="type">?sep:<a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -><br>       (Map.key -> 'a -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> unit -> 'a Map.t -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocOpt	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocOpt"><\/a>docOpt : <code class="type">('a -> <a href="Pretty.html#TYPEdoc">doc<\/a>) -> unit -> 'a option -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdocSet	cil/doc/api/Pretty.MakeSetPrinter.html	/^<pre><span class="keyword">val<\/span> <a name="VALdocSet"><\/a>docSet : <code class="type">?sep:<a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> (Set.elt -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> unit -> Set.t -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALdomTreeIter	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALdomTreeIter"><\/a>domTreeIter : <code class="type">(<a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> unit) -> <a href="Dominators.html#TYPEorder">order<\/a> -> <a href="Dominators.html#TYPEtree">tree<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALdominates	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALdominates"><\/a>dominates : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> option Inthash.t -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALdoubleType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdoubleType"><\/a>doubleType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALdprintf	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALdprintf"><\/a>dprintf : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">doc<\/a>, <a href="Pretty.html#TYPEdoc">doc<\/a>) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALdropAttribute	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdropAttribute"><\/a>dropAttribute : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALdropAttributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdropAttributes"><\/a>dropAttributes : <code class="type">string list -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALdummyFile	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdummyFile"><\/a>dummyFile : <code class="type"><a href="Cil.html#TYPEfile">file<\/a><\/code><\/pre><div class="info">$/;"	a
VALdummyFunDec	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdummyFunDec"><\/a>dummyFunDec : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a><\/code><\/pre><div class="info">$/;"	a
VALdummyInstr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdummyInstr"><\/a>dummyInstr : <code class="type"><a href="Cil.html#TYPEinstr">instr<\/a><\/code><\/pre><div class="info">$/;"	a
VALdummyStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdummyStmt"><\/a>dummyStmt : <code class="type"><a href="Cil.html#TYPEstmt">stmt<\/a><\/code><\/pre><div class="info">$/;"	a
VALdumpBlock	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdumpBlock"><\/a>dumpBlock : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> out_channel -> int -> <a href="Cil.html#TYPEblock">block<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALdumpFile	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdumpFile"><\/a>dumpFile : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> out_channel -> string -> <a href="Cil.html#TYPEfile">file<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALdumpGlobal	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdumpGlobal"><\/a>dumpGlobal : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> out_channel -> <a href="Cil.html#TYPEglobal">global<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALdumpInit	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdumpInit"><\/a>dumpInit : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> out_channel -> int -> <a href="Cil.html#TYPEinit">init<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALdumpStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALdumpStmt"><\/a>dumpStmt : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> out_channel -> int -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALempty	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALempty"><\/a>empty : <code class="type">'a <a href="Clist.html#TYPEclist">clist<\/a><\/code><\/pre><div class="info">$/;"	a
VALemptyFunction	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALemptyFunction"><\/a>emptyFunction : <code class="type">string -> <a href="Cil.html#TYPEfundec">fundec<\/a><\/code><\/pre><div class="info">$/;"	a
VALeprintf	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALeprintf"><\/a>eprintf : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALerror	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALerror"><\/a>error : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALerror	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALerror"><\/a>error : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALerrorLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALerrorLoc"><\/a>errorLoc : <code class="type"><a href="Cil.html#TYPElocation">location<\/a> -> ('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALexistsType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALexistsType"><\/a>existsType : <code class="type">(<a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEexistsAction">existsAction<\/a>) -> <a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALexpToAttrParam	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALexpToAttrParam"><\/a>expToAttrParam : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEattrparam">attrparam<\/a><\/code><\/pre><div class="info">$/;"	a
VALf_int32	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALf_int32"><\/a>f_int32 : <code class="type">unit -> int32 -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALd_int64"><\/a>d_int64 : <code class="type">int64 -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALf_int64"><\/a>f_int64 : <code class="type">unit -> int64 -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><pre><span class="keyword">module<\/span> <a href="Pretty.MakeMapPrinter.html">MakeMapPrinter<\/a>: <div class="sig_block"><code class="code">functor (<\/code><code class="code">Map<\/code><code class="code"> : <\/code><code class="code">sig<\/code><div class="sig_block"><pre><span class="keyword">type<\/span> <a name="TYPEkey"><\/a><code class="type"><\/code>key <\/pre>$/;"	a
VALfastMode	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALfastMode"><\/a>fastMode : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALfilterAttributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALfilterAttributes"><\/a>filterAttributes : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALfilterStmt	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALfilterStmt"><\/a>filterStmt : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALfilterStmt	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALfilterStmt"><\/a>filterStmt : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALfindNaturalLoops	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALfindNaturalLoops"><\/a>findNaturalLoops : <code class="type"><a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> option Inthash.t -> (<a href="Cil.html#TYPEstmt">Cil.stmt<\/a> * <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list) list<\/code><\/pre><div class="info">$/;"	a
VALfindOrCreateFunc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALfindOrCreateFunc"><\/a>findOrCreateFunc : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> string -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALfind_stmts	cil/doc/api/Dataflow.html	/^<pre><span class="keyword">module type<\/span> <a href="Dataflow.ForwardsTransfer.html">ForwardsTransfer<\/a> = <code class="code">sig<\/code> <a href="Dataflow.ForwardsTransfer.html">..<\/a> <code class="code">end<\/code><\/pre><pre><span class="keyword">module<\/span> <a href="Dataflow.ForwardsDataFlow.html">ForwardsDataFlow<\/a>: <div class="sig_block"><code class="code">functor (<\/code><code class="code">T<\/code><code class="code"> : <\/code><code class="type"><a href="Dataflow.ForwardsTransfer.html">ForwardsTransfer<\/a><\/code><code class="code">) -&gt; <\/code><code class="code">sig<\/code> <a href="Dataflow.ForwardsDataFlow.html">..<\/a> <code class="code">end<\/code><\/div><\/pre><pre><span class="keyword">module type<\/span> <a href="Dataflow.BackwardsTransfer.html">BackwardsTransfer<\/a> = <code class="code">sig<\/code> <a href="Dataflow.BackwardsTransfer.html">..<\/a> <code class="code">end<\/code><\/pre><pre><span class="keyword">module<\/span> <a href="Dataflow.BackwardsDataFlow.html">BackwardsDataFlow<\/a>: <div class="sig_block"><code class="code">functor (<\/code><code class="code">T<\/code><code class="code"> : <\/code><code class="type"><a href="Dataflow.BackwardsTransfer.html">BackwardsTransfer<\/a><\/code><code class="code">) -&gt; <\/code><code class="code">sig<\/code> <a href="Dataflow.BackwardsDataFlow.html">..<\/a> <code class="code">end<\/code><\/div><\/pre><pre><span class="keyword">val<\/span> <a name="VALfind_stmts"><\/a>find_stmts : <code class="type"><a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list * <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALflushOften	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALflushOften"><\/a>flushOften : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALfold	cil/doc/api/Pretty.MakeMapPrinter.html	/^<pre><span class="keyword">val<\/span> <a name="VALfold"><\/a>fold : <code class="type">(key -> 'a -> 'b -> 'b) -><br>       'a t -> 'b -> 'b<\/code><\/pre><\/div><code class="code">end<\/code><code class="code">) -&gt; <\/code><code class="code">sig<\/code> <a href="Pretty.MakeMapPrinter.html">..<\/a> <code class="code">end<\/code><\/div><\/pre>Format maps.<br>$/;"	a
VALfold	cil/doc/api/Pretty.MakeSetPrinter.html	/^<pre><span class="keyword">val<\/span> <a name="VALfold"><\/a>fold : <code class="type">(elt -> 'a -> 'a) -><br>       t -> 'a -> 'a<\/code><\/pre><\/div><code class="code">end<\/code><code class="code">) -&gt; <\/code><code class="code">sig<\/code> <a href="Pretty.MakeSetPrinter.html">..<\/a> <code class="code">end<\/code><\/div><\/pre>Format sets.<br>$/;"	a
VALfold	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALfold"><\/a>fold : <code class="type">(elt -> 'a -> 'a) -><br>       t -> 'a -> 'a<\/code><\/pre><\/div><code class="code">end<\/code><code class="code">) -&gt; <\/code><code class="code">sig<\/code> <a href="Pretty.MakeSetPrinter.html">..<\/a> <code class="code">end<\/code><\/div><\/pre><div class="info">$/;"	a
VALfold	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALfold"><\/a>fold : <code class="type">(key -> 'a -> 'b -> 'b) -><br>       'a t -> 'b -> 'b<\/code><\/pre><\/div><code class="code">end<\/code><code class="code">) -&gt; <\/code><code class="code">sig<\/code> <a href="Pretty.MakeMapPrinter.html">..<\/a> <code class="code">end<\/code><\/div><\/pre><div class="info">$/;"	a
VALfoldGlobals	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALfoldGlobals"><\/a>foldGlobals : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> ('a -> <a href="Cil.html#TYPEglobal">global<\/a> -> 'a) -> 'a -> 'a<\/code><\/pre><div class="info">$/;"	a
VALfoldLeftCompound	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALfoldLeftCompound"><\/a>foldLeftCompound : <code class="type">implicit:bool -><br>       doinit:(<a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a> -> 'a -> 'a) -><br>       ct:<a href="Cil.html#TYPEtyp">typ<\/a> -> initl:(<a href="Cil.html#TYPEoffset">offset<\/a> * <a href="Cil.html#TYPEinit">init<\/a>) list -> acc:'a -> 'a<\/code><\/pre><div class="info">$/;"	a
VALfold_left	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALfold_left"><\/a>fold_left : <code class="type">('a -> 'b -> 'a) -> 'a -> 'b <a href="Clist.html#TYPEclist">clist<\/a> -> 'a<\/code><\/pre><div class="info">$/;"	a
VALforgcc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALforgcc"><\/a>forgcc : <code class="type">string -> string<\/code><\/pre><div class="info">$/;"	a
VALfprint	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALfprint"><\/a>fprint : <code class="type">out_channel -> width:int -> <a href="Pretty.html#TYPEdoc">doc<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALfprintf	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALfprintf"><\/a>fprintf : <code class="type">out_channel -> ('a, unit, <a href="Pretty.html#TYPEdoc">doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALfromList	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALfromList"><\/a>fromList : <code class="type">'a list -> 'a <a href="Clist.html#TYPEclist">clist<\/a><\/code><\/pre><div class="info">$/;"	a
VALfuncExitData	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALfuncExitData"><\/a>funcExitData : <code class="type"><a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a><\/code><\/pre><div class="info">$/;"	a
VALgccBuiltins	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALgccBuiltins"><\/a>gccBuiltins : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEtyp">typ<\/a> list * bool) Hashtbl.t<\/code><\/pre><div class="info">$/;"	a
VALgetAlphaPrefix	cil/doc/api/Alpha.html	/^<pre><span class="keyword">val<\/span> <a name="VALgetAlphaPrefix"><\/a>getAlphaPrefix : <code class="type">lookupname:string -> string<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALundoAlphaChanges"><\/a>undoAlphaChanges : <code class="type">alphaTable:(string, 'a <a href="Alpha.html#TYPEalphaTableData">alphaTableData<\/a> ref) Hashtbl.t -><br>       undolist:'a <a href="Alpha.html#TYPEundoAlphaElement">undoAlphaElement<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
VALgetCompField	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALgetCompField"><\/a>getCompField : <code class="type"><a href="Cil.html#TYPEcompinfo">compinfo<\/a> -> string -> <a href="Cil.html#TYPEfieldinfo">fieldinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALgetGlobInit	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALgetGlobInit"><\/a>getGlobInit : <code class="type">?main_name:string -> <a href="Cil.html#TYPEfile">file<\/a> -> <a href="Cil.html#TYPEfundec">fundec<\/a><\/code><\/pre><div class="info">$/;"	a
VALgetIdom	cil/doc/api/Dominators.html	/^<pre><span class="keyword">val<\/span> <a name="VALgetIdom"><\/a>getIdom : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> option Inthash.t -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> -> <a href="Cil.html#TYPEstmt">Cil.stmt<\/a> option<\/code><\/pre><div class="info">$/;"	a
VALget_globalLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALget_globalLoc"><\/a>get_globalLoc : <code class="type"><a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Cil.html#TYPElocation">location<\/a><\/code><\/pre><div class="info">$/;"	a
VALget_instrLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALget_instrLoc"><\/a>get_instrLoc : <code class="type"><a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Cil.html#TYPElocation">location<\/a><\/code><\/pre><div class="info">$/;"	a
VALget_stmtLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALget_stmtLoc"><\/a>get_stmtLoc : <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind<\/a> -> <a href="Cil.html#TYPElocation">location<\/a><\/code><\/pre><div class="info">$/;"	a
VALgprintf	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALgprintf"><\/a>gprintf : <code class="type">(<a href="Pretty.html#TYPEdoc">doc<\/a> -> 'a) -> ('b, unit, <a href="Pretty.html#TYPEdoc">doc<\/a>, 'a) format4 -> 'b<\/code><\/pre><div class="info">$/;"	a
VALhadErrors	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALhadErrors"><\/a>hadErrors : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALhasAttribute	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALhasAttribute"><\/a>hasAttribute : <code class="type">string -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALhas_performance_counters	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALhas_performance_counters"><\/a>has_performance_counters : <code class="type">unit -> bool<\/code><\/pre><div class="info">$/;"	a
VALi64_to_int	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALi64_to_int"><\/a>i64_to_int : <code class="type">int64 -> int<\/code><\/pre><div class="info">$/;"	a
VALincrem	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALincrem"><\/a>increm : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> int -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALindent	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALindent"><\/a>indent : <code class="type">int -> <a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALinitCIL	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALinitCIL"><\/a>initCIL : <code class="type">unit -> unit<\/code><\/pre><div class="info">$/;"	a
VALinsert	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALinsert"><\/a>insert : <code class="type">unit -> <a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALinsertImplicitCasts	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALinsertImplicitCasts"><\/a>insertImplicitCasts : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALintPtrType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALintPtrType"><\/a>intPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALintType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALintType"><\/a>intType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALinteger	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALinteger"><\/a>integer : <code class="type">int -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALinvalidStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALinvalidStmt"><\/a>invalidStmt : <code class="type"><a href="Cil.html#TYPEstmt">stmt<\/a><\/code><\/pre><div class="info">$/;"	a
VALisArithmeticType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisArithmeticType"><\/a>isArithmeticType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisArrayType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisArrayType"><\/a>isArrayType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisCompleteType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisCompleteType"><\/a>isCompleteType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisConstant	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisConstant"><\/a>isConstant : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisFunctionType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisFunctionType"><\/a>isFunctionType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisInteger	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisInteger"><\/a>isInteger : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> int64 option<\/code><\/pre><div class="info">$/;"	a
VALisIntegralType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisIntegralType"><\/a>isIntegralType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisPointerType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisPointerType"><\/a>isPointerType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisSigned	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisSigned"><\/a>isSigned : <code class="type"><a href="Cil.html#TYPEikind">ikind<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisVoidPtrType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisVoidPtrType"><\/a>isVoidPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisVoidType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisVoidType"><\/a>isVoidType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALisZero	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALisZero"><\/a>isZero : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> bool<\/code><\/pre><div class="info">$/;"	a
VALiter	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALiter"><\/a>iter : <code class="type">('a -> unit) -> 'a <a href="Clist.html#TYPEclist">clist<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALiterGlobals	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALiterGlobals"><\/a>iterGlobals : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> (<a href="Cil.html#TYPEglobal">global<\/a> -> unit) -> unit<\/code><\/pre><div class="info">$/;"	a
VALkindOfSizeOf	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALkindOfSizeOf"><\/a>kindOfSizeOf : <code class="type"><a href="Cil.html#TYPEikind">ikind<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALkinteger	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALkinteger"><\/a>kinteger : <code class="type"><a href="Cil.html#TYPEikind">ikind<\/a> -> int -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALkinteger64	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALkinteger64"><\/a>kinteger64 : <code class="type"><a href="Cil.html#TYPEikind">ikind<\/a> -> int64 -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALlastTime	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALlastTime"><\/a>lastTime : <code class="type">float ref<\/code><\/pre><div class="info">$/;"	a
VALleftflush	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALleftflush"><\/a>leftflush : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALlenOfArray	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlenOfArray"><\/a>lenOfArray : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> option -> int<\/code><\/pre><div class="info">$/;"	a
VALlength	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALlength"><\/a>length : <code class="type">'a <a href="Clist.html#TYPEclist">clist<\/a> -> int<\/code><\/pre><div class="info">$/;"	a
VALline	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALline"><\/a>line : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALlineDirectiveStyle	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlineDirectiveStyle"><\/a>lineDirectiveStyle : <code class="type"><a href="Cil.html#TYPElineDirectiveStyle">lineDirectiveStyle<\/a> option ref<\/code><\/pre><div class="info">$/;"	a
VALlineLength	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlineLength"><\/a>lineLength : <code class="type">int ref<\/code><\/pre><div class="info">$/;"	a
VALlittle_endian	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlittle_endian"><\/a>little_endian : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALloadBinaryFile	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALloadBinaryFile"><\/a>loadBinaryFile : <code class="type">string -> <a href="Cil.html#TYPEfile">file<\/a><\/code><\/pre><div class="info">$/;"	a
VALlocUnknown	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlocUnknown"><\/a>locUnknown : <code class="type"><a href="Cil.html#TYPElocation">location<\/a><\/code><\/pre><div class="info">$/;"	a
VALlog	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALlog"><\/a>log : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALlogChannel	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALlogChannel"><\/a>logChannel : <code class="type">out_channel ref<\/code><\/pre><div class="info">$/;"	a
VALlogg	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALlogg"><\/a>logg : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALlongType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlongType"><\/a>longType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALlookupTime	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALlookupTime"><\/a>lookupTime : <code class="type">string -> float<\/code><\/pre><div class="info">$/;"	a
VALlowerConstants	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALlowerConstants"><\/a>lowerConstants : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALlowerEnumVisitor	cil/doc/api/Cillower.html	/^<pre><span class="keyword">val<\/span> <a name="VALlowerEnumVisitor"><\/a>lowerEnumVisitor : <code class="type"><a href="Cil.cilVisitor.html">Cil.cilVisitor<\/a><\/code><\/pre><div class="info">$/;"	a
VALmakeFormalVar	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmakeFormalVar"><\/a>makeFormalVar : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> ?where:string -> string -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALmakeGlobalVar	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmakeGlobalVar"><\/a>makeGlobalVar : <code class="type">string -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALmakeLocalVar	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmakeLocalVar"><\/a>makeLocalVar : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> ?insert:bool -> string -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALmakeTempVar	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmakeTempVar"><\/a>makeTempVar : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -><br>       ?name:string -><br>       ?descr:<a href="Pretty.html#TYPEdoc">Pretty.doc<\/a> -> ?descrpure:bool -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALmakeVarinfo	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmakeVarinfo"><\/a>makeVarinfo : <code class="type">bool -> string -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALmakeZeroInit	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmakeZeroInit"><\/a>makeZeroInit : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEinit">init<\/a><\/code><\/pre><div class="info">$/;"	a
VALmap	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALmap"><\/a>map : <code class="type">('a -> 'b) -> 'a <a href="Clist.html#TYPEclist">clist<\/a> -> 'b <a href="Clist.html#TYPEclist">clist<\/a><\/code><\/pre><div class="info">$/;"	a
VALmapGlobals	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmapGlobals"><\/a>mapGlobals : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> (<a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Cil.html#TYPEglobal">global<\/a>) -> unit<\/code><\/pre><div class="info">$/;"	a
VALmapNoCopy	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmapNoCopy"><\/a>mapNoCopy : <code class="type">('a -> 'a) -> 'a list -> 'a list<\/code><\/pre><div class="info">$/;"	a
VALmapNoCopyList	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmapNoCopyList"><\/a>mapNoCopyList : <code class="type">('a -> 'a list) -> 'a list -> 'a list<\/code><\/pre><div class="info">$/;"	a
VALmark	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALmark"><\/a>mark : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALmarkup	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALmarkup"><\/a>markup : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a> -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALmissingFieldName	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmissingFieldName"><\/a>missingFieldName : <code class="type">string<\/code><\/pre><div class="info">$/;"	a
VALmkAddrOf	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkAddrOf"><\/a>mkAddrOf : <code class="type"><a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkAddrOrStartOf	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkAddrOrStartOf"><\/a>mkAddrOrStartOf : <code class="type"><a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkBlock	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkBlock"><\/a>mkBlock : <code class="type"><a href="Cil.html#TYPEstmt">stmt<\/a> list -> <a href="Cil.html#TYPEblock">block<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkCast	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkCast"><\/a>mkCast : <code class="type">e:<a href="Cil.html#TYPEexp">exp<\/a> -> newt:<a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkCastT	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkCastT"><\/a>mkCastT : <code class="type">e:<a href="Cil.html#TYPEexp">exp<\/a> -> oldt:<a href="Cil.html#TYPEtyp">typ<\/a> -> newt:<a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkCompInfo	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkCompInfo"><\/a>mkCompInfo : <code class="type">bool -><br>       string -><br>       (<a href="Cil.html#TYPEcompinfo">compinfo<\/a> -><br>        (string * <a href="Cil.html#TYPEtyp">typ<\/a> * int option * <a href="Cil.html#TYPEattributes">attributes<\/a> * <a href="Cil.html#TYPElocation">location<\/a>) list) -><br>       <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEcompinfo">compinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkEmptyStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkEmptyStmt"><\/a>mkEmptyStmt : <code class="type">unit -> <a href="Cil.html#TYPEstmt">stmt<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkFor	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkFor"><\/a>mkFor : <code class="type">start:<a href="Cil.html#TYPEstmt">stmt<\/a> list -><br>       guard:<a href="Cil.html#TYPEexp">exp<\/a> -> next:<a href="Cil.html#TYPEstmt">stmt<\/a> list -> body:<a href="Cil.html#TYPEstmt">stmt<\/a> list -> <a href="Cil.html#TYPEstmt">stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALmkForIncr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkForIncr"><\/a>mkForIncr : <code class="type">iter:<a href="Cil.html#TYPEvarinfo">varinfo<\/a> -><br>       first:<a href="Cil.html#TYPEexp">exp<\/a> -><br>       stopat:<a href="Cil.html#TYPEexp">exp<\/a> -> incr:<a href="Cil.html#TYPEexp">exp<\/a> -> body:<a href="Cil.html#TYPEstmt">stmt<\/a> list -> <a href="Cil.html#TYPEstmt">stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALmkMem	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkMem"><\/a>mkMem : <code class="type">addr:<a href="Cil.html#TYPEexp">exp<\/a> -> off:<a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPElval">lval<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkStmt"><\/a>mkStmt : <code class="type"><a href="Cil.html#TYPEstmtkind">stmtkind<\/a> -> <a href="Cil.html#TYPEstmt">stmt<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkStmtOneInstr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkStmtOneInstr"><\/a>mkStmtOneInstr : <code class="type"><a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Cil.html#TYPEstmt">stmt<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkString	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkString"><\/a>mkString : <code class="type">string -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALmkWhile	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmkWhile"><\/a>mkWhile : <code class="type">guard:<a href="Cil.html#TYPEexp">exp<\/a> -> body:<a href="Cil.html#TYPEstmt">stmt<\/a> list -> <a href="Cil.html#TYPEstmt">stmt<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALmone	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmone"><\/a>mone : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALmsvcBuiltins	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmsvcBuiltins"><\/a>msvcBuiltins : <code class="type">(string, <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEtyp">typ<\/a> list * bool) Hashtbl.t<\/code><\/pre><div class="info">$/;"	a
VALmsvcMode	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALmsvcMode"><\/a>msvcMode : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALname	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALname"><\/a>name : <code class="type">string<\/code><\/pre><div class="info">$/;"	a
VALname	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALname"><\/a>name : <code class="type">string<\/code><\/pre><div class="info">$/;"	a
VALnewAlphaName	cil/doc/api/Alpha.html	/^<pre><span class="keyword">val<\/span> <a name="VALnewAlphaName"><\/a>newAlphaName : <code class="type">alphaTable:(string, 'a <a href="Alpha.html#TYPEalphaTableData">alphaTableData<\/a> ref) Hashtbl.t -><br>       undolist:'a <a href="Alpha.html#TYPEundoAlphaElement">undoAlphaElement<\/a> list ref option -><br>       lookupname:string -> data:'a -> string * 'a<\/code><\/pre><div class="info">$/;"	a
VALnewVID	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALnewVID"><\/a>newVID : <code class="type">unit -> int<\/code><\/pre><div class="info">$/;"	a
VALnew_sid	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALnew_sid"><\/a>new_sid : <code class="type">unit -> int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALprepareCFG"><\/a>prepareCFG : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALnewline	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALnewline"><\/a>newline : <code class="type">unit -> unit<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALnewHline"><\/a>newHline : <code class="type">unit -> unit<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALgetPosition"><\/a>getPosition : <code class="type">unit -> int * string * int<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALgetHPosition"><\/a>getHPosition : <code class="type">unit -> int * string<\/code><\/pre><div class="info">$/;"	a
VALnil	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALnil"><\/a>nil : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALnoMemoize	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALnoMemoize"><\/a>noMemoize : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALnodeList	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALnodeList"><\/a>nodeList : <code class="type"><a href="Cil.html#TYPEstmt">Cil.stmt<\/a> list ref<\/code><\/pre><div class="info">$/;"	a
VALnull	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALnull"><\/a>null : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALnum	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALnum"><\/a>num : <code class="type">int -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALnumNodes	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALnumNodes"><\/a>numNodes : <code class="type">int ref<\/code><\/pre><div class="info">$/;"	a
VALone	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALone"><\/a>one : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALparseInt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALparseInt"><\/a>parseInt : <code class="type">string -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALpartitionAttributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALpartitionAttributes"><\/a>partitionAttributes : <code class="type">default:<a href="Cil.html#TYPEattributeClass">attributeClass<\/a> -><br>       <a href="Cil.html#TYPEattributes">attributes<\/a> -><br>       <a href="Cil.html#TYPEattribute">attribute<\/a> list * <a href="Cil.html#TYPEattribute">attribute<\/a> list * <a href="Cil.html#TYPEattribute">attribute<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALpeepHole1	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALpeepHole1"><\/a>peepHole1 : <code class="type">(<a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Cil.html#TYPEinstr">instr<\/a> list option) -> <a href="Cil.html#TYPEstmt">stmt<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
VALpeepHole2	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALpeepHole2"><\/a>peepHole2 : <code class="type">(<a href="Cil.html#TYPEinstr">instr<\/a> * <a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Cil.html#TYPEinstr">instr<\/a> list option) -> <a href="Cil.html#TYPEstmt">stmt<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
VALplainCilPrinter	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALplainCilPrinter"><\/a>plainCilPrinter : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a><\/code><\/pre><pre><span class="keyword">class type<\/span> <a name="TYPEdescriptiveCilPrinter"><\/a><a href="Cil.descriptiveCilPrinter.html">descriptiveCilPrinter<\/a> = <code class="code">object<\/code> <a href="Cil.descriptiveCilPrinter.html">..<\/a> <code class="code">end<\/code><\/pre><pre><span class="keyword">class<\/span> <a name="TYPEdescriptiveCilPrinterClass"><\/a><a href="Cil.descriptiveCilPrinterClass.html">descriptiveCilPrinterClass<\/a> : <code class="type"><\/code><code class="type"><a href="Cil.descriptiveCilPrinter.html">descriptiveCilPrinter<\/a><\/code><\/pre><div class="info">$/;"	a
VALpopContext	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALpopContext"><\/a>popContext : <code class="type">unit -> unit<\/code><\/pre><div class="info">$/;"	a
VALpretty	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALpretty"><\/a>pretty : <code class="type">unit -> <a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALpretty	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALpretty"><\/a>pretty : <code class="type">unit -> <a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprint	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALprint"><\/a>print : <code class="type">out_channel -> string -> unit<\/code><\/pre><div class="info">$/;"	a
VALprintAttr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintAttr"><\/a>printAttr : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEattribute">attribute<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintAttrs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintAttrs"><\/a>printAttrs : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintBlock	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintBlock"><\/a>printBlock : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEblock">block<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintCfgChannel	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintCfgChannel"><\/a>printCfgChannel : <code class="type">out_channel -> <a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALprintCfgFilename	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintCfgFilename"><\/a>printCfgFilename : <code class="type">string -> <a href="Cil.html#TYPEfundec">Cil.fundec<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALprintCilAsIs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintCilAsIs"><\/a>printCilAsIs : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALprintDepth	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintDepth"><\/a>printDepth : <code class="type">int ref<\/code><\/pre><div class="info">$/;"	a
VALprintExp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintExp"><\/a>printExp : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintGlobal	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintGlobal"><\/a>printGlobal : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintIndent	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintIndent"><\/a>printIndent : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALprintInit	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintInit"><\/a>printInit : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintInstr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintInstr"><\/a>printInstr : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintLval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintLval"><\/a>printLval : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintStmt"><\/a>printStmt : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprintType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintType"><\/a>printType : <code class="type"><a href="Cil.cilPrinter.html">cilPrinter<\/a> -> unit -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALprint_CIL_Input	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALprint_CIL_Input"><\/a>print_CIL_Input : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALprintf	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALprintf"><\/a>printf : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALpushContext	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALpushContext"><\/a>pushContext : <code class="type">(unit -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> unit<\/code><\/pre><div class="info">$/;"	a
VALpushGlobal	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALpushGlobal"><\/a>pushGlobal : <code class="type"><a href="Cil.html#TYPEglobal">global<\/a> -><br>       types:<a href="Cil.html#TYPEglobal">global<\/a> list ref -><br>       variables:<a href="Cil.html#TYPEglobal">global<\/a> list ref -> unit<\/code><\/pre><div class="info">$/;"	a
VALreadingFromStdin	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALreadingFromStdin"><\/a>readingFromStdin : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALreal	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALreal"><\/a>real : <code class="type">float -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALregisterAlphaName	cil/doc/api/Alpha.html	/^<pre><span class="keyword">val<\/span> <a name="VALregisterAlphaName"><\/a>registerAlphaName : <code class="type">alphaTable:(string, 'a <a href="Alpha.html#TYPEalphaTableData">alphaTableData<\/a> ref) Hashtbl.t -><br>       undolist:'a <a href="Alpha.html#TYPEundoAlphaElement">undoAlphaElement<\/a> list ref option -><br>       lookupname:string -> data:'a -> unit<\/code><\/pre><div class="info">$/;"	a
VALremoveOffset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALremoveOffset"><\/a>removeOffset : <code class="type"><a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> * <a href="Cil.html#TYPEoffset">offset<\/a><\/code><\/pre><div class="info">$/;"	a
VALremoveOffsetLval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALremoveOffsetLval"><\/a>removeOffsetLval : <code class="type"><a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPElval">lval<\/a> * <a href="Cil.html#TYPEoffset">offset<\/a><\/code><\/pre><div class="info">$/;"	a
VALrepeattime	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALrepeattime"><\/a>repeattime : <code class="type">float -> string -> ('a -> 'b) -> 'a -> 'b<\/code><\/pre><div class="info">$/;"	a
VALreset	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALreset"><\/a>reset : <code class="type"><a href="Stats.html#TYPEtimerModeEnum">timerModeEnum<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALrev	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALrev"><\/a>rev : <code class="type">('a -> 'a) -> 'a <a href="Clist.html#TYPEclist">clist<\/a> -> 'a <a href="Clist.html#TYPEclist">clist<\/a><\/code><\/pre><div class="info">$/;"	a
VALs	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALs"><\/a>s : <code class="type">'a -> 'b<\/code><\/pre><div class="info">$/;"	a
VALsample_pentium_perfcount_10	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALsample_pentium_perfcount_10"><\/a>sample_pentium_perfcount_10 : <code class="type">unit -> int<\/code><\/pre><div class="info">$/;"	a
VALsample_pentium_perfcount_20	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALsample_pentium_perfcount_20"><\/a>sample_pentium_perfcount_20 : <code class="type">unit -> int<\/code><\/pre><div class="info">$/;"	a
VALsaveBinaryFile	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsaveBinaryFile"><\/a>saveBinaryFile : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> string -> unit<\/code><\/pre><div class="info">$/;"	a
VALsaveBinaryFileChannel	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsaveBinaryFileChannel"><\/a>saveBinaryFileChannel : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> out_channel -> unit<\/code><\/pre><div class="info">$/;"	a
VALseparateStorageModifiers	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALseparateStorageModifiers"><\/a>separateStorageModifiers : <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> list -> <a href="Cil.html#TYPEattribute">attribute<\/a> list * <a href="Cil.html#TYPEattribute">attribute<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALseq	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALseq"><\/a>seq : <code class="type">sep:<a href="Pretty.html#TYPEdoc">doc<\/a> -> doit:('a -> <a href="Pretty.html#TYPEdoc">doc<\/a>) -> elements:'a list -> <a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALsetFormals	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetFormals"><\/a>setFormals : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a> list -> unit<\/code><\/pre><div class="info">$/;"	a
VALsetFunctionType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetFunctionType"><\/a>setFunctionType : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALsetFunctionTypeMakeFormals	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetFunctionTypeMakeFormals"><\/a>setFunctionTypeMakeFormals : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALsetHLine	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetHLine"><\/a>setHLine : <code class="type">int -> unit<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALsetHFile"><\/a>setHFile : <code class="type">string -> unit<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALsetCurrentLine"><\/a>setCurrentLine : <code class="type">int -> unit<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALsetCurrentFile"><\/a>setCurrentFile : <code class="type">string -> unit<\/code><\/pre><br><code><span class="keyword">type<\/span> <a name="TYPElocation"><\/a><code class="type"><\/code>location = {<\/code><table class="typetable">$/;"	a
VALsetMaxId	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetMaxId"><\/a>setMaxId : <code class="type"><a href="Cil.html#TYPEfundec">fundec<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALsetTypeAttrs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetTypeAttrs"><\/a>setTypeAttrs : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALtypeAddAttributes"><\/a>typeAddAttributes : <code class="type"><a href="Cil.html#TYPEattribute">attribute<\/a> list -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALsetTypeSigAttrs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsetTypeSigAttrs"><\/a>setTypeSigAttrs : <code class="type"><a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEtypsig">typsig<\/a> -> <a href="Cil.html#TYPEtypsig">typsig<\/a><\/code><\/pre><div class="info">$/;"	a
VALshowContext	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALshowContext"><\/a>showContext : <code class="type">unit -> unit<\/code><\/pre><div class="info">$/;"	a
VALsingle	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALsingle"><\/a>single : <code class="type">'a -> 'a <a href="Clist.html#TYPEclist">clist<\/a><\/code><\/pre><div class="info">$/;"	a
VALsplitFunctionType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsplitFunctionType"><\/a>splitFunctionType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -><br>       <a href="Cil.html#TYPEtyp">typ<\/a> * (string * <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEattributes">attributes<\/a>) list option * bool *<br>       <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALsplitFunctionTypeVI	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALsplitFunctionTypeVI"><\/a>splitFunctionTypeVI : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -><br>       <a href="Cil.html#TYPEtyp">typ<\/a> * (string * <a href="Cil.html#TYPEtyp">typ<\/a> * <a href="Cil.html#TYPEattributes">attributes<\/a>) list option * bool *<br>       <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><br>$/;"	a
VALsprint	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALsprint"><\/a>sprint : <code class="type">width:int -> <a href="Pretty.html#TYPEdoc">doc<\/a> -> string<\/code><\/pre><div class="info">$/;"	a
VALstartParsing	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALstartParsing"><\/a>startParsing : <code class="type">?useBasename:bool -> string -> Lexing.lexbuf<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALstartParsingFromString"><\/a>startParsingFromString : <code class="type">?file:string -> ?line:int -> string -> Lexing.lexbuf<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALfinishParsing"><\/a>finishParsing : <code class="type">unit -> unit<\/code><\/pre><\/body><\/html>/;"	a
VALstart_id	cil/doc/api/Cfg.html	/^<pre><span class="keyword">val<\/span> <a name="VALstart_id"><\/a>start_id : <code class="type">int ref<\/code><\/pre><div class="info">$/;"	a
VALstartsWith	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALstartsWith"><\/a>startsWith : <code class="type">string -> string -> bool<\/code><\/pre><div class="info">$/;"	a
VALstmtStartData	cil/doc/api/Dataflow.BackwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALstmtStartData"><\/a>stmtStartData : <code class="type"><a href="Dataflow.BackwardsTransfer.html#TYPEt">t<\/a> Inthash.t<\/code><\/pre><div class="info">$/;"	a
VALstmtStartData	cil/doc/api/Dataflow.ForwardsTransfer.html	/^<pre><span class="keyword">val<\/span> <a name="VALstmtStartData"><\/a>stmtStartData : <code class="type"><a href="Dataflow.ForwardsTransfer.html#TYPEt">t<\/a> Inthash.t<\/code><\/pre><div class="info">$/;"	a
VALstripCasts	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALstripCasts"><\/a>stripCasts : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALtest	cil/doc/api/Formatcil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtest"><\/a>test : <code class="type">unit -> unit<\/code><\/pre><div class="info">$/;"	a
VALtime	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALtime"><\/a>time : <code class="type">string -> ('a -> 'b) -> 'a -> 'b<\/code><\/pre><div class="info">$/;"	a
VALtimethis	cil/doc/api/Stats.html	/^<pre><span class="keyword">val<\/span> <a name="VALtimethis"><\/a>timethis : <code class="type">('a -> 'b) -> 'a -> 'b<\/code><\/pre><\/body><\/html>/;"	a
VALtoList	cil/doc/api/Clist.html	/^<pre><span class="keyword">val<\/span> <a name="VALtoList"><\/a>toList : <code class="type">'a <a href="Clist.html#TYPEclist">clist<\/a> -> 'a list<\/code><\/pre><div class="info">$/;"	a
VALtruncateInteger64	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtruncateInteger64"><\/a>truncateInteger64 : <code class="type"><a href="Cil.html#TYPEikind">ikind<\/a> -> int64 -> int64 * bool<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALsizeOf"><\/a>sizeOf : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeAttrs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeAttrs"><\/a>typeAttrs : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEattribute">attribute<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALtypeOf	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeOf"><\/a>typeOf : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeOfLval	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeOfLval"><\/a>typeOfLval : <code class="type"><a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeOfSizeOf	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeOfSizeOf"><\/a>typeOfSizeOf : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALtypeOffset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeOffset"><\/a>typeOffset : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeRemoveAttributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeRemoveAttributes"><\/a>typeRemoveAttributes : <code class="type">string list -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeSig	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeSig"><\/a>typeSig : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtypsig">typsig<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeSigAttrs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeSigAttrs"><\/a>typeSigAttrs : <code class="type"><a href="Cil.html#TYPEtypsig">typsig<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a><\/code><\/pre><div class="info">$/;"	a
VALtypeSigWithAttrs	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALtypeSigWithAttrs"><\/a>typeSigWithAttrs : <code class="type">?ignoreSign:bool -><br>       (<a href="Cil.html#TYPEattributes">attributes<\/a> -> <a href="Cil.html#TYPEattributes">attributes<\/a>) -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtypsig">typsig<\/a><\/code><\/pre><div class="info">$/;"	a
VALuintPtrType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALuintPtrType"><\/a>uintPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALuintType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALuintType"><\/a>uintType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALulongType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALulongType"><\/a>ulongType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALunalign	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALunalign"><\/a>unalign : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALunderscore_name	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALunderscore_name"><\/a>underscore_name : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALunimp	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALunimp"><\/a>unimp : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALunimp	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALunimp"><\/a>unimp : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALuniqueVarNames	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALuniqueVarNames"><\/a>uniqueVarNames : <code class="type"><a href="Cil.html#TYPEfile">file<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALunmark	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALunmark"><\/a>unmark : <code class="type"><a href="Pretty.html#TYPEdoc">doc<\/a><\/code><\/pre><div class="info">$/;"	a
VALunrollType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALunrollType"><\/a>unrollType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALunrollTypeDeep	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALunrollTypeDeep"><\/a>unrollTypeDeep : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALupointType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALupointType"><\/a>upointType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALuseLogicalOperators	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALuseLogicalOperators"><\/a>useLogicalOperators : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALvar	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvar"><\/a>var : <code class="type"><a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Cil.html#TYPElval">lval<\/a><\/code><\/pre><div class="info">$/;"	a
VALverboseFlag	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALverboseFlag"><\/a>verboseFlag : <code class="type">bool ref<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALwarnFlag"><\/a>warnFlag : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALvisitCilAttributes	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilAttributes"><\/a>visitCilAttributes : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEattribute">attribute<\/a> list -> <a href="Cil.html#TYPEattribute">attribute<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALvisitCilBlock	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilBlock"><\/a>visitCilBlock : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEblock">block<\/a> -> <a href="Cil.html#TYPEblock">block<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilExpr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilExpr"><\/a>visitCilExpr : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a> -> <a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALvisitCilLval"><\/a>visitCilLval : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPElval">lval<\/a> -> <a href="Cil.html#TYPElval">lval<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilFile	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilFile"><\/a>visitCilFile : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEfile">file<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALvisitCilFileSameGlobals	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilFileSameGlobals"><\/a>visitCilFileSameGlobals : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEfile">file<\/a> -> unit<\/code><\/pre><div class="info">$/;"	a
VALvisitCilFunction	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilFunction"><\/a>visitCilFunction : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEfundec">fundec<\/a> -> <a href="Cil.html#TYPEfundec">fundec<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilGlobal	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilGlobal"><\/a>visitCilGlobal : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEglobal">global<\/a> -> <a href="Cil.html#TYPEglobal">global<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALvisitCilInit	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilInit"><\/a>visitCilInit : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEinit">init<\/a> -> <a href="Cil.html#TYPEinit">init<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilInitOffset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilInitOffset"><\/a>visitCilInitOffset : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilInstr	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilInstr"><\/a>visitCilInstr : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEinstr">instr<\/a> -> <a href="Cil.html#TYPEinstr">instr<\/a> list<\/code><\/pre><div class="info">$/;"	a
VALvisitCilOffset	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilOffset"><\/a>visitCilOffset : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a> -> <a href="Cil.html#TYPEoffset">offset<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilStmt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilStmt"><\/a>visitCilStmt : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEstmt">stmt<\/a> -> <a href="Cil.html#TYPEstmt">stmt<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilType"><\/a>visitCilType : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a> -> <a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALvisitCilVarDecl	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvisitCilVarDecl"><\/a>visitCilVarDecl : <code class="type"><a href="Cil.cilVisitor.html">cilVisitor<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a> -> <a href="Cil.html#TYPEvarinfo">varinfo<\/a><\/code><\/pre><div class="info">$/;"	a
VALvoidPtrType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvoidPtrType"><\/a>voidPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALvoidType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALvoidType"><\/a>voidType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALwarn	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarn"><\/a>warn : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarn	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarn"><\/a>warn : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarnContext	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarnContext"><\/a>warnContext : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarnContextOpt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarnContextOpt"><\/a>warnContextOpt : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarnLoc	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarnLoc"><\/a>warnLoc : <code class="type"><a href="Cil.html#TYPElocation">location<\/a> -> ('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarnOpt	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarnOpt"><\/a>warnOpt : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) format -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarnOpt	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarnOpt"><\/a>warnOpt : <code class="type">('a, unit, <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>, unit) format4 -> 'a<\/code><\/pre><div class="info">$/;"	a
VALwarnTruncate	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwarnTruncate"><\/a>warnTruncate : <code class="type">bool ref<\/code><\/pre><div class="info">$/;"	a
VALwcharKind	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwcharKind"><\/a>wcharKind : <code class="type"><a href="Cil.html#TYPEikind">ikind<\/a> ref<\/code><\/pre><div class="info">$/;"	a
VALwcharType	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALwcharType"><\/a>wcharType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a> ref<\/code><\/pre><pre><span class="keyword">val<\/span> <a name="VALcharConstPtrType"><\/a>charConstPtrType : <code class="type"><a href="Cil.html#TYPEtyp">typ<\/a><\/code><\/pre><div class="info">$/;"	a
VALwithContext	cil/doc/api/Errormsg.html	/^<pre><span class="keyword">val<\/span> <a name="VALwithContext"><\/a>withContext : <code class="type">(unit -> <a href="Pretty.html#TYPEdoc">Pretty.doc<\/a>) -> ('a -> 'b) -> 'a -> 'b<\/code><\/pre><div class="info">$/;"	a
VALwithPrintDepth	cil/doc/api/Pretty.html	/^<pre><span class="keyword">val<\/span> <a name="VALwithPrintDepth"><\/a>withPrintDepth : <code class="type">int -> (unit -> unit) -> unit<\/code><\/pre><div class="info">$/;"	a
VALzero	cil/doc/api/Cil.html	/^<pre><span class="keyword">val<\/span> <a name="VALzero"><\/a>zero : <code class="type"><a href="Cil.html#TYPEexp">exp<\/a><\/code><\/pre><div class="info">$/;"	a
VARIABLE	cil/src/frontc/cabs.ml	/^  | VARIABLE of string$/;"	C	type:expression
VERSION	cil/libstr/confdefs.h	3;"	d
VERSION	cil/src/machdep.c	53;"	d	file:
VERSION	cil/src/machdep.c	61;"	d	file:
VERSION_MAJOR	cil/src/machdep.c	54;"	d	file:
VERSION_MAJOR	cil/src/machdep.c	62;"	d	file:
VERSION_MINOR	cil/src/machdep.c	55;"	d	file:
VERSION_MINOR	cil/src/machdep.c	63;"	d	file:
VIRTUAL	cil/src/frontc/cabs.ml	/^    INLINE | VIRTUAL | EXPLICIT$/;"	C	type:funspec
VOID	cil/obj/x86_LINUX/cparser.ml	/^  | VOID of (Cabs.cabsloc)$/;"	C	type:token
VOID	cil/obj/x86_LINUX/cparser.mli	/^  | VOID of (Cabs.cabsloc)$/;"	C	type:token
VOID	cil/obj/x86_LINUX/formatparse.ml	/^  | VOID$/;"	C	type:token
VOID	cil/obj/x86_LINUX/formatparse.mli	/^  | VOID$/;"	C	type:token
VOLATILE	cil/obj/x86_LINUX/cparser.ml	/^  | VOLATILE of (Cabs.cabsloc)$/;"	C	type:token
VOLATILE	cil/obj/x86_LINUX/cparser.mli	/^  | VOLATILE of (Cabs.cabsloc)$/;"	C	type:token
VOLATILE	cil/obj/x86_LINUX/formatparse.ml	/^  | VOLATILE$/;"	C	type:token
VOLATILE	cil/obj/x86_LINUX/formatparse.mli	/^  | VOLATILE$/;"	C	type:token
Var	cil/src/cil.mli	/^  | Var        of varinfo    $/;"	C	type:lhost
WHILE	cil/obj/x86_LINUX/cparser.ml	/^  | WHILE of (Cabs.cabsloc)$/;"	C	type:token
WHILE	cil/obj/x86_LINUX/cparser.mli	/^  | WHILE of (Cabs.cabsloc)$/;"	C	type:token
WHILE	cil/obj/x86_LINUX/formatparse.ml	/^  | WHILE$/;"	C	type:token
WHILE	cil/obj/x86_LINUX/formatparse.mli	/^  | WHILE$/;"	C	type:token
WHILE	cil/src/frontc/cabs.ml	/^ | WHILE of expression * statement * cabsloc$/;"	C	type:statement
Wanted	cil/src/ext/astslicer.ml	/^type mark = Wanted | Unwanted | Unspecified$/;"	C	type:mark
Weird_bitwidth	cil/src/ext/ciltools.ml	/^exception Weird_bitwidth$/;"	e
WellFormed	cil/src/ext/pta/golf.ml	/^exception WellFormed   (* raised if types are not well-formed *)$/;"	e
WellFormed	cil/src/ext/pta/olf.ml	/^exception WellFormed   (* raised if types are not well-formed *)$/;"	e
Whitetrack	cil/src/frontc/whitetrack.ml	1;"	M
Whitetrack	cil/src/frontc/whitetrack.mli	1;"	M
WriteCoverageToFileOrDie	src/run_crest/concolic_search.cc	/^void Search::WriteCoverageToFileOrDie(const string& file) {$/;"	f	class:crest::Search
WriteInputToFileOrDie	src/run_crest/concolic_search.cc	/^void Search::WriteInputToFileOrDie(const string& file,$/;"	f	class:crest::Search
XOR	cil/src/frontc/cabs.ml	/^  | BAND | BOR | XOR | SHL | SHR$/;"	C	type:binary_operator
XOR_ASSIGN	cil/src/frontc/cabs.ml	/^  | BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN$/;"	C	type:binary_operator
YICES_DIR	src/Makefile	/^YICES_DIR=\/home\/awanish\/git\/yices\/$/;"	m
YicesSolver	src/base/yices_solver.h	/^class YicesSolver {$/;"	c	namespace:crest
_GNUCC	cil/Makefile	/^_GNUCC=1$/;"	m
_GNUCC	cil/config.mk	/^export _GNUCC=1$/;"	m
_GNU_SOURCE	cil/libstr/acconfig.h	1;"	d
_GNU_SOURCE	cil/libstr/confdefs.h	4;"	d
__CREST_ADD	include/crest.h	/^  __CREST_ADD       =  0,$/;"	e	enum:__anon12
__CREST_ADD	src/libcrest/crest.h	/^  __CREST_ADD       =  0,$/;"	e	enum:__anon10
__CREST_ADDR	include/crest.h	127;"	d
__CREST_ADDR	src/libcrest/crest.h	127;"	d
__CREST_AND	include/crest.h	/^  __CREST_AND       =  5,$/;"	e	enum:__anon12
__CREST_AND	src/libcrest/crest.h	/^  __CREST_AND       =  5,$/;"	e	enum:__anon10
__CREST_BOOL	include/crest.h	130;"	d
__CREST_BOOL	src/libcrest/crest.h	130;"	d
__CREST_BRANCH_ID	include/crest.h	124;"	d
__CREST_BRANCH_ID	src/libcrest/crest.h	124;"	d
__CREST_CONCRETE	include/crest.h	/^  __CREST_CONCRETE  = 18,$/;"	e	enum:__anon12
__CREST_CONCRETE	src/libcrest/crest.h	/^  __CREST_CONCRETE  = 18,$/;"	e	enum:__anon10
__CREST_DIVIDE	include/crest.h	/^  __CREST_DIVIDE    =  3,$/;"	e	enum:__anon12
__CREST_DIVIDE	src/libcrest/crest.h	/^  __CREST_DIVIDE    =  3,$/;"	e	enum:__anon10
__CREST_EQ	include/crest.h	/^  __CREST_EQ        = 12,$/;"	e	enum:__anon12
__CREST_EQ	src/libcrest/crest.h	/^  __CREST_EQ        = 12,$/;"	e	enum:__anon10
__CREST_FUNCTION_ID	include/crest.h	125;"	d
__CREST_FUNCTION_ID	src/libcrest/crest.h	125;"	d
__CREST_GEQ	include/crest.h	/^  __CREST_GEQ       = 17,$/;"	e	enum:__anon12
__CREST_GEQ	src/libcrest/crest.h	/^  __CREST_GEQ       = 17,$/;"	e	enum:__anon10
__CREST_GT	include/crest.h	/^  __CREST_GT        = 14,$/;"	e	enum:__anon12
__CREST_GT	src/libcrest/crest.h	/^  __CREST_GT        = 14,$/;"	e	enum:__anon10
__CREST_ID	include/crest.h	123;"	d
__CREST_ID	src/libcrest/crest.h	123;"	d
__CREST_LEQ	include/crest.h	/^  __CREST_LEQ       = 15,$/;"	e	enum:__anon12
__CREST_LEQ	src/libcrest/crest.h	/^  __CREST_LEQ       = 15,$/;"	e	enum:__anon10
__CREST_LT	include/crest.h	/^  __CREST_LT        = 16,$/;"	e	enum:__anon12
__CREST_LT	src/libcrest/crest.h	/^  __CREST_LT        = 16,$/;"	e	enum:__anon10
__CREST_L_AND	include/crest.h	/^  __CREST_L_AND     = 10,$/;"	e	enum:__anon12
__CREST_L_AND	src/libcrest/crest.h	/^  __CREST_L_AND     = 10,$/;"	e	enum:__anon10
__CREST_L_NOT	include/crest.h	/^  __CREST_L_NOT     = 21,$/;"	e	enum:__anon12
__CREST_L_NOT	src/libcrest/crest.h	/^  __CREST_L_NOT     = 21,$/;"	e	enum:__anon10
__CREST_L_OR	include/crest.h	/^  __CREST_L_OR      = 11,$/;"	e	enum:__anon12
__CREST_L_OR	src/libcrest/crest.h	/^  __CREST_L_OR      = 11,$/;"	e	enum:__anon10
__CREST_MOD	include/crest.h	/^  __CREST_MOD       =  4,$/;"	e	enum:__anon12
__CREST_MOD	src/libcrest/crest.h	/^  __CREST_MOD       =  4,$/;"	e	enum:__anon10
__CREST_MULTIPLY	include/crest.h	/^  __CREST_MULTIPLY  =  2,$/;"	e	enum:__anon12
__CREST_MULTIPLY	src/libcrest/crest.h	/^  __CREST_MULTIPLY  =  2,$/;"	e	enum:__anon10
__CREST_NEGATE	include/crest.h	/^  __CREST_NEGATE    = 19,$/;"	e	enum:__anon12
__CREST_NEGATE	src/libcrest/crest.h	/^  __CREST_NEGATE    = 19,$/;"	e	enum:__anon10
__CREST_NEQ	include/crest.h	/^  __CREST_NEQ       = 13,$/;"	e	enum:__anon12
__CREST_NEQ	src/libcrest/crest.h	/^  __CREST_NEQ       = 13,$/;"	e	enum:__anon10
__CREST_NOT	include/crest.h	/^  __CREST_NOT       = 20,$/;"	e	enum:__anon12
__CREST_NOT	src/libcrest/crest.h	/^  __CREST_NOT       = 20,$/;"	e	enum:__anon10
__CREST_OP	include/crest.h	129;"	d
__CREST_OP	src/libcrest/crest.h	129;"	d
__CREST_OR	include/crest.h	/^  __CREST_OR        =  6,$/;"	e	enum:__anon12
__CREST_OR	src/libcrest/crest.h	/^  __CREST_OR        =  6,$/;"	e	enum:__anon10
__CREST_SHIFT_L	include/crest.h	/^  __CREST_SHIFT_L   =  8,$/;"	e	enum:__anon12
__CREST_SHIFT_L	src/libcrest/crest.h	/^  __CREST_SHIFT_L   =  8,$/;"	e	enum:__anon10
__CREST_SHIFT_R	include/crest.h	/^  __CREST_SHIFT_R   =  9,$/;"	e	enum:__anon12
__CREST_SHIFT_R	src/libcrest/crest.h	/^  __CREST_SHIFT_R   =  9,$/;"	e	enum:__anon10
__CREST_SUBTRACT	include/crest.h	/^  __CREST_SUBTRACT  =  1,$/;"	e	enum:__anon12
__CREST_SUBTRACT	src/libcrest/crest.h	/^  __CREST_SUBTRACT  =  1,$/;"	e	enum:__anon10
__CREST_VALUE	include/crest.h	126;"	d
__CREST_VALUE	src/libcrest/crest.h	126;"	d
__CREST_XOR	include/crest.h	/^  __CREST_XOR       =  7,$/;"	e	enum:__anon12
__CREST_XOR	src/libcrest/crest.h	/^  __CREST_XOR       =  7,$/;"	e	enum:__anon10
__CrestApply1	src/libcrest/crest.cc	/^void __CrestApply1(__CREST_ID id, __CREST_OP op, __CREST_VALUE val) {$/;"	f
__CrestApply2	src/libcrest/crest.cc	/^void __CrestApply2(__CREST_ID id, __CREST_OP op, __CREST_VALUE val) {$/;"	f
__CrestAtExit	src/libcrest/crest.cc	/^void __CrestAtExit() {$/;"	f
__CrestBranch	src/libcrest/crest.cc	/^void __CrestBranch(__CREST_ID id, __CREST_BRANCH_ID bid, __CREST_BOOL b) {$/;"	f
__CrestCall	src/libcrest/crest.cc	/^void __CrestCall(__CREST_ID id, __CREST_FUNCTION_ID fid) {$/;"	f
__CrestChar	src/libcrest/crest.cc	/^void __CrestChar(char* x) {$/;"	f
__CrestCharTrace	src/libcrest/crest.cc	/^void __CrestCharTrace(char* x, char c, char* iprange) {$/;"	f
__CrestClearStack	src/libcrest/crest.cc	/^void __CrestClearStack(__CREST_ID id) {$/;"	f
__CrestHandleReturn	src/libcrest/crest.cc	/^void __CrestHandleReturn(__CREST_ID id, __CREST_VALUE val) {$/;"	f
__CrestInit	src/libcrest/crest.cc	/^void __CrestInit() {$/;"	f
__CrestInt	src/libcrest/crest.cc	/^void __CrestInt(int* x) {$/;"	f
__CrestIntTrace	src/libcrest/crest.cc	/^void __CrestIntTrace(int* x, int c, char* iprange) {$/;"	f
__CrestLoad	src/libcrest/crest.cc	/^void __CrestLoad(__CREST_ID id, __CREST_ADDR addr, __CREST_VALUE val) {$/;"	f
__CrestLogPC	src/libcrest/crest.cc	/^void __CrestLogPC(unsigned int x) {$/;"	f
__CrestLogSpec	src/libcrest/crest.cc	/^void __CrestLogSpec(char *op,int *op1,int *op2)$/;"	f
__CrestLogState	src/libcrest/crest.cc	/^void __CrestLogState(unsigned int x, int r_w, int line, char* varname, int val) {$/;"	f
__CrestLogState_1	src/libcrest/crest.cc	/^void __CrestLogState_1(unsigned int x) {$/;"	f
__CrestReturn	src/libcrest/crest.cc	/^void __CrestReturn(__CREST_ID id) {$/;"	f
__CrestShort	src/libcrest/crest.cc	/^void __CrestShort(short* x) {$/;"	f
__CrestShortTrace	src/libcrest/crest.cc	/^void __CrestShortTrace(short* x, short c, char* iprange) {$/;"	f
__CrestStore	src/libcrest/crest.cc	/^void __CrestStore(__CREST_ID id, __CREST_ADDR addr) {$/;"	f
__CrestUChar	src/libcrest/crest.cc	/^void __CrestUChar(unsigned char* x) {$/;"	f
__CrestUCharTrace	src/libcrest/crest.cc	/^void __CrestUCharTrace(unsigned char* x, unsigned char c, char* iprange) {$/;"	f
__CrestUInt	src/libcrest/crest.cc	/^void __CrestUInt(unsigned int* x) {$/;"	f
__CrestUIntTrace	src/libcrest/crest.cc	/^void __CrestUIntTrace(unsigned int* x, unsigned int c, char* iprange) {$/;"	f
__CrestUShort	src/libcrest/crest.cc	/^void __CrestUShort(unsigned short* x) {$/;"	f
__CrestUShortTrace	src/libcrest/crest.cc	/^void __CrestUShortTrace(unsigned short* x, unsigned short c, char* iprange) {$/;"	f
__CrestVarMap	src/libcrest/crest.cc	/^void __CrestVarMap(void* addr, char* name, int tp, char* trigger="true") {$/;"	f
__NULLTERM	cil/test/small1/init.c	/^    char   strbuff[20] __NULLTERM;$/;"	m	struct:__anon1::__anon2	file:
__NULLTERM	cil/test/small1/init.c	2;"	d	file:
__SIZED	cil/test/small1/init.c	/^  } f2[5] __SIZED;$/;"	m	struct:__anon1	typeref:struct:__anon1::__anon3	file:
__SIZED	cil/test/small1/init.c	3;"	d	file:
__SKIP	include/crest.h	172;"	d
__SKIP	src/libcrest/crest.h	172;"	d
__gnu_cxx	src/process_cfg/process_cfg.cc	/^namespace __gnu_cxx {$/;"	n	file:
__gxx_personality_v0	test/hack.c	/^int __gxx_personality_v0;$/;"	v
_thread_is_keyword	cil/Makefile	/^	echo "let __thread_is_keyword = true"  >>$@$/;"	m
a	cil/src/ext/sfi.ml	/^      let a = getArg n in $/;"	v
a	cil/src/ext/simplify.ml	/^      let a = mkAddrOrStartOf (Var v, NoOffset) in$/;"	v
a	cil/src/mergecil.ml	/^  let a,b,c,d,e =$/;"	v
a	cil/test/small1/init.c	/^    int a;$/;"	m	struct:__anon4::__anon5	file:
a	cil/test/small1/init.c	/^STR a[] = {$/;"	v
a	cil/test/small1/init.c	/^struct str1 { int a[3]; int b;};$/;"	m	struct:str1	file:
a'	cil/src/cil.ml	/^        let a' = dropAttributes [ "const" ] a in $/;"	v
a'	cil/src/ext/simplify.ml	/^      let a' = $/;"	v
a'	cil/src/ext/simplify.ml	/^      let a' = makeBasic setTemp a' in$/;"	v
a'	cil/src/ext/simplify.ml	/^      let a' = setTemp a' in$/;"	v
a1	cil/src/ext/sfi.ml	/^      let a1 = getArg n1 in$/;"	v
a1	cil/test/small1/init.c	/^    char * a1[10];$/;"	m	struct:__anon1::__anon2	file:
a1	cil/test/small1/init.c	/^int a1[10] = {$/;"	v
a2	cil/src/ext/sfi.ml	/^      let a2 = getArg n2 in $/;"	v
a2	cil/test/small1/init.c	/^    char * a2;$/;"	m	struct:__anon1::__anon2	file:
abscol'	cil/ocamlutil/pretty.ml	/^      let abscol' = scan abscol d in$/;"	v
absloc	cil/src/ext/pta/golf.ml	/^type absloc = label$/;"	t
absloc	cil/src/ext/pta/golf.mli	/^type absloc$/;"	t
absloc	cil/src/ext/pta/olf.mli	/^type absloc$/;"	t
absloc	cil/src/ext/pta/ptranal.mli	/^type absloc $/;"	t
absloc_e_points_to	cil/src/ext/pta/ptranal.mli	/^val absloc_e_points_to  : Cil.exp -> absloc list$/;"	v
absloc_e_transitive_points_to	cil/src/ext/pta/ptranal.mli	/^val absloc_e_transitive_points_to : Cil.exp -> absloc list $/;"	v
absloc_epoints_to	cil/src/ext/pta/golf.ml	/^let absloc_epoints_to = tauPointsTo$/;"	v
absloc_epoints_to	cil/src/ext/pta/golf.mli	/^val absloc_epoints_to : tau -> absloc list$/;"	v
absloc_epoints_to	cil/src/ext/pta/olf.mli	/^val absloc_epoints_to : tau -> absloc list$/;"	v
absloc_eq	cil/src/ext/pta/golf.ml	/^let absloc_eq (a1, a2) = smart_alias_query a1 a2$/;"	v
absloc_eq	cil/src/ext/pta/golf.mli	/^val absloc_eq : (absloc * absloc) -> bool$/;"	v
absloc_eq	cil/src/ext/pta/olf.mli	/^val absloc_eq : (absloc * absloc) -> bool$/;"	v
absloc_eq	cil/src/ext/pta/ptranal.ml	/^let absloc_eq a b = A.absloc_eq (a, b)$/;"	v
absloc_eq	cil/src/ext/pta/ptranal.mli	/^val absloc_eq : absloc -> absloc -> bool$/;"	v
absloc_lval_aliases	cil/src/ext/pta/ptranal.mli	/^val absloc_lval_aliases : Cil.lval -> absloc list$/;"	v
absloc_of_lval	cil/src/ext/pta/ptranal.mli	/^val absloc_of_lval : Cil.lval -> absloc$/;"	v
absloc_of_lvalue	cil/src/ext/pta/golf.ml	/^let absloc_of_lvalue (l : lvalue) : absloc = l.l$/;"	v
absloc_of_lvalue	cil/src/ext/pta/golf.mli	/^val absloc_of_lvalue : lvalue -> absloc$/;"	v
absloc_of_lvalue	cil/src/ext/pta/olf.mli	/^val absloc_of_lvalue : lvalue -> absloc $/;"	v
absloc_of_varinfo	cil/src/ext/pta/ptranal.mli	/^val absloc_of_varinfo : Cil.varinfo -> absloc$/;"	v
absloc_points_to	cil/src/ext/pta/golf.ml	/^let rec absloc_points_to (l : lvalue) : absloc list =$/;"	v
absloc_points_to	cil/src/ext/pta/golf.mli	/^val absloc_points_to : lvalue -> absloc list$/;"	v
absloc_points_to	cil/src/ext/pta/olf.mli	/^val absloc_points_to : lvalue -> absloc list$/;"	v
absloc_print_name	cil/src/ext/pta/golf.ml	/^let absloc_print_name = ref true$/;"	v
acc'	cil/ocamlutil/pretty.ml	/^      let acc' = Concat(CText (acc, String.sub str 0 r), Line) in$/;"	v
acc'	cil/src/cil.ml	/^  let acc' = List.fold_left doone' acc fl.globals in$/;"	v
accLive	cil/src/ext/bitmap.ml	/^let accLive lin lout def = $/;"	v
accLive	cil/src/ext/bitmap.mli	/^val  accLive : t -> t -> t -> bool$/;"	v
ach	cil/Makefile	/^	echo "type mach = {" >> $@ $/;"	m
aclobbers	cil/src/frontc/cabs.ml	/^      aclobbers: string list (* clobbered registers *)$/;"	r	type:asm_details
act	cil/src/ext/blockinggraph.ml	/^    let act = Queue.take worklist in$/;"	v
action	cil/src/ext/dataflow.mli	/^type 't action = $/;"	t
actuals	cil/src/ext/pta/golf.ml	/^  let actuals = ref al in$/;"	v
actuals	cil/src/ext/pta/olf.ml	/^  let actuals = ref al in$/;"	v
actuals	cil/src/ext/pta/steensgaard.ml	/^  let actuals = ref al in $/;"	v
add	cil/ocamlutil/inthash.ml	/^let add h key info =$/;"	v
add	cil/ocamlutil/inthash.mli	/^val add: 'a t -> int -> 'a -> unit$/;"	v
add	cil/ocamlutil/intmap.ml	/^let rec add x data = function$/;"	v
add	cil/ocamlutil/intmap.mli	/^val add: int -> 'a -> 'a t -> 'a t$/;"	v
add	cil/src/ext/pta/setp.ml	/^    let rec add x = function$/;"	v
addAttribute	cil/src/cil.ml	/^let rec addAttribute (Attr(an, _) as a: attribute) (al: attributes) = $/;"	v
addAttribute	cil/src/cil.mli	/^val addAttribute: attribute -> attributes -> attributes$/;"	v
addAttributes	cil/src/cil.ml	/^and addAttributes al0 (al: attributes) : attributes = $/;"	v
addAttributes	cil/src/cil.mli	/^val addAttributes: attribute list -> attributes -> attributes$/;"	v
addBlockingPointEdge	cil/src/ext/blockinggraph.ml	/^let addBlockingPointEdge (bptFrom: blockpt) (bptTo: blockpt) : unit =$/;"	v
addBranchPair	cil/src/ext/crestInstrument.ml	/^let addBranchPair bp = (curBranches := bp :: !curBranches)$/;"	v
addCall	cil/src/ext/stackoverflow.ml	/^let addCall (caller: string) (callee: string) = $/;"	v
addCheck	cil/src/ext/stackoverflow.ml	/^let addCheck (f: Cil.file) : unit = $/;"	v
addCheck	cil/src/ext/stackoverflow.mli	/^val addCheck: Cil.file -> unit$/;"	v
addCrestInitializer	cil/src/ext/crestInstrument.ml	/^let addCrestInitializer f =$/;"	v
addFunction	cil/src/ext/crestInstrument.ml	/^let addFunction () = (branches := (!funCount, !curBranches) :: !branches;$/;"	v
addGlobalToEnv	cil/src/frontc/cabs2cil.ml	/^let addGlobalToEnv (k: string) (d: envdata) : unit = $/;"	v
addNaturalLoop	cil/src/ext/dominators.ml	/^              let rec addNaturalLoop = function$/;"	v
addOffset	cil/src/cil.ml	/^let rec addOffset (toadd: offset) (off: offset) : offset =$/;"	v
addOffset	cil/src/cil.mli	/^val addOffset:     offset -> offset -> offset$/;"	v
addOffsetLval	cil/src/cil.mli	/^val addOffsetLval: offset -> lval -> lval $/;"	v
addTrailing	cil/src/cil.ml	/^and addTrailing nrbits roundto = $/;"	v
add_constraint	cil/src/ext/pta/steensgaard.ml	/^and add_constraint (c : su_constraint) =$/;"	v
add_constraint_int	cil/src/ext/pta/olf.ml	/^and add_constraint_int (c : tconstraint) (toplev : bool) =$/;"	v
add_dom_def_info	cil/src/ext/ssa.ml	/^let add_dom_def_info (f: cfgInfo): unit = $/;"	v
add_identifier	cil/obj/x86_LINUX/clexer.mli	/^val add_identifier: string -> unit (* Add a new string as a variable name  *)$/;"	v
add_identifier	cil/src/frontc/clexer.mli	/^val add_identifier: string -> unit (* Add a new string as a variable name  *)$/;"	v
add_phi_functions_info	cil/src/ext/ssa.ml	/^let add_phi_functions_info (flowgraph: cfgInfo) : unit = $/;"	v
add_ssa_info	cil/src/ext/ssa.mli	/^val add_ssa_info: cfgInfo -> unit$/;"	v
add_type	cil/obj/x86_LINUX/clexer.ml	/^let add_type name =$/;"	v
add_type	cil/obj/x86_LINUX/clexer.mli	/^val add_type: string -> unit (* Add a new string as a type name  *)$/;"	v
add_type	cil/src/frontc/clexer.mli	/^val add_type: string -> unit (* Add a new string as a type name  *)$/;"	v
additiveLevel	cil/src/cil.ml	/^let additiveLevel = 60$/;"	v
addrOfLevel	cil/src/cil.ml	/^let addrOfLevel = 30$/;"	v
addrOfOrGlobalFinderClass	cil/src/ext/availexpslv.ml	/^class addrOfOrGlobalFinderClass br = object(self)$/;"	c
addrType	cil/src/ext/crestInstrument.ml	/^let addrType = TInt (IULong, [])$/;"	v
addr_t	src/base/basic_types.h	/^typedef unsigned long int addr_t;$/;"	t	namespace:crest
address	cil/src/ext/pta/golf.mli	/^val address : lvalue -> tau$/;"	v
address	cil/src/ext/pta/olf.ml	/^let address (lv  : lvalue) : tau =$/;"	v
address	cil/src/ext/pta/olf.mli	/^val address : lvalue -> tau$/;"	v
address	cil/src/ext/pta/steensgaard.mli	/^val address : lvalue -> tau$/;"	v
addressOf	cil/src/ext/crestInstrument.ml	/^let addressOf : lval -> exp = mkAddrOrStartOf$/;"	v
adjEnd	cil/ocamlutil/errormsg.ml	/^  let adjEnd = $/;"	v
adjStart	cil/ocamlutil/errormsg.ml	/^  let adjStart = $/;"	v
adj_list_t	src/process_cfg/process_cfg.cc	/^typedef vector< pair<int,size_t> > adj_list_t;$/;"	t	file:
aeVisitorClass	cil/src/ext/availexps.ml	/^class aeVisitorClass = object(self)$/;"	c
after	cil/src/ext/dataflow.ml	/^          let after: T.t = $/;"	v
afunc	cil/test/small1/init.c	/^int afunc(int a) {$/;"	f
ainputs	cil/src/frontc/cabs.ml	/^      ainputs: (string option * string * expression) list; (* optional name, constraints and expressions for inputs *)$/;"	r	type:asm_details
al	cil/obj/x86_LINUX/formatparse.ml	/^                          let al = (fst _2) args in$/;"	v
al	cil/obj/x86_LINUX/formatparse.ml	/^                         let al = (fst _2) args in$/;"	v
al	cil/obj/x86_LINUX/formatparse.ml	/^                        let al = (fst _2) args in$/;"	v
al'	cil/obj/x86_LINUX/cparser.ml	/^                                      let al' = al @ _4 in$/;"	v
al'	cil/src/ext/partial.ml	/^                           let al' = List.map (S.evaluate !state) al in$/;"	v
al'	cil/src/frontc/cabsvisit.ml	/^      let al' = mapNoCopy (childrenAttribute vis) al in$/;"	v
algo	cil/ocamlutil/pretty.ml	/^let  algo = George$/;"	v
algo	cil/ocamlutil/pretty.ml	/^type algo = George | Aman | Gap$/;"	t
aliasFinderClass	cil/src/ext/predabst.ml	/^    class aliasFinderClass ae br = object(self)$/;"	c
alias_frequency	cil/src/ext/pta/golf.ml	/^let alias_frequency (lvl : (lvalue * bool) list) : int * int =$/;"	v
alias_frequency	cil/src/ext/pta/golf.mli	/^val alias_frequency : (lvalue * bool) list -> int * int$/;"	v
alias_query	cil/src/ext/pta/golf.ml	/^let alias_query (b : bool) (lvl : lvalue list) : int * int =$/;"	v
alias_query	cil/src/ext/pta/golf.mli	/^val alias_query : bool -> lvalue list -> int * int$/;"	v
alias_query	cil/src/ext/pta/steensgaard.ml	/^let alias_query (a_progress : bool) (lv : lvalue list) : int * int = $/;"	v
alias_query	cil/src/ext/pta/steensgaard.mli	/^val alias_query : bool -> lvalue list -> int * int$/;"	v
aliases	cil/src/ext/pta/steensgaard.ml	/^  let aliases = constset_to_string (C.elements ((U.deref l).aliases))$/;"	v
align	cil/ocamlutil/pretty.ml	/^let align         = Align$/;"	v
align	cil/ocamlutil/pretty.mli	/^val align: doc$/;"	v	function:++
alignDepth	cil/ocamlutil/pretty.ml	/^let alignDepth = ref 0$/;"	v
alignof_double	cil/obj/x86_LINUX/machdep.ml	/^  alignof_double: int;    (* Alignment of "double" *)$/;"	r	type:mach
alignof_enum	cil/obj/x86_LINUX/machdep.ml	/^  alignof_enum: int;      (* Alignment of enum types *)$/;"	r	type:mach
alignof_float	cil/obj/x86_LINUX/machdep.ml	/^  alignof_float: int;     (* Alignment of "float" *)$/;"	r	type:mach
alignof_fun	cil/obj/x86_LINUX/machdep.ml	/^  alignof_fun: int;       (* Alignment of function *)$/;"	r	type:mach
alignof_int	cil/obj/x86_LINUX/machdep.ml	/^  alignof_int: int;       (* Alignment of "int" *)$/;"	r	type:mach
alignof_long	cil/obj/x86_LINUX/machdep.ml	/^  alignof_long: int;      (* Alignment of "long" *)$/;"	r	type:mach
alignof_longdouble	cil/obj/x86_LINUX/machdep.ml	/^  alignof_longdouble: int;  (* Alignment of "long double" *)$/;"	r	type:mach
alignof_longlong	cil/obj/x86_LINUX/machdep.ml	/^  alignof_longlong: int;  (* Alignment of "long long" *)$/;"	r	type:mach
alignof_ptr	cil/obj/x86_LINUX/machdep.ml	/^  alignof_ptr: int;       (* Alignment of pointers *)$/;"	r	type:mach
alignof_short	cil/obj/x86_LINUX/machdep.ml	/^  alignof_short: int;     (* Alignment of "short" *)$/;"	r	type:mach
alignof_str	cil/obj/x86_LINUX/machdep.ml	/^  alignof_str: int;       (* Alignment of strings *)$/;"	r	type:mach
allBranches	cil/src/ext/crestInstrument.ml	/^      let allBranches = (!funCount, !curBranches) :: !branches in$/;"	v
allScc	cil/src/ext/ssa.ml	/^  let allScc = ref([]) in$/;"	v
all_mli	cil/Makefile	/^all_mli := $(filter %.mli, $(DISTRIB_OCAMLUTIL) $(DISTRIB_SRC) $(DISTRIB_SRC_FRONTC) $(DISTRIB_SRC_EXT) $(DISTRIB_SRC_EXT_PTA))$/;"	m
all_sccArray	cil/src/ext/ssa.ml	/^  let all_sccArray = Array.of_list allScc in$/;"	v
all_stmts	cil/src/ext/dataflow.ml	/^let all_stmts = ref []$/;"	v
alloc_stmt	cil/src/ext/heapify.ml	/^        let alloc_stmt = mkStmt (* allocate the big struct on the heap *)$/;"	v
allocators	cil/src/ext/sfi.ml	/^let allocators: (string, (dataLocation * dataLocation)) H.t = H.create 13$/;"	v
allowDuplication	cil/src/frontc/cabs2cil.mli	/^val allowDuplication: bool ref$/;"	v
alpha	cil/src/rmtmps.ml	/^  let alpha = "\\\\(___[0-9]+\\\\)?" in$/;"	v
alphaTable	cil/src/frontc/cabs2cil.ml	/^let alphaTable : (string, location AL.alphaTableData ref) H.t = H.create 307 $/;"	v
alphaTableData	cil/ocamlutil/alpha.mli	/^type 'a alphaTableData$/;"	t
alreadyDefined	cil/src/frontc/cabs2cil.ml	/^let alreadyDefined: (string, location) H.t = H.create 117$/;"	v
alv	cil/src/ext/pta/ptranal.ml	/^          let alv =$/;"	v
amputateFunctionBodies	cil/src/rmtmps.ml	/^let amputateFunctionBodies keptGlobals file =$/;"	v
an'	cil/src/cil.ml	/^        let an' = if !msvcMode then "__" ^ an else "__" ^ an ^ "__" in$/;"	v
analyze_expr_as_lval	cil/src/ext/pta/ptranal.ml	/^and analyze_expr_as_lval (e : exp) : A.lvalue =$/;"	v
analyze_file	cil/src/ext/pta/ptranal.ml	/^let analyze_file (f : file) : unit =$/;"	v
analyze_file	cil/src/ext/pta/ptranal.mli	/^val analyze_file : Cil.file -> unit$/;"	v
analyze_function	cil/src/ext/pta/ptranal.ml	/^let analyze_function (f : fundec ) : unit =$/;"	v
analyze_global	cil/src/ext/pta/ptranal.ml	/^let analyze_global (g : global ) : unit =$/;"	v
analyze_init	cil/src/ext/pta/ptranal.ml	/^let rec analyze_init (i : init ) : A.tau =$/;"	v
analyze_lval	cil/src/ext/pta/ptranal.ml	/^let rec analyze_lval (lv : lval ) : A.lvalue =$/;"	v
analyze_mono	cil/src/ext/pta/golf.mli	/^val analyze_mono : bool ref$/;"	v
analyze_mono	cil/src/ext/pta/olf.mli	/^val analyze_mono : bool ref$/;"	v
analyze_mono	cil/src/ext/pta/ptranal.mli	/^val analyze_mono : bool ref$/;"	v
analyze_mono	cil/src/ext/pta/steensgaard.mli	/^val analyze_mono : bool ref$/;"	v
analyze_stmt	cil/src/ext/pta/ptranal.ml	/^let rec analyze_stmt (s : stmt ) : unit =$/;"	v
analyze_var_decl	cil/src/ext/pta/ptranal.ml	/^let analyze_var_decl (v : varinfo ) : A.lvalue =$/;"	v
annotate	cil/src/ext/astslicer.ml	/^let annotate (f : Cil.file) ei = begin$/;"	v
anticompare	cil/ocamlutil/util.mli	/^val anticompare: 'a -> 'a -> int$/;"	v
aoutputs	cil/src/frontc/cabs.ml	/^    { aoutputs: (string option * string * expression) list; (* optional name, constraints and expressions for outputs *)$/;"	r	type:asm_details
append	cil/ocamlutil/clist.ml	/^let append l1 l2 =$/;"	v
append	cil/ocamlutil/clist.mli	/^val append: 'a clist -> 'a clist -> 'a clist $/;"	v
apply	cil/src/ext/pta/golf.mli	/^val apply : tau -> tau list -> (tau * int)$/;"	v
apply	cil/src/ext/pta/olf.mli	/^val apply : tau -> tau list -> (tau * int)$/;"	v
apply	cil/src/ext/pta/steensgaard.mli	/^val apply : tau -> tau list -> tau$/;"	v
applyCil	cil/lib/Cilly.pm	/^sub applyCil {$/;"	s
applyCilAndCompile	cil/lib/Cilly.pm	/^sub applyCilAndCompile {$/;"	s
applyOnePatch	cil/bin/patcher	/^sub applyOnePatch {$/;"	s
applyPatch	cil/src/frontc/patch.ml	/^let rec applyPatch (patchFile : file) (srcFile : file) : file =$/;"	v
applyPatch	cil/src/frontc/patch.mli	/^val applyPatch : Cabs.file -> Cabs.file -> Cabs.file$/;"	v
applyPatches	cil/bin/patcher	/^sub applyPatches {$/;"	s
apply_undefined	cil/src/ext/pta/golf.ml	/^let apply_undefined (_ : tau list) = (fresh_var true, 0)$/;"	v
apply_undefined	cil/src/ext/pta/golf.mli	/^val apply_undefined : tau list -> (tau * int) (* only for compatability with Olf *)$/;"	v
apply_undefined	cil/src/ext/pta/olf.ml	/^let apply_undefined (al : tau list) : (tau * int) =$/;"	v
apply_undefined	cil/src/ext/pta/olf.mli	/^val apply_undefined : tau list -> (tau * int)$/;"	v
arArguments	cil/lib/Cilly.pm	/^sub arArguments {$/;"	s
argl	cil/src/mergecil.ml	/^            let argl = argsToList args in$/;"	v
args	cil/obj/x86_LINUX/cparser.ml	/^  let args = List.map findOneName names in$/;"	v
args	cil/src/frontc/frontc.mli	/^val args: (string * Arg.spec * string) list$/;"	v
args'	cil/src/cil.ml	/^      let args' = mapNoCopy fExp args in$/;"	v
args'	cil/src/cil.ml	/^      let f' = fExp f in let args' = mapNoCopy fExp args in$/;"	v
argsToList	cil/src/cil.mli	/^val argsToList: (string * typ * attributes) list option $/;"	v
array_to_pointer	cil/src/ext/simplemem.ml	/^let rec array_to_pointer tau = $/;"	v
arrfun	cil/test/small1/func.c	/^intfun arrfun[5];$/;"	v
arrowLevel	cil/src/cil.ml	/^let arrowLevel = 20$/;"	v
as_func_failure	cil/configure	/^as_func_failure () {$/;"	f
as_func_ret_failure	cil/configure	/^as_func_ret_failure () {$/;"	f
as_func_ret_success	cil/configure	/^as_func_ret_success () {$/;"	f
as_func_success	cil/configure	/^as_func_success () {$/;"	f
asm_details	cil/src/frontc/cabs.ml	/^and asm_details =$/;"	t
assemble	cil/lib/Cilly.pm	/^sub assemble {$/;"	s
assembleOutputFile	cil/lib/Cilly.pm	/^sub assembleOutputFile {$/;"	s
assembly	cil/src/ext/partial.ml	/^  let assembly r i = r (* no-op in Necula-world *)$/;"	v
assertEmptyQueue	cil/src/cil.ml	/^let assertEmptyQueue vis =$/;"	v
assign	cil/src/ext/bitmap.ml	/^let assign b1 b2 = $/;"	v
assign	cil/src/ext/bitmap.mli	/^val  assign : t -> t -> unit$/;"	v
assign	cil/src/ext/partial.ml	/^  let assign r l e =$/;"	v
assign	cil/src/ext/pta/golf.mli	/^val assign : lvalue -> tau -> unit$/;"	v
assign	cil/src/ext/pta/olf.ml	/^let assign (lv : lvalue) (t : tau) : unit =$/;"	v
assign	cil/src/ext/pta/olf.mli	/^val assign : lvalue -> tau -> unit$/;"	v
assign	cil/src/ext/pta/steensgaard.ml	/^let assign (lv : lvalue) (t : tau) : unit = $/;"	v
assign	cil/src/ext/pta/steensgaard.mli	/^val assign : lvalue -> tau -> unit$/;"	v
assign_ret	cil/src/ext/pta/golf.mli	/^val assign_ret : int -> lvalue -> tau -> unit$/;"	v
assign_ret	cil/src/ext/pta/olf.ml	/^let assign_ret (i : int) (lv : lvalue) (t : tau) : unit =$/;"	v
assign_ret	cil/src/ext/pta/olf.mli	/^val assign_ret : int -> lvalue -> tau -> unit$/;"	v
assign_undefined	cil/src/ext/pta/golf.ml	/^let assign_undefined (_ : lvalue) = ()$/;"	v
assign_undefined	cil/src/ext/pta/golf.mli	/^val assign_undefined : lvalue -> unit (* only for compatability with Olf *)$/;"	v
assign_undefined	cil/src/ext/pta/olf.ml	/^let assign_undefined (lv : lvalue) : unit =$/;"	v
assign_undefined	cil/src/ext/pta/olf.mli	/^val assign_undefined : lvalue -> unit$/;"	v
assignment_list	cil/src/ext/simplemem.ml	/^let assignment_list = ref []$/;"	v
assoc_list_mem	cil/src/ext/pta/olf.ml	/^let rec assoc_list_mem (e : tau) (l : association list) =$/;"	v
assoc_list_mem	cil/src/ext/pta/steensgaard.ml	/^let rec assoc_list_mem (e : tau) (l : association list) =$/;"	v
assume	cil/src/ext/partial.ml	/^  let assume r e = r (* no-op in Necula-world *)$/;"	v
attrVisitor	cil/src/cil.ml	/^  let attrVisitor = new typeSigVisitor typeSig in$/;"	v
attribute	cil/src/cil.mli	/^and attribute = Attr of string * attrparam list$/;"	t
attribute	cil/src/frontc/cabs.ml	/^and attribute = string * expression list$/;"	t
attributeClass	cil/src/cil.mli	/^type attributeClass = $/;"	t
attributeHash	cil/src/cil.mli	/^val attributeHash: (string, attributeClass) Hashtbl.t$/;"	v
attributes	cil/src/cil.mli	/^and attributes = attribute list$/;"	t
attrparam	cil/src/cil.mli	/^and attrparam = $/;"	t
attrsForCombinedArg	cil/src/frontc/cabs2cil.mli	/^val attrsForCombinedArg: ((string, string) Hashtbl.t ->$/;"	v
auto_printer	cil/ocamlutil/pretty.ml	/^let auto_printer (typ: string) = $/;"	v
auto_printer	cil/ocamlutil/pretty.mli	/^val auto_printer: string -> 'b$/;"	v
average	cil/test/small1/vararg1.c	/^int average( int first, ... )$/;"	f
b	cil/obj/x86_LINUX/cparser.ml	/^                                         (let b, d = _3 in TYPE_ALIGNOF (b, d))$/;"	v
b	cil/obj/x86_LINUX/cparser.ml	/^                           (let b, d = _3 in TYPE_SIZEOF (b, d))$/;"	v
b	cil/obj/x86_LINUX/cparser.ml	/^                        ( let b, _, _ = _2 in$/;"	v
b	cil/obj/x86_LINUX/cparser.ml	/^                        ( let b, d = _5 in$/;"	v
b	cil/obj/x86_LINUX/cparser.ml	/^          (let b, d = _3 in TYPE_ALIGNOF (b, d), _1)$/;"	v
b	cil/obj/x86_LINUX/cparser.ml	/^          (let b, d = _3 in TYPE_SIZEOF (b, d), _1)$/;"	v
b	cil/test/small1/init.c	/^    int *b;$/;"	m	struct:__anon4::__anon5	file:
b	cil/test/small1/init.c	/^struct str1 { int a[3]; int b;};$/;"	m	struct:str1	file:
b'	cil/src/cil.ml	/^        let b' = fBlock b in $/;"	v
b'	cil/src/cil.ml	/^        let b' = fBlock b in$/;"	v
b1	cil/obj/x86_LINUX/cparser.ml	/^                        ( let b1,d1 = _3 in$/;"	v
b2	cil/obj/x86_LINUX/cparser.ml	/^                          let b2,d2 = _5 in$/;"	v
backEdges	cil/src/ext/ssa.ml	/^  let backEdges = ref ([]) in$/;"	v
backEdges	cil/src/ext/ssa.mli	/^    backEdges: (int*int) list;$/;"	r	type:oneSccInfo
backwards_tabulate	cil/src/ext/pta/golf.ml	/^let backwards_tabulate (l : label) : unit =$/;"	v
bal	cil/ocamlutil/intmap.ml	/^let bal l x d r =$/;"	v
banana	test/structure_return.c	/^struct banana {$/;"	s	file:
bar	test/structure_test.c	/^  struct bar bar;$/;"	m	struct:foo	typeref:struct:foo::bar	file:
bar	test/structure_test.c	/^struct bar {$/;"	s	file:
base	cil/src/ext/pta/steensgaard.ml	/^	  let base = get_bounds is_pos l in$/;"	v
basenoext	cil/src/cil.ml	/^        let basenoext = $/;"	v
baset	cil/obj/x86_LINUX/formatparse.ml	/^                   let baset = $/;"	v
baset	cil/obj/x86_LINUX/formatparse.ml	/^                 let baset = $/;"	v
basis	cil/lib/OutputFile.pm	/^sub basis {$/;"	s
battrs	cil/src/cil.mli	/^   { mutable battrs: attributes;      (** Attributes for the block *)$/;"	r	type:block
battrs	cil/src/frontc/cabs.ml	/^      battrs: attribute list;$/;"	r	type:block
bidType	cil/src/ext/crestInstrument.ml	/^let bidType  = intType$/;"	v
binaryExists	cil/configure	/^binaryExists() {$/;"	f
binary_op_t	src/base/basic_types.h	/^enum binary_op_t { ADD, SUBTRACT, MULTIPLY, CONCRETE };$/;"	g	namespace:crest::ops
binary_operator	cil/src/frontc/cabs.ml	/^and binary_operator =$/;"	t
binding	cil/src/frontc/patch.ml	/^type binding =$/;"	t
binop	cil/src/cil.mli	/^and binop =$/;"	t
bitmap	cil/src/ext/bitmap.ml	/^           mutable bitmap   : int array }$/;"	r	type:t
bits_offset	cil/src/ext/sfi.ml	/^    let bits_offset, bits_width = $/;"	v
bitwiseLevel	cil/src/cil.ml	/^let bitwiseLevel = 75$/;"	v
bl2	cil/src/ext/predabst.ml	/^	try let bl2 = IH.find h2 pid in$/;"	v
blabels	cil/src/frontc/cabs.ml	/^    { blabels: string list;$/;"	r	type:block
blit	cil/ocamlutil/longarray.mli	/^val blit : 'a t -> int -> 'a t -> int -> int -> unit$/;"	v
block	cil/src/cil.mli	/^and block = $/;"	t
block	cil/src/frontc/cabs.ml	/^and block = $/;"	t
block_labels	cil/src/ext/partial.ml	/^                let block_labels = visit_block gather_labels LabelSet.empty b$/;"	v
blocks	cil/src/ext/ssa.mli	/^    blocks: cfgBlock array; (** Dominating blocks must come first *)$/;"	r	type:cfgInfo
body	cil/src/cil.ml	/^        let body = (self#pLineDirective ~forcefile:true l) $/;"	v
body_block	cil/src/cil.ml	/^      let body_block = b in $/;"	v
body_if_stmtkind	cil/src/cil.ml	/^      let body_if_stmtkind = (If(zero,body_block,break_block,l)) in$/;"	v
boolRegexp	cil/ocamlutil/util.ml	/^let boolRegexp = Str.regexp "b\\\\(\\\\(true\\\\)\\\\|\\\\(false\\\\)\\\\);"$/;"	v
boolType	cil/src/ext/crestInstrument.ml	/^let boolType = TInt (IUChar, [])$/;"	v
bop	cil/obj/x86_LINUX/formatparse.ml	/^                               let bop = (fst _2) args in$/;"	v
bottom	cil/src/ext/pta/golf.ml	/^let bottom () : tau =$/;"	v
bottom	cil/src/ext/pta/golf.mli	/^val bottom : unit -> tau$/;"	v
bottom	cil/src/ext/pta/olf.ml	/^let bottom () : tau =$/;"	v
bottom	cil/src/ext/pta/olf.mli	/^val bottom : unit -> tau$/;"	v
bottom	cil/src/ext/pta/steensgaard.ml	/^let bottom () : tau = $/;"	v
bottom	cil/src/ext/pta/steensgaard.mli	/^val bottom : unit -> tau$/;"	v
bottom	cil/src/ext/ssa.ml	/^  let bottom = Array.make size true in  (* bottom of the dominator tree *)$/;"	v
box_int_to_exp	cil/src/ext/ciltools.ml	/^let box_int_to_exp (n : int64) (ye : typ) : exp =$/;"	v
boxedInt	cil/ocamlutil/clist.ml	/^type boxedInt =$/;"	t
branch_count_	src/run_crest/concolic_search.h	/^  vector<unsigned int> branch_count_;$/;"	m	class:crest::Search
branch_function_	src/run_crest/concolic_search.h	/^  vector<function_id_t> branch_function_;$/;"	m	class:crest::Search
branch_id_t	src/base/basic_types.h	/^typedef int branch_id_t;$/;"	t	namespace:crest
branches	cil/src/ext/crestInstrument.ml	/^let branches = ref []$/;"	v
branches	src/base/symbolic_path.h	/^  const vector<branch_id_t>& branches() const { return branches_; }$/;"	f	class:crest::SymbolicPath
branches_	src/base/symbolic_path.h	/^  vector<branch_id_t> branches_;$/;"	m	class:crest::SymbolicPath
branches_	src/run_crest/concolic_search.h	/^  vector<branch_id_t> branches_;$/;"	m	class:crest::Search
break	cil/ocamlutil/pretty.ml	/^let break         = Break  $/;"	v
break	cil/ocamlutil/pretty.mli	/^val break: doc$/;"	v	function:++
breakString	cil/ocamlutil/pretty.ml	/^let rec breakString (acc: doc) (str: string) : doc = $/;"	v
break_block	cil/src/cil.ml	/^      let break_block = mkBlock [ break_stmt ] in$/;"	v
break_dest	cil/src/cil.ml	/^          let break_dest () = ref break_stmt in$/;"	v
break_stmt	cil/src/cil.ml	/^          let break_stmt = mkStmt (Instr []) in$/;"	v
break_stmt	cil/src/cil.ml	/^      let break_stmt = mkStmt (Instr []) in$/;"	v
bstmt	cil/src/ext/ssa.mli	/^    bstmt: Cil.stmt;$/;"	r	type:cfgBlock
bstmts	cil/src/cil.mli	/^     mutable bstmts: stmt list;       (** The statements comprising the block*)$/;"	r	type:block
bstmts	cil/src/frontc/cabs.ml	/^      bstmts: statement list$/;"	r	type:block
bsz	cil/src/testcil.ml	/^      let bsz = $/;"	v
bt	cil/obj/x86_LINUX/formatparse.ml	/^                     let bt = $/;"	v
bucketlist	cil/ocamlutil/inthash.ml	/^and 'a bucketlist =$/;"	t
buffer	cil/obj/x86_LINUX/cparser.ml	/^     let buffer = Buffer.create (Queue.length queue) in$/;"	v
bug	cil/ocamlutil/errormsg.ml	/^let bug (fmt : ('a,unit,doc,unit) format4) : 'a = $/;"	v
bug	cil/ocamlutil/errormsg.mli	/^val bug:           ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
bug	cil/src/cil.ml	/^let bug (fmt : ('a,unit,doc) format) : 'a = $/;"	v
buildFirstStmtIdMap	cil/src/ext/crestInstrument.ml	/^let buildFirstStmtIdMap cilFile =$/;"	v
builtinFunctions	cil/src/cil.ml	/^let builtinFunctions : (string, typ * typ list * bool) H.t = $/;"	v
builtinFunctions	cil/src/cil.mli	/^val builtinFunctions : (string, typ * typ list * bool) Hashtbl.t$/;"	v
builtinLoc	cil/src/cil.ml	/^let builtinLoc: location = { line = 1; $/;"	v
builtinLoc	cil/src/cil.mli	/^val builtinLoc: location$/;"	v
byte	cil/src/cil.mli	/^    byte: int;             (** The byte position in the source file *)$/;"	r	type:location
byteno	cil/src/frontc/cabs.ml	/^ byteno: int;$/;"	r	type:cabsloc
bytesSizeOfInt	cil/src/cil.ml	/^let bytesSizeOfInt (ik: ikind): int = $/;"	v
bytes_offset	cil/src/ext/sfi.ml	/^    let bytes_offset = bits_offset \/ 8 in$/;"	v
c	cil/ocamlutil/util.ml	/^          let c = stringToConfig s in $/;"	v
c	cil/src/cil.ml	/^    let c = String.get s i in$/;"	v
c	cil/test/small1/init.c	/^  int c;$/;"	m	union:__anon4	file:
cExp	cil/src/formatcil.ml	/^let cExp (prog: string) : (string * formatArg) list -> exp = $/;"	v
cExp	cil/src/formatcil.mli	/^val cExp: string -> (string * Cil.formatArg) list -> Cil.exp$/;"	v
cInstr	cil/src/formatcil.ml	/^let cInstr (prog: string) : location -> (string * formatArg) list -> instr = $/;"	v
cInstr	cil/src/formatcil.mli	/^val cInstr: string -> Cil.location -> $/;"	v
cLval	cil/src/formatcil.ml	/^let cLval (prog: string) : (string * formatArg) list -> lval = $/;"	v
cLval	cil/src/formatcil.mli	/^val cLval: string -> (string * Cil.formatArg) list -> Cil.lval$/;"	v
cStmt	cil/src/formatcil.ml	/^let cStmt (prog: string) : (string -> typ -> varinfo) -> $/;"	v
cStmt	cil/src/formatcil.mli	/^val cStmt: string -> $/;"	v
cStmts	cil/src/formatcil.ml	/^let cStmts (prog: string) : $/;"	v
cStmts	cil/src/formatcil.mli	/^val cStmts: string -> $/;"	v
cType	cil/src/formatcil.ml	/^let cType (prog: string) : (string * formatArg) list -> typ = $/;"	v
cType	cil/src/formatcil.mli	/^val cType: string -> (string * Cil.formatArg) list -> Cil.typ$/;"	v
cabsPushGlobal	cil/src/frontc/cabs2cil.ml	/^let cabsPushGlobal (g: global) = $/;"	v
cabsVisitor	cil/src/frontc/cabsvisit.mli	/^class type cabsVisitor = object$/;"	c
cabsloc	cil/src/frontc/cabs.ml	/^type cabsloc = {$/;"	t
cabsloc_to_str	cil/src/frontc/whitetrack.ml	/^let cabsloc_to_str cabsloc =$/;"	v
callBBVisitor	cil/src/ext/ciltools.ml	/^class callBBVisitor = object$/;"	c
callBBVisitor	cil/src/ext/partial.ml	/^class callBBVisitor =$/;"	c
callGraphNode	cil/src/ext/partial.ml	/^type callGraphNode = {$/;"	t
callHasNoSideEffects	cil/src/ext/deadcodeelim.ml	/^let callHasNoSideEffects : (instr -> bool) ref = $/;"	v
callHasNoSideEffects	cil/src/ext/pta/ptranal.mli	/^val callHasNoSideEffects : (Cil.exp -> bool) ref$/;"	v
callLogAlloc	cil/src/ext/sfi.ml	/^let callLogAlloc (szloc: dataLocation) $/;"	v
callLogFree	cil/src/ext/sfi.ml	/^let callLogFree  (dataloc: dataLocation) $/;"	v
callLogRead	cil/src/ext/sfi.ml	/^let callLogRead (lv: lval) = $/;"	v
callLogStack	cil/src/ext/sfi.ml	/^let callLogStack (fname: string) = $/;"	v
callLogWrite	cil/src/ext/sfi.ml	/^let callLogWrite (lv: lval) = $/;"	v
callNodeHash	cil/src/ext/partial.ml	/^type callNodeHash = (Cil.varinfo, callGraphNode) Hashtbl.t$/;"	t
calledBy	cil/src/ext/partial.ml	/^  mutable calledBy : Cil.fundec list;$/;"	r	type:callGraphNode
callgraph	cil/src/ext/callgraph.mli	/^type callgraph =$/;"	t
callnode	cil/src/ext/callgraph.mli	/^type callnode = {$/;"	t
calls	cil/src/ext/partial.ml	/^  mutable calls    : Cil.fundec list$/;"	r	type:callGraphNode
calls_end_basic_blocks	cil/src/ext/partial.ml	/^let calls_end_basic_blocks f =$/;"	v
can_be_called_by	cil/src/ext/partial.ml	/^  let can_be_called_by cg fd =$/;"	v
capacity	cil/src/ext/heap.ml	/^          capacity  : int ; (* max number of elements *)$/;"	r	type:t
card	cil/src/ext/bitmap.mli	/^val  card  : t -> int$/;"	v
cardinal	cil/src/ext/pta/setp.ml	/^    let rec cardinal = function$/;"	v
casesVisited	cil/src/check.ml	/^          let casesVisited : stmt list ref = ref [] in$/;"	v
cattr	cil/src/cil.mli	/^    mutable cattr:   attributes;        $/;"	r	type:compinfo
cc	cil/Makefile	/^	echo "let gcc = {" >>$@$/;"	m
ccHas__builtin_va_list	cil/Makefile	/^	echo "let gccHas__builtin_va_list = true" >>$@$/;"	m
cdefined	cil/src/cil.mli	/^    mutable cdefined: bool;$/;"	r	type:compinfo
cfgBlock	cil/src/ext/ssa.mli	/^and cfgBlock = { $/;"	t
cfgFun	cil/src/ext/cfg.mli	/^val cfgFun : fundec -> int$/;"	v
cfgInfo	cil/src/ext/ssa.mli	/^type cfgInfo = {$/;"	t
cfgStmts	cil/src/ext/cfg.ml	1;"	M
cfg_	src/run_crest/concolic_search.h	/^  vector<nbhr_list_t> cfg_;$/;"	m	class:crest::CfgHeuristicSearch
cfg_rev_	src/run_crest/concolic_search.h	/^  vector<nbhr_list_t> cfg_rev_;$/;"	m	class:crest::CfgHeuristicSearch
cfields	cil/src/cil.mli	/^    mutable cfields: fieldinfo list;    $/;"	r	type:compinfo
ch	cil/src/cil.ml	/^      let ch = String.get str idx in$/;"	v
changed	cil/src/ext/canonicalize.ml	/^	let changed: bool ref = ref false in$/;"	v
changed_cfg	cil/src/ext/partial.ml	/^    let changed_cfg = ref false$/;"	v
changes	cil/src/ext/dataflow.ml	/^            let changes = processStmt s in $/;"	v
char	cil/obj/x86_LINUX/cparser.ml	/^	    let char = int64_to_char value in$/;"	v
charConstPtrType	cil/src/cil.ml	/^let charConstPtrType = TPtr(TInt(IChar, [Attr("const", [])]),[])$/;"	v
charConstPtrType	cil/src/cil.mli	/^val charConstPtrType: typ$/;"	v
charConstToInt	cil/src/cil.ml	/^let charConstToInt (c: char) : constant =$/;"	v
charConstToInt	cil/src/cil.mli	/^val charConstToInt: char -> constant$/;"	v
charPtrType	cil/src/cil.ml	/^let charPtrType = TPtr(charType,[])$/;"	v
charPtrType	cil/src/cil.mli	/^val charPtrType: typ$/;"	v
charType	cil/src/cil.ml	/^let charType = TInt(IChar, [])$/;"	v
charType	cil/src/cil.mli	/^val charType: typ$/;"	v
char_is_unsigned	cil/obj/x86_LINUX/machdep.ml	/^  char_is_unsigned: bool; (* Whether "char" is unsigned *)$/;"	r	type:mach
checkBeforeAppend	cil/ocamlutil/clist.ml	/^let checkBeforeAppend  (l1: 'a clist) (l2: 'a clist) : bool =$/;"	v
checkBeforeAppend	cil/ocamlutil/clist.mli	/^val checkBeforeAppend: 'a clist -> 'a clist -> bool$/;"	v
checkBlock	cil/src/check.ml	/^and checkBlock (b: block) : unit = $/;"	v
checkConnective	cil/obj/x86_LINUX/cparser.ml	/^let checkConnective (s : string) : unit =$/;"	v
checkContext	cil/src/check.ml	/^  let rec checkContext = function$/;"	v
checkEnumInfo	cil/src/check.ml	/^and checkEnumInfo (isadef: defuse) enum = $/;"	v
checkExp	cil/src/check.ml	/^and checkExp (isconst: bool) (e: exp) : typ = $/;"	v
checkFile	cil/src/check.ml	/^let checkFile flags fl = $/;"	v
checkFile	cil/src/check.mli	/^val checkFile: checkFlags list -> Cil.file -> bool$/;"	v
checkFlags	cil/src/check.mli	/^type checkFlags = $/;"	t
checkGlobal	cil/src/check.ml	/^let rec checkGlobal = function$/;"	v
checkInit	cil/src/check.ml	/^and checkInit  (i: init) : typ = $/;"	v
checkInitType	cil/src/check.ml	/^and checkInitType (i: init) (t: typ) : unit = $/;"	v
checkIntegerType	cil/configure	/^checkIntegerType() {$/;"	f
checkIntegralType	cil/src/check.ml	/^and checkIntegralType (t: typ) = $/;"	v
checkLval	cil/src/check.ml	/^and checkLval (isconst: bool) (forAddrof: bool) (lv: lval) : typ = $/;"	v
checkOffset	cil/src/check.ml	/^and checkOffset basetyp : offset -> typ = function$/;"	v
checkOffsets	cil/src/testcil.ml	/^      let rec checkOffsets (lv: lval) (lvt: typ) = $/;"	v
checkProtected	cil/lib/OutputFile.pm	/^sub checkProtected {$/;"	s
checkRef	cil/lib/OutputFile.pm	/^sub checkRef {$/;"	s
checkSameFormat	cil/obj/x86_LINUX/formatparse.ml	/^let rec checkSameFormat (fl1: formatArg list) (fl2: formatArg list) = $/;"	v
checkSomeFunctions	cil/src/ext/stackoverflow.ml	/^let checkSomeFunctions = ref false$/;"	v
checkTemporary	cil/lib/OutputFile.pm	/^sub checkTemporary {$/;"	s
checkType	cil/src/check.ml	/^let rec checkType (t: typ) (ctx: ctxType) = $/;"	v
check_alias	cil/src/ext/pta/golf.ml	/^  let rec check_alias sets labels =$/;"	v
children	cil/src/ext/dominators.ml	/^let children (t: tree) (s: stmt) : stmt list =$/;"	v
children	cil/src/ext/dominators.mli	/^val children: tree -> Cil.stmt -> Cil.stmt list$/;"	v
childrenIdentStringExp	cil/src/frontc/cabsvisit.ml	/^      let childrenIdentStringExp ((i,s, e) as input) = $/;"	v
childrenNameGroup	cil/src/frontc/cabsvisit.ml	/^and childrenNameGroup vis (kind: nameKind) ((s, nl) as input) = $/;"	v
childrenSpecElem	cil/src/frontc/cabsvisit.ml	/^and childrenSpecElem (vis: cabsVisitor) (se: spec_elem) : spec_elem = $/;"	v
childrenStmt	cil/src/cil.ml	/^and childrenStmt (toPrepend: instr list ref) (vis:cilVisitor) (s:stmt): stmt =$/;"	v
choose	cil/src/ext/pta/setp.ml	/^    let choose = min_elt$/;"	v
chooseLastGain	cil/ocamlutil/pretty.ml	/^let chooseLastGain () : align option = $/;"	v
chopped	cil/src/cil.ml	/^        let chopped = Int64.shift_right_logical i (64 - nrBits)$/;"	v
chopwhite	cil/src/frontc/whitetrack.ml	/^let rec chopwhite str =$/;"	v
chr	cil/ocamlutil/pretty.ml	/^let chr  c        = text (String.make 1 c) $/;"	v
chr	cil/ocamlutil/pretty.mli	/^val chr          : char   -> doc$/;"	v	function:++
ci	cil/src/ext/heapify.ml	/^        let ci = mkCompInfo true name (* make a big structure *)$/;"	v
ci	cil/src/mergecil.ml	/^    let ci = cinode.ndata in$/;"	v
cil	cil/src/frontc/frontc.ml	/^    let cil = Stats.time "convert to CIL" Cabs2cil.convFile cabs in$/;"	v
cilOutputFile	cil/lib/Cilly.pm	/^sub cilOutputFile {$/;"	s
cilVersion	cil/obj/x86_LINUX/cilversion.ml	/^let cilVersion      = "1.3.6"$/;"	v
cilVersion	cil/src/cil.mli	/^val cilVersion: string$/;"	v
cilVersionMajor	cil/obj/x86_LINUX/cilversion.ml	/^let cilVersionMajor = 1$/;"	v
cilVersionMajor	cil/src/cil.mli	/^val cilVersionMajor: int$/;"	v
cilVersionMinor	cil/obj/x86_LINUX/cilversion.ml	/^let cilVersionMinor = 3$/;"	v
cilVersionMinor	cil/src/cil.mli	/^val cilVersionMinor: int$/;"	v
cilVersionRev	cil/obj/x86_LINUX/cilversion.ml	/^let cilVersionRev   = 6$/;"	v
cilVersionRevision	cil/src/cil.mli	/^val cilVersionRevision: int$/;"	v
cilVisitor	cil/src/cil.mli	/^class type cilVisitor = object$/;"	c
cil_to_ocaml_int	cil/src/ext/ciltools.ml	/^let cil_to_ocaml_int (e : exp) : (int64 * int * sign) = $/;"	v
cinfo	cil/src/ext/dataslicing.ml	/^    let cinfo =$/;"	v
cinode	cil/src/mergecil.ml	/^  let    cinode = getNode sEq sSyn    fidx    ci.cname    ci None in $/;"	v
ckey	cil/src/cil.mli	/^    mutable ckey: int;                  $/;"	r	type:compinfo
classifyArgDebug	cil/lib/Cilly.pm	/^sub classifyArgDebug {$/;"	s
cleanUpExp	cil/src/ext/predabst.ml	/^      let rec cleanUpExp e = match e with$/;"	v
cleanup	cil/src/main.ml	/^let cleanup () = $/;"	v
clear	cil/ocamlutil/growArray.ml	/^let clear (ga: 'a t) : unit =$/;"	v
clear	cil/ocamlutil/growArray.mli	/^val clear: 'a t -> unit $/;"	v
clear	cil/ocamlutil/inthash.mli	/^val clear: 'a t -> unit$/;"	v
clear	cil/ocamlutil/util.mli	/^  val clear : 'a t -> unit$/;"	v	Module:STACK
clear	cil/src/cil.ml	/^class clear : cilVisitor = object$/;"	c
clearCFGinfo	cil/src/ext/cfg.ml	/^let clearCFGinfo (fd : fundec) =$/;"	v
clearCFGinfo	cil/src/ext/cfg.mli	/^val clearCFGinfo: Cil.fundec -> unit$/;"	v
clearFileCFG	cil/src/ext/cfg.ml	/^let clearFileCFG (f : file) =$/;"	v
clearFileCFG	cil/src/ext/cfg.mli	/^val clearFileCFG: Cil.file -> unit$/;"	v
clear_lexeme	cil/obj/x86_LINUX/clexer.mli	/^val clear_lexeme: unit -> unit$/;"	v
clear_lexeme	cil/src/frontc/clexer.mli	/^val clear_lexeme: unit -> unit$/;"	v
clear_sinfo	cil/src/ext/partial.ml	/^  let clear_sinfo () = Hashtbl.clear sinfo_ht$/;"	v
clear_white	cil/obj/x86_LINUX/clexer.mli	/^val clear_white: unit -> unit$/;"	v
clear_white	cil/src/frontc/clexer.mli	/^val clear_white: unit -> unit$/;"	v
clexer	cil/src/frontc/frontc.ml	/^and clexer lexbuf =$/;"	v
clist	cil/ocamlutil/clist.ml	/^type 'a clist = $/;"	t
clist	cil/ocamlutil/clist.mli	/^type 'a clist = $/;"	t
clone	cil/src/ext/bitmap.mli	/^val  clone : t -> t $/;"	v
cloneEmpty	cil/src/ext/bitmap.mli	/^val  cloneEmpty : t -> t                (* An empty set with the same $/;"	v
cnCallees	cil/src/ext/callgraph.mli	/^  cnCallees: callnode Inthash.t;$/;"	r	type:callnode
cnCallers	cil/src/ext/callgraph.mli	/^  cnCallers: callnode Inthash.t;$/;"	r	type:callnode
cnInfo	cil/src/ext/callgraph.mli	/^  cnInfo: nodeinfo;$/;"	r	type:callnode
cname	cil/src/cil.mli	/^    mutable cname: string;              $/;"	r	type:compinfo
cnid	cil/src/ext/callgraph.mli	/^  cnid: int;$/;"	r	type:callnode
coeff_	src/base/symbolic_expression.h	/^  map<var_t,value_t> coeff_;$/;"	m	class:crest::SymbolicExpr
collect	cil/ocamlutil/pretty.ml	/^  and collect (acc: doc) (i: int) = $/;"	v
collectArgumentList	cil/lib/Cilly.pm	/^sub collectArgumentList {$/;"	s
collectOneArgument	cil/bin/cilly	/^sub collectOneArgument {$/;"	s
collectOneArgument	cil/lib/Cilly.pm	/^sub collectOneArgument {$/;"	s
collect_ptset	cil/src/ext/pta/olf.ml	/^let collect_ptset =$/;"	v
collect_ptset_fast	cil/src/ext/pta/olf.ml	/^let collect_ptset_fast (l : c_absloc) : abslocset =$/;"	v
collect_ptset_slow	cil/src/ext/pta/olf.ml	/^let collect_ptset_slow (l : c_absloc) : abslocset =$/;"	v
collect_ptsets	cil/src/ext/pta/golf.ml	/^let collect_ptsets (l : label) : constantset = (* todo -- cache aliases *)$/;"	v
combine	cil/src/ext/pta/golf.ml	/^and combine (ti, ti' : tinfo * tinfo) : tinfo =$/;"	v
combine	cil/src/ext/pta/steensgaard.ml	/^and combine (ti,ti' : tinfo * tinfo) : tinfo = $/;"	v
combinePredecessors	cil/src/ext/predabst.ml	/^	let combinePredecessors (stm:stmt) ~(old:t) (ss:t) =$/;"	v
combine_label	cil/src/ext/pta/steensgaard.ml	/^  let combine_label (li,li' : lblinfo *lblinfo) : lblinfo =$/;"	v
combine_lbounds	cil/src/ext/pta/steensgaard.ml	/^let combine_lbounds (s,s' : label boundset * label boundset) =$/;"	v
comment	cil/src/cil.mli	/^and comment = location * string$/;"	t
comp	cil/src/cil.ml	/^   let comp = $/;"	v
compFullName	cil/src/cil.ml	/^let compFullName comp = $/;"	v
compFullName	cil/src/cil.mli	/^val compFullName: compinfo -> string$/;"	v
compactStmts	cil/src/cil.mli	/^val compactStmts: stmt list -> stmt list$/;"	v
comparativeLevel	cil/src/cil.ml	/^let comparativeLevel = 70$/;"	v
compare	cil/ocamlutil/intmap.ml	/^let compare cmp m1 m2 =$/;"	v
compare	cil/ocamlutil/intmap.mli	/^val compare: ('a -> 'a -> int) -> 'a t -> 'a t -> int$/;"	v
compare	cil/src/ext/pta/setp.ml	/^    let compare s1 s2 =$/;"	v
compareExpDeepStripCasts	cil/src/ext/expcompare.ml	/^let compareExpDeepStripCasts (e1 : exp) (e2 : exp) : bool =$/;"	v
compareExpStripCasts	cil/src/ext/deadcodeelim.ml	/^let compareExpStripCasts (e1: exp) (e2: exp) : bool =$/;"	v
compareExpStripCasts	cil/src/ext/expcompare.ml	/^let compareExpStripCasts (e1: exp) (e2: exp) : bool =$/;"	v
compareLoc	cil/src/cil.mli	/^val compareLoc: location -> location -> int$/;"	v
compareLval	cil/src/ext/expcompare.ml	1;"	M
compareTypes	cil/src/ext/expcompare.ml	/^let compareTypes ?(ignoreSign=true) (t1 : typ) (t2 : typ) : bool =$/;"	v	value:stripCastsForPtrArith
compareTypesNoAttributes	cil/src/ext/expcompare.ml	/^let compareTypesNoAttributes ?(ignoreSign=true) (t1 : typ) (t2 : typ) : bool =$/;"	v	value:stripCastsForPtrArith
compare_aux	cil/src/ext/pta/setp.ml	/^    let rec compare_aux l1 l2 =$/;"	v
compare_choices	cil/src/cil.ml	/^      let compare_choices s1 s2 = match s1.labels, s2.labels with$/;"	v
compare_exp	cil/src/ext/ciltools.ml	/^let compare_exp x y =$/;"	v
compare_op_t	src/base/basic_types.h	/^enum compare_op_t { EQ = 0, NEQ = 1, GT = 2, LE = 3, LT = 4, GE = 5 };$/;"	g	namespace:crest::ops
compile	cil/lib/Cilly.pm	/^sub compile {$/;"	s
compileOutputFile	cil/lib/Cilly.pm	/^sub compileOutputFile {$/;"	s
compile_cil	cil/lib/Cilly.pm	/^sub compile_cil {$/;"	s
compilerArgument	cil/lib/Cilly.pm	/^sub compilerArgument {$/;"	s
compinfo	cil/src/cil.mli	/^and compinfo = {$/;"	t
compop	cil/src/cil.ml	/^  let compop, nextop = $/;"	v
compute	cil/src/ext/dataflow.ml	/^    let compute (sinks: stmt list) = $/;"	v
compute	cil/src/ext/dataflow.ml	/^    let compute (sources: stmt list) = $/;"	v
compute	cil/src/ext/partial.ml	/^  let compute (f : Cil.file) =$/;"	v
computeAEs	cil/src/ext/availexps.ml	/^let computeAEs fd =$/;"	v
computeCFGInfo	cil/src/cil.mli	/^val computeCFGInfo: fundec -> bool -> unit$/;"	v
computeDeepUseDefStmtKind	cil/src/ext/usedef.ml	/^let rec computeDeepUseDefStmtKind ?(acc_used=VS.empty)$/;"	v
computeDomTree	cil/src/ext/dominators.ml	/^let computeDomTree ?(doCFG:bool=true) (f: fundec) $/;"	v
computeDomTree	cil/src/ext/dominators.mli	/^val computeDomTree: ?doCFG:bool -> $/;"	v
computeFileCFG	cil/src/ext/cfg.mli	/^val computeFileCFG: Cil.file -> unit$/;"	v
computeGraph	cil/src/ext/callgraph.mli	/^val computeGraph : Cil.file -> callgraph$/;"	v
computeIDom	cil/src/ext/dominators.mli	/^val computeIDom: ?doCFG:bool -> Cil.fundec -> Cil.stmt option Inthash.t$/;"	v
computeLiveness	cil/src/ext/liveness.ml	/^let computeLiveness fdec =$/;"	v
computeStackThreshhold	cil/src/ext/stackoverflow.ml	/^    let computeStackThreshhold = $/;"	v
computeUseDefInstr	cil/src/ext/usedef.ml	/^let computeUseDefInstr ?(acc_used=VS.empty)$/;"	v
computeUseDefStmtKind	cil/src/ext/usedef.ml	/^let computeUseDefStmtKind ?(acc_used=VS.empty)$/;"	v
computeUseExp	cil/src/ext/usedef.ml	/^let computeUseExp ?(acc=VS.empty) (e: exp) : VS.t = $/;"	v
computeUseLocalTypes	cil/src/ext/usedef.ml	/^let computeUseLocalTypes ?(acc_used=VS.empty)$/;"	v
compute_aliases	cil/src/ext/pta/ptranal.mli	/^val compute_aliases : bool  -> unit$/;"	v
compute_may_aliases	cil/src/ext/pta/ptranal.ml	/^let compute_may_aliases (b : bool) : unit =$/;"	v
compute_results	cil/src/ext/pta/ptranal.mli	/^val compute_results : bool -> unit$/;"	v
concat	cil/ocamlutil/pretty.ml	/^let concat d1 d2 = Concat (d1, d2)$/;"	v
concat	cil/ocamlutil/pretty.mli	/^val concat       : doc -> doc -> doc$/;"	v	function:++
concrete	src/base/symbolic_interpreter.h	/^    value_t concrete;$/;"	m	struct:crest::SymbolicInterpreter::StackElem
configToString	cil/ocamlutil/util.ml	/^  let configToString (c: configData) : string = $/;"	v
cons_enum	cil/ocamlutil/intmap.ml	/^let rec cons_enum m e =$/;"	v
conservative_undefineds	cil/src/ext/pta/ptranal.mli	/^val conservative_undefineds : bool ref$/;"	v
considerGlobal	cil/src/rmtmps.ml	/^  let considerGlobal global =$/;"	v
constFold	cil/src/cil.ml	/^and constFold (machdep: bool) (e: exp) : exp = $/;"	v
constFold	cil/src/cil.mli	/^val constFold: bool -> exp -> exp$/;"	v
constFoldBinOp	cil/src/cil.mli	/^val constFoldBinOp: bool -> binop -> exp -> exp -> typ -> exp$/;"	v
constFoldLval	cil/src/cil.ml	/^and constFoldLval machdep (host,offset) =$/;"	v
constFoldVisitor	cil/src/cil.ml	/^let constFoldVisitor (machdep: bool) = new constFoldVisitorClass machdep$/;"	v
constFoldVisitorClass	cil/src/cil.ml	/^class constFoldVisitorClass (machdep: bool) : cilVisitor = object$/;"	c
const_	src/base/symbolic_expression.h	/^  value_t const_;$/;"	m	class:crest::SymbolicExpr
const_nbhr_it	src/process_cfg/process_cfg.cc	/^typedef adj_list_t::const_iterator const_nbhr_it;$/;"	t	file:
const_string_literals	cil/obj/x86_LINUX/machdep.ml	/^  const_string_literals: bool; (* Whether string literals have const chars *)$/;"	r	type:mach
const_term	src/base/symbolic_expression.h	/^  value_t const_term() const { return const_; }$/;"	f	class:crest::SymbolicExpr
constant	cil/src/cil.mli	/^and constant =$/;"	t
constant	cil/src/frontc/cabs.ml	/^and constant =$/;"	t
constraints	src/base/symbolic_path.h	/^  const vector<SymbolicPred*>& constraints() const { return constraints_; }$/;"	f	class:crest::SymbolicPath
constraints_	src/base/symbolic_path.h	/^  vector<SymbolicPred*> constraints_;$/;"	m	class:crest::SymbolicPath
constraints_idx	src/base/symbolic_path.h	/^  const vector<size_t>& constraints_idx() const { return constraints_idx_; }$/;"	f	class:crest::SymbolicPath
constraints_idx_	src/base/symbolic_path.h	/^  vector<size_t> constraints_idx_;$/;"	m	class:crest::SymbolicPath
cont_dest	cil/src/cil.ml	/^          let cont_dest () = ref cont_stmt in $/;"	v
cont_stmt	cil/src/cil.ml	/^          let cont_stmt = mkStmt (Instr []) in$/;"	v
context	cil/obj/x86_LINUX/clexer.ml	/^let context : string list list ref = ref []$/;"	v
contextMessage	cil/ocamlutil/errormsg.ml	/^let contextMessage (name: string) (d: doc) = $/;"	v
convFile	cil/src/frontc/cabs2cil.mli	/^val convFile: Cabs.file -> Cil.file$/;"	v
convLoc	cil/src/frontc/cabs2cil.ml	/^let convLoc (l : cabsloc) =$/;"	v
convertInts	cil/src/cil.ml	/^let convertInts (i1:int64) (ik1:ikind) (i2:int64) (ik2:ikind)$/;"	v
copy	cil/ocamlutil/growArray.ml	/^let copy (ga: 'a t) : 'a t = $/;"	v
copy	cil/ocamlutil/growArray.mli	/^val copy : 'a t -> 'a t$/;"	v
copy	cil/ocamlutil/inthash.mli	/^val copy: 'a t -> 'a t$/;"	v
copy	cil/ocamlutil/longarray.mli	/^val copy : 'a t -> 'a t$/;"	v
copy	cil/ocamlutil/util.mli	/^  val copy : 'a t -> 'a t$/;"	v	Module:STACK
copyCompInfo	cil/src/cil.mli	/^val copyCompInfo: compinfo -> string -> compinfo$/;"	v
copyFunction	cil/src/cil.ml	/^let copyFunction (f: fundec) (newname: string) : fundec = $/;"	v
copyFunction	cil/src/cil.mli	/^val copyFunction: fundec -> string -> fundec $/;"	v
copyFunctionVisitor	cil/src/cil.ml	/^class copyFunctionVisitor (newname: string) = object (self)$/;"	c
copyGrowArray	cil/ocamlutil/util.ml	/^let copyGrowArray (ga: 'a growArray) : 'a growArray = $/;"	v
copyVarinfo	cil/src/cil.mli	/^val copyVarinfo: varinfo -> string -> varinfo$/;"	v
copy_into	cil/ocamlutil/inthash.mli	/^val copy_into: 'a t -> 'a t -> unit$/;"	v
count	cil/src/rmtmps.ml	/^	let count = List.length removedLocals in$/;"	v
countNewLines	cil/ocamlutil/pretty.ml	/^let countNewLines = ref 0$/;"	v
countNewLines	cil/ocamlutil/pretty.mli	/^val countNewLines : int ref$/;"	v
counter	cil/src/ext/canonicalize.ml	/^		  let counter: int ref = ref 0 in$/;"	v
counter	cil/src/frontc/frontc.ml	/^  let counter : int ref = ref 0 in$/;"	v
covered_	src/run_crest/concolic_search.h	/^  vector<bool> covered_;$/;"	m	class:crest::Search
create	cil/ocamlutil/inthash.ml	/^let create initial_size =$/;"	v
create	cil/ocamlutil/inthash.mli	/^val create: int -> 'a t$/;"	v
create	cil/ocamlutil/intmap.ml	/^let create l x d r =$/;"	v
create	cil/ocamlutil/longarray.mli	/^val create : int -> 'a -> 'a t$/;"	v
create	cil/ocamlutil/util.mli	/^  val create : unit -> 'a t$/;"	v	Module:STACK
create	cil/src/ext/heap.ml	/^let create size = {$/;"	v
createFile	cil/src/testcil.ml	/^let createFile () = $/;"	v
creferenced	cil/src/cil.mli	/^    mutable creferenced: bool;          $/;"	r	type:compinfo
crest	src/base/basic_types.cc	/^namespace crest {$/;"	n	file:
crest	src/base/basic_types.h	/^namespace crest {$/;"	n
crest	src/base/symbolic_execution.cc	/^namespace crest {$/;"	n	file:
crest	src/base/symbolic_execution.h	/^namespace crest {$/;"	n
crest	src/base/symbolic_expression.cc	/^namespace crest {$/;"	n	file:
crest	src/base/symbolic_expression.h	/^namespace crest {$/;"	n
crest	src/base/symbolic_interpreter.cc	/^namespace crest {$/;"	n	file:
crest	src/base/symbolic_interpreter.h	/^namespace crest {$/;"	n
crest	src/base/symbolic_path.cc	/^namespace crest {$/;"	n	file:
crest	src/base/symbolic_path.h	/^namespace crest {$/;"	n
crest	src/base/symbolic_predicate.cc	/^namespace crest {$/;"	n	file:
crest	src/base/symbolic_predicate.h	/^namespace crest {$/;"	n
crest	src/base/yices_solver.cc	/^namespace crest {$/;"	n	file:
crest	src/base/yices_solver.h	/^namespace crest {$/;"	n
crest	src/run_crest/concolic_search.cc	/^namespace crest {$/;"	n	file:
crest	src/run_crest/concolic_search.h	/^namespace crest {$/;"	n
crestInstrumentVisitor	cil/src/ext/crestInstrument.ml	/^class crestInstrumentVisitor f =$/;"	c
cstruct	cil/src/cil.mli	/^    mutable cstruct: bool;              $/;"	r	type:compinfo
ctxType	cil/src/check.ml	/^type ctxType = $/;"	t
curBranches	cil/src/ext/crestInstrument.ml	/^let curBranches = ref []$/;"	v
curLoc	cil/src/mergecil.ml	/^      let curLoc = !currentLoc in     (* d_global blows this away.. *)$/;"	v
curNode	cil/src/ext/blockinggraph.ml	/^          let curNode = getFunctionNode fdec.svar.vname in$/;"	v
curSum	cil/src/mergecil.ml	/^                let curSum = (functionChecksum fdec') in$/;"	v
cur_ex_	src/run_crest/concolic_search.h	/^  SymbolicExecution cur_ex_;$/;"	m	class:crest::UniformRandomSearch
curidx	cil/src/frontc/whitetrack.ml	/^let curidx = ref 0  $/;"	v
curr	cil/src/ext/dataflow.ml	/^          let curr = match act with$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                            let currentArg = _1 in $/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                         ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                        ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                       ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                      ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                     ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                    ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                   ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                  (  let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                  ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                 ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                 ( let currentArg = _2 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                ( let currentArg = _1 in$/;"	v
currentArg	cil/obj/x86_LINUX/formatparse.ml	/^                ( let currentArg = _2 in$/;"	v
currentContext	cil/src/ext/predabst.ml	/^    let currentContext = emptyContext()$/;"	v
currentDeclIdx	cil/src/mergecil.ml	/^let currentDeclIdx = ref 0 (* The index of the definition in a file. This is $/;"	v
currentFidx	cil/src/mergecil.ml	/^let currentFidx = ref 0$/;"	v
currentFunc	cil/src/ext/logcalls.ml	/^let currentFunc: string ref = ref ""$/;"	v
currentFunc	cil/src/rmtmps.ml	/^  let currentFunc = ref None in $/;"	v
currentLoc	cil/obj/x86_LINUX/clexer.mli	/^val currentLoc : unit -> Cabs.cabsloc$/;"	v
currentLoc	cil/src/frontc/cabshelper.ml	/^let currentLoc () = $/;"	v
currentLoc	cil/src/frontc/clexer.mli	/^val currentLoc : unit -> Cabs.cabsloc$/;"	v
currentReturnType	cil/src/check.ml	/^let currentReturnType : typ ref = ref voidType$/;"	v
cvspec	cil/src/frontc/cabs.ml	/^and cvspec =$/;"	t
cycles_per_usec	cil/ocamlutil/perfcount.c	/^double cycles_per_usec = 3850.000;$/;"	v
d	cil/obj/x86_LINUX/cparser.ml	/^                                          ( let d, a = _2 in$/;"	v
d	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let d, a = _3 in$/;"	v
d	cil/obj/x86_LINUX/cparser.ml	/^                               ( let d, a = _2 in$/;"	v
d	cil/src/cil.ml	/^        let d =$/;"	v
d'	cil/src/ext/dataflow.ml	/^          let d' = T.computeFirstPredecessor s d in $/;"	v
dBlock	cil/src/cil.ml	/^  method dBlock (out: out_channel) (ind: int) (b:block) : unit = $/;"	m
dExp	cil/src/cil.ml	/^let dExp: doc -> exp = $/;"	v
dExp	cil/src/formatcil.ml	/^let dExp (prog: string) : exp -> formatArg list option = $/;"	v
dExp	cil/src/formatcil.mli	/^val dExp: string -> Cil.exp -> Cil.formatArg list option$/;"	v
dGlobal	cil/src/cil.ml	/^   method dGlobal (out: out_channel) (g: global) : unit = $/;"	m
dGlobal	cil/src/cil.ml	/^let dGlobal: doc -> location -> global = $/;"	v
dInit	cil/src/cil.ml	/^  method dInit (out: out_channel) (ind: int) (i: init) = $/;"	m
dInstr	cil/src/cil.ml	/^let dInstr: doc -> location -> instr = $/;"	v
dInstr	cil/src/formatcil.ml	/^let dInstr (prog: string) : instr -> formatArg list option = $/;"	v
dInstr	cil/src/formatcil.mli	/^val dInstr: string -> Cil.instr -> Cil.formatArg list option$/;"	v
dList	cil/src/frontc/patch.ml	/^        let dList = (visitCabsDefinition$/;"	v	value:patchDefn
dLval	cil/src/formatcil.ml	/^let dLval (prog: string) : lval -> formatArg list option = $/;"	v
dLval	cil/src/formatcil.mli	/^val dLval: string -> Cil.lval -> Cil.formatArg list option$/;"	v
dStmt	cil/src/cil.ml	/^  method dStmt (out: out_channel) (ind: int) (s:stmt) : unit = $/;"	m
dType	cil/src/formatcil.ml	/^let dType (prog: string) : typ -> formatArg list option = $/;"	v
dType	cil/src/formatcil.mli	/^val dType: string -> Cil.typ -> Cil.formatArg list option$/;"	v
d_absloc	cil/src/ext/pta/golf.ml	/^let d_absloc () (p : absloc) =$/;"	v
d_absloc	cil/src/ext/pta/golf.mli	/^val d_absloc : unit -> absloc -> Pretty.doc$/;"	v
d_absloc	cil/src/ext/pta/olf.mli	/^val d_absloc : unit -> absloc -> Pretty.doc$/;"	v
d_absloc	cil/src/ext/pta/ptranal.ml	/^let d_absloc: unit -> absloc -> Pretty.doc = A.d_absloc$/;"	v
d_absloc	cil/src/ext/pta/ptranal.mli	/^val d_absloc : unit -> absloc -> Pretty.doc$/;"	v
d_attr	cil/src/cil.ml	/^let d_attr () a = printAttr defaultCilPrinter () a$/;"	v
d_attrlist	cil/src/cil.ml	/^let d_attrlist () a = printAttrs defaultCilPrinter () a $/;"	v
d_attrparam	cil/src/cil.ml	/^let d_attrparam () e = defaultCilPrinter#pAttrParam () e$/;"	v
d_binop	cil/src/cil.ml	/^let d_binop () b =$/;"	v
d_block	cil/src/cil.ml	/^let d_block () b = printBlock defaultCilPrinter () b$/;"	v
d_boxedInt	cil/ocamlutil/clist.ml	/^let d_boxedInt () b =$/;"	v
d_cabsloc	cil/src/frontc/cabshelper.ml	/^let d_cabsloc () cl = $/;"	v
d_cfgedge	cil/src/ext/cfg.ml	/^let d_cfgedge (src) () (dest) =$/;"	v
d_cfgnode	cil/src/ext/cfg.ml	/^let d_cfgnode () (s : stmt) =$/;"	v
d_cfgnodelabel	cil/src/ext/cfg.ml	/^let d_cfgnodelabel () (s : stmt) =$/;"	v
d_cfgnodename	cil/src/ext/cfg.ml	/^let d_cfgnodename () (s : stmt) =$/;"	v
d_context	cil/src/check.ml	/^let d_context () = function$/;"	v
d_exp	cil/src/cil.ml	/^let d_exp () e = printExp defaultCilPrinter () e$/;"	v
d_fkind	cil/src/cil.ml	/^let d_fkind () = function$/;"	v
d_global	cil/src/cil.ml	/^let d_global () g = printGlobal defaultCilPrinter () g$/;"	v
d_growarray	cil/ocamlutil/growArray.ml	/^let d_growarray (sep: Pretty.doc)$/;"	v
d_growarray	cil/ocamlutil/growArray.mli	/^val d_growarray : Pretty.doc -> (int -> 'a -> Pretty.doc) -> unit -> 'a t$/;"	v
d_hloc	cil/ocamlutil/errormsg.ml	/^let d_hloc () (l: location) = $/;"	v
d_hloc	cil/ocamlutil/errormsg.mli	/^val d_hloc: unit -> location -> Pretty.doc$/;"	v
d_init	cil/src/cil.ml	/^let d_init () i = printInit defaultCilPrinter () i$/;"	v
d_instr	cil/src/cil.ml	/^let d_instr () i = printInstr defaultCilPrinter () i$/;"	v
d_int32	cil/ocamlutil/pretty.ml	/^let d_int32 (i: int32) = text (Int32.to_string i)$/;"	v
d_int32	cil/ocamlutil/pretty.mli	/^val d_int32: int32 -> doc$/;"	v	function:++
d_int64	cil/ocamlutil/pretty.ml	/^let d_int64 (i: int64) = text (Int64.to_string i)$/;"	v
d_int64	cil/ocamlutil/pretty.mli	/^val d_int64: int64 -> doc$/;"	v	function:++
d_label	cil/src/cil.ml	/^let d_label () l = defaultCilPrinter#pLabel () l$/;"	v
d_list	cil/ocamlutil/pretty.mli	/^val d_list: string -> (unit -> 'a -> doc) -> unit -> 'a list -> doc$/;"	v	function:++
d_loc	cil/ocamlutil/errormsg.ml	/^let d_loc () l = $/;"	v
d_loc	cil/ocamlutil/errormsg.mli	/^val d_loc: unit -> location -> Pretty.doc$/;"	v
d_loc	cil/src/frontc/patch.ml	/^let d_loc (_:unit) (loc: cabsloc) : doc =$/;"	v
d_lval	cil/src/cil.ml	/^let d_lval () lv = printLval defaultCilPrinter () lv$/;"	v
d_map	cil/ocamlutil/pretty.mli	/^    val d_map: ?dmaplet:(doc -> doc -> doc)$/;"	v
d_offset	cil/src/cil.ml	/^let d_offset base () off = defaultCilPrinter#pOffset base off$/;"	v
d_oneInit	cil/src/cil.ml	/^        let d_oneInit = function$/;"	v
d_plainexp	cil/src/cil.ml	/^let d_plainexp () e = plainCilPrinter#pExp () e$/;"	v
d_plaininit	cil/src/cil.ml	/^let d_plaininit () i = plainCilPrinter#pInit () i$/;"	v
d_plainlval	cil/src/cil.ml	/^let d_plainlval () l = plainCilPrinter#pLval () l$/;"	v
d_plaintype	cil/src/cil.ml	/^let d_plaintype () t = plainCilPrinter#pType None () t$/;"	v
d_set	cil/ocamlutil/pretty.mli	/^    val d_set: string$/;"	v
d_shortglobal	cil/src/cil.ml	/^let d_shortglobal () = function$/;"	v
d_stmt	cil/src/cil.ml	/^let d_stmt () s = printStmt defaultCilPrinter () s$/;"	v
d_storage	cil/src/cil.ml	/^let d_storage () = function$/;"	v
d_string	cil/src/ext/logcalls.ml	/^let d_string (fmt : ('a,unit,doc,string) format4) : 'a = $/;"	v
d_type	cil/src/cil.ml	/^let d_type () t = printType defaultCilPrinter () t$/;"	v
d_typsig	cil/src/cil.ml	/^let rec d_typsig () = function$/;"	v
d_typsig	cil/src/cil.mli	/^val d_typsig: unit -> typsig -> Pretty.doc$/;"	v
d_unop	cil/src/cil.ml	/^let d_unop () u =$/;"	v
data	cil/ocamlutil/inthash.ml	/^    mutable data: 'a bucketlist array } (* the buckets *)$/;"	r	type:t
data	cil/test/small1/init.c	/^  int   data;$/;"	m	struct:s	file:
data	test/cfg_search_test.c	/^int data[200];$/;"	v
data'	cil/ocamlutil/util.ml	/^    let data' = begin match ga.gaFill with$/;"	v
datadir	cil/Makefile	/^datadir = ${datarootdir}$/;"	m
dataflow	cil/src/ext/partial.ml	/^    let dataflow (file : Cil.file)           (* whole program *)$/;"	v
datarootdir	cil/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
dbgToken	cil/obj/x86_LINUX/clexer.ml	/^let dbgToken (t: token) = $/;"	v
dbl	test/function.c	/^short dbl(short x) {$/;"	f
dce	cil/src/ext/deadcodeelim.ml	/^let dce f =$/;"	v
dconcat	cil/ocamlutil/pretty.ml	/^  let dconcat (acc: doc) (another: doc) = $/;"	v
dctext1	cil/ocamlutil/pretty.ml	/^  let dctext1 (acc: doc) (str: string) = $/;"	v
dd_exp	cil/src/cil.ml	/^let dd_exp = descriptiveCilPrinter#pExp$/;"	v
deadCodeElimClass	cil/src/ext/deadcodeelim.ml	/^class deadCodeElimClass : cilVisitor = object(self)$/;"	c
dead_configs	cil/src/ext/pta/golf.ml	/^  let dead_configs : config_map = CH.create 16 in$/;"	v
deallocators	cil/src/ext/sfi.ml	/^let deallocators: (string, dataLocation) H.t = H.create 13$/;"	v
debug	cil/ocamlutil/pretty.ml	/^let debug =  false$/;"	v
debug	cil/src/ext/deadcodeelim.ml	/^let debug = RD.debug$/;"	v
debug	cil/src/ext/pta/golf.mli	/^val debug : bool ref$/;"	v
debug	cil/src/ext/pta/olf.mli	/^val debug : bool ref$/;"	v
debug	cil/src/ext/pta/ptranal.mli	/^val debug : bool ref$/;"	v
debug	cil/src/ext/pta/steensgaard.mli	/^val debug : bool ref$/;"	v
debug	cil/src/ext/reachingdefs.ml	/^let debug = ref false$/;"	v
debugFlag	cil/ocamlutil/errormsg.ml	/^let debugFlag  = ref false              (* If set then print debugging info *)$/;"	v
debugFlag	cil/ocamlutil/errormsg.mli	/^val debugFlag  : bool ref               $/;"	v
debugLoc	cil/src/frontc/cabs2cil.ml	/^let debugLoc = false$/;"	v
debugVisit	cil/src/cil.ml	/^let debugVisit = false$/;"	v
debug_aliases	cil/src/ext/pta/golf.mli	/^val debug_aliases : bool ref$/;"	v
debug_aliases	cil/src/ext/pta/olf.mli	/^val debug_aliases : bool ref$/;"	v
debug_aliases	cil/src/ext/pta/ptranal.mli	/^val debug_aliases : bool ref$/;"	v
debug_constraints	cil/src/ext/pta/golf.mli	/^val debug_constraints : bool ref$/;"	v
debug_constraints	cil/src/ext/pta/olf.mli	/^val debug_constraints : bool ref$/;"	v
debug_constraints	cil/src/ext/pta/ptranal.mli	/^val debug_constraints : bool ref$/;"	v
debug_constraints	cil/src/ext/pta/steensgaard.mli	/^val debug_constraints : bool ref$/;"	v
debug_cycle	cil/src/ext/pta/steensgaard.ml	/^let debug_cycle (is_pos,c,l,p) =$/;"	v
debug_cycle_bounds	cil/src/ext/pta/steensgaard.ml	/^let debug_cycle_bounds is_pos c =$/;"	v
debug_may_aliases	cil/src/ext/pta/ptranal.mli	/^val debug_may_aliases : bool ref$/;"	v
decl_type	cil/src/frontc/cabs.ml	/^and decl_type =$/;"	t
deepHasAttribute	cil/src/ext/ciltools.ml	/^let deepHasAttribute s t =$/;"	v
deep_copy	cil/ocamlutil/growArray.mli	/^val deep_copy : 'a t -> ('a -> 'a) -> 'a t$/;"	v
defSpec	cil/obj/x86_LINUX/cparser.ml	/^                             let defSpec = [SpecType Tint] in$/;"	v
defaultCilPrinter	cil/src/cil.ml	/^let defaultCilPrinter = new defaultCilPrinterClass$/;"	v
defaultCilPrinterClass	cil/src/cil.ml	/^class defaultCilPrinterClass : cilPrinter = object (self)$/;"	c
defaultCilPrinterClass	cil/src/cil.mli	/^class defaultCilPrinterClass: cilPrinter$/;"	c
default_heapify	cil/src/ext/heapify.ml	/^let default_heapify (f : file) =$/;"	v
default_stackguard	cil/src/ext/heapify.ml	/^let default_stackguard (f : file) =$/;"	v
definition	cil/src/frontc/cabs.ml	/^and definition =$/;"	t
dependsOnMem	cil/src/ext/partial.ml	/^  let dependsOnMem = ref false$/;"	v
depids	cil/src/ext/partial.ml	/^    let depids = ref [] in$/;"	v
depth_first_search_pp	cil/src/ext/ssa.ml	/^  let rec depth_first_search_pp (x:int) =      $/;"	v
deref	cil/src/ext/pta/golf.mli	/^val deref : tau -> lvalue$/;"	v
deref	cil/src/ext/pta/olf.mli	/^val deref : tau -> lvalue$/;"	v
deref	cil/src/ext/pta/steensgaard.mli	/^val deref : tau -> lvalue$/;"	v
deref	cil/src/ext/pta/uref.ml	/^let deref p = $/;"	v
deref	cil/src/ext/pta/uref.mli	/^val deref: 'a uref -> 'a$/;"	v
derefFinderClass	cil/src/ext/predabst.ml	/^    class derefFinderClass vi br = object(self)$/;"	c
derefStarLevel	cil/src/cil.ml	/^let derefStarLevel = 20$/;"	v
descriptiveCilPrinter	cil/src/cil.ml	/^class type descriptiveCilPrinter = object$/;"	c
descriptiveCilPrinter	cil/src/cil.ml	/^let descriptiveCilPrinter: descriptiveCilPrinter = $/;"	v
descriptiveCilPrinterClass	cil/src/cil.ml	/^class descriptiveCilPrinterClass : descriptiveCilPrinter = object (self)$/;"	c
descriptiveCilPrinterClass	cil/src/cil.mli	/^class descriptiveCilPrinterClass : descriptiveCilPrinter$/;"	c
destinationFileName	cil/bin/patcher	/^sub destinationFileName {$/;"	s
destlv	cil/src/cil.ml	/^          let destlv = match stripCasts adest with $/;"	v
destt	cil/src/cil.ml	/^                (let destt = typeOfLval lv in$/;"	v
details'	cil/src/frontc/cabsvisit.ml	/^      let details' = match details with$/;"	v
dfInfo	cil/src/ext/ssa.mli	/^and dfInfo = (int list) array  (* dominance frontier *)$/;"	t
dfPlus	cil/src/ext/ssa.ml	/^  let dfPlus = Array.init nrRegs ($/;"	v
dfinish	cil/ocamlutil/pretty.ml	/^  let dfinish (dc: doc) : 'b = $/;"	v
diagnostic	cil/configure	/^diagnostic() {$/;"	f
diff	cil/src/ext/bitmap.ml	/^let diff b1 b2 = $/;"	v
diff	cil/src/ext/bitmap.mli	/^val  diff   : t -> t -> unit$/;"	v
diff	cil/src/ext/pta/setp.ml	/^    let rec diff s1 s2 =$/;"	v
dijkstra_bounded_shortest_paths	src/process_cfg/process_cfg.cc	/^void dijkstra_bounded_shortest_paths$/;"	f
discovered	cil/src/ext/pta/golf.ml	/^  let discovered : config_map = CH.create 16 in$/;"	v
dist_	src/run_crest/concolic_search.h	/^  vector<size_t> dist_;$/;"	m	class:crest::CfgHeuristicSearch
dl'	cil/src/frontc/cabsvisit.ml	/^      let dl' = mapNoCopyList (visitCabsDefinition vis) dl in$/;"	v
dld_link	cil/libstr/ltconfig	/^dld_link()$/;"	f
dlopen	cil/libstr/ltconfig	/^dlopen()$/;"	f
dlopen	cil/libstr/ltconfig	/^dlopen();$/;"	f
dn_attr	cil/src/cil.ml	/^let dn_attr      = (dn_obj d_attr)$/;"	v
dn_attrlist	cil/src/cil.ml	/^let dn_attrlist  = (dn_obj d_attrlist)$/;"	v
dn_attrparam	cil/src/cil.ml	/^let dn_attrparam = (dn_obj d_attrparam)$/;"	v
dn_exp	cil/src/cil.ml	/^let dn_exp       = (dn_obj d_exp)$/;"	v
dn_global	cil/src/cil.ml	/^let dn_global    = (dn_obj d_global)$/;"	v
dn_init	cil/src/cil.ml	/^let dn_init      = (dn_obj d_init)$/;"	v
dn_instr	cil/src/cil.ml	/^let dn_instr     = (dn_obj d_instr)$/;"	v
dn_lval	cil/src/cil.ml	/^let dn_lval      = (dn_obj d_lval)$/;"	v
dn_stmt	cil/src/cil.ml	/^let dn_stmt      = (dn_obj d_stmt)$/;"	v
dn_type	cil/src/cil.ml	/^let dn_type      = (dn_obj d_type)$/;"	v
doAttr	cil/obj/x86_LINUX/formatparse.ml	/^let doAttr (id: string) $/;"	v
doBlock	cil/src/ext/astslicer.ml	/^  let rec doBlock b base i default =$/;"	v
doCheck	cil/src/cilutil.ml	/^let doCheck= ref false   (* Whether to check CIL *)$/;"	v
doCollapseCallCast	cil/src/frontc/cabs2cil.mli	/^val doCollapseCallCast: bool ref$/;"	v
doCxxPP	cil/src/cilutil.ml	/^let doCxxPP = ref false$/;"	v
doEpicenter	cil/src/ext/epicenter.ml	/^let doEpicenter = ref false$/;"	v
doFeatureClass	cil/src/ext/liveness.ml	/^class doFeatureClass = object(self)$/;"	c
doFunctionDef	cil/obj/x86_LINUX/cparser.ml	/^let doFunctionDef (loc: cabsloc)$/;"	v
doGlobal	cil/src/ext/simplify.ml	/^let doGlobal = function $/;"	v
doGuard	cil/src/ext/predabst.ml	/^	let doGuard e ss = DF.GUse(handleBranch currentContext e ss)$/;"	v
doHeapify	cil/src/cilutil.ml	/^let doHeapify = ref false (* move stack-allocated arrays to the heap *)$/;"	v
doInstr	cil/src/ext/predabst.ml	/^	let doInstr i ss = DF.Default$/;"	v
doInstr	cil/src/ext/reachingdefs.ml	/^    let doInstr inst (_, s, iosh) =$/;"	v
doLocal	cil/src/check.ml	/^            let doLocal tctx v = $/;"	v
doMergeSynonyms	cil/src/mergecil.ml	/^let doMergeSynonyms $/;"	v
doOldParDecl	cil/obj/x86_LINUX/cparser.ml	/^let doOldParDecl (names: string list)$/;"	v
doOneEnumItem	cil/src/frontc/cabsvisit.ml	/^      let doOneEnumItem ((s, e, loc) as ei) =$/;"	v
doOneInit	cil/src/cil.ml	/^        let doOneInit ((o, i) as oi) = $/;"	v
doOneRet	cil/src/cilutil.ml	/^let doOneRet = ref false (* make a functions have at most one 'return' *)$/;"	v
doPartial	cil/src/cilutil.ml	/^let doPartial = ref false (* Whether to do partial evaluation and constant $/;"	v
doPrintProtos	cil/src/frontc/frontc.ml	/^let doPrintProtos : bool ref = ref false$/;"	v
doSimpleMem	cil/src/cilutil.ml	/^let doSimpleMem = ref false (* reduce complex memory expressions so that$/;"	v
doStackGuard	cil/src/cilutil.ml	/^let doStackGuard = ref false (* instrument function calls and returns to$/;"	v
doStmt	cil/src/ext/predabst.ml	/^	let doStmt stm ss = DF.SUse(handleStmt currentContext stm ss)$/;"	v
doStmt	cil/src/ext/reachingdefs.ml	/^    let doStmt stm (_, s, iosh) =$/;"	v
doTime	cil/src/ext/deadcodeelim.ml	/^let doTime = ref false$/;"	v
doVisit	cil/src/cil.ml	/^let doVisit (vis: cilVisitor)$/;"	v
doVisit	cil/src/frontc/cabsvisit.ml	/^let doVisit (vis: cabsVisitor)$/;"	v
do_feature_partial	cil/src/ext/partial.ml	/^let do_feature_partial f =$/;"	v
do_live_feature	cil/src/ext/liveness.ml	/^let do_live_feature (f:file) =$/;"	v
doattr	cil/src/cil.ml	/^  let doattr al = visitCilAttributes attrVisitor (doattr al) in$/;"	v
doc	cil/ocamlutil/pretty.ml	/^type doc = $/;"	t
doc	cil/ocamlutil/pretty.mli	/^type doc$/;"	t
docAlphaTable	cil/ocamlutil/alpha.ml	/^let docAlphaTable () (alphaTable: (string, 'a alphaTableData ref) H.t) = $/;"	v
docAlphaTable	cil/ocamlutil/alpha.mli	/^val docAlphaTable: unit -> $/;"	v
docArray	cil/ocamlutil/longarray.mli	/^val docArray : ?sep: Pretty.doc -> (int -> 'a -> Pretty.doc) ->$/;"	v
docArray	cil/ocamlutil/pretty.mli	/^val docArray: ?sep:doc -> (int -> 'a -> doc) -> unit -> 'a array -> doc$/;"	v	function:++
docCList	cil/ocamlutil/clist.ml	/^let docCList (sep: doc) (doone: 'a -> doc) () (dl: 'a clist) = $/;"	v
docCList	cil/ocamlutil/clist.mli	/^val docCList: $/;"	v
docHash	cil/ocamlutil/util.ml	/^let docHash ?(sep=chr ',') (one: 'a -> 'b -> doc) () (h: ('a, 'b) H.t) = $/;"	v
docHash	cil/ocamlutil/util.mli	/^val docHash : ?sep:Pretty.doc -> ('a -> 'b -> Pretty.doc) -> unit -> $/;"	v
docList	cil/ocamlutil/pretty.mli	/^val docList: ?sep:doc -> ('a -> doc) -> unit -> 'a list -> doc$/;"	v	function:++
docMap	cil/ocamlutil/pretty.ml	/^  let docMap ?(sep=chr ',')$/;"	v
docMap	cil/ocamlutil/pretty.mli	/^    val docMap: ?sep:doc -> (Map.key -> 'a -> doc) -> unit -> 'a Map.t -> doc$/;"	v
docOpt	cil/ocamlutil/pretty.ml	/^let docOpt delem () = function$/;"	v
docOpt	cil/ocamlutil/pretty.mli	/^val docOpt: ('a -> doc) -> unit -> 'a option -> doc$/;"	v	function:++
docSet	cil/ocamlutil/pretty.ml	/^  let docSet ?(sep=chr ',') (doit: Set.elt -> doc) () (set: Set.t) : doc =$/;"	v
docSet	cil/ocamlutil/pretty.mli	/^    val docSet: ?sep:doc -> (Set.elt -> doc) -> unit -> Set.t -> doc$/;"	v
doit	cil/lib/Cilly.pm	/^sub doit {$/;"	s
doit	cil/src/ext/sfi.ml	/^let doit (f: file) =$/;"	v
domTreeIter	cil/src/ext/dominators.ml	/^let rec domTreeIter (f: stmt -> unit) $/;"	v
domTreeIter	cil/src/ext/dominators.mli	/^val domTreeIter: (Cil.stmt -> unit) -> order -> tree -> unit$/;"	v
dominance_frontier	cil/src/ext/ssa.ml	/^let dominance_frontier (flowgraph: cfgInfo) : dfInfo = $/;"	v
dominates	cil/src/ext/dominators.mli	/^val dominates: Cil.stmt option Inthash.t -> Cil.stmt -> Cil.stmt -> bool$/;"	v
dontSplitLocals	cil/src/ext/simplify.ml	/^let dontSplitLocals : (string, bool) H.t = H.create 111$/;"	v
doubleType	cil/src/cil.ml	/^let doubleType = TFloat(FDouble, [])$/;"	v
doubleType	cil/src/cil.mli	/^val doubleType: typ$/;"	v
dprintf	cil/ocamlutil/pretty.ml	/^let dprintf format     = gprintf (fun x -> x) format$/;"	v
dprintf	cil/ocamlutil/pretty.mli	/^val dprintf: ('a, unit, doc, doc) format4 -> 'a  $/;"	v
dropAttribute	cil/src/cil.mli	/^val dropAttribute: string -> attributes -> attributes$/;"	v
dropAttributes	cil/src/cil.mli	/^val dropAttributes: string list -> attributes -> attributes$/;"	v
dropAttrsVisitor	cil/src/ext/dataslicing.ml	/^class dropAttrsVisitor = object$/;"	c
dropX	cil/src/ext/ssa.ml	/^        let rec dropX = function$/;"	v
dt'	cil/src/frontc/cabsvisit.ml	/^      let dt' = visitCabsDeclType vis false dt in$/;"	v
dt1'	cil/src/frontc/cabsvisit.ml	/^      let dt1' = visitCabsDeclType vis false dt1 in$/;"	v
dt1'	cil/src/frontc/cabsvisit.ml	/^      let dt1' = visitCabsDeclType vis isfundef dt1 in$/;"	v
dummyFile	cil/src/cil.mli	/^val dummyFile: file$/;"	v
dummyFunDec	cil/src/cil.mli	/^val dummyFunDec: fundec$/;"	v
dummyInstr	cil/src/cil.mli	/^val dummyInstr: instr$/;"	v
dummyStmt	cil/src/cil.mli	/^val dummyStmt: stmt$/;"	v
dumpArray	cil/src/cil.ml	/^    let dumpArray (bt: typ) (il: 'a list) (getelem: 'a -> init) = $/;"	v
dumpBlock	cil/src/cil.ml	/^let dumpBlock (pp: cilPrinter) (out: out_channel) (ind: int) (b: block) : unit = $/;"	v
dumpBlockingGraph	cil/src/ext/blockinggraph.ml	/^let dumpBlockingGraph () =$/;"	v
dumpFCG	cil/src/cilutil.ml	/^let dumpFCG = ref false$/;"	v
dumpGlobal	cil/src/cil.ml	/^let dumpGlobal (pp: cilPrinter) (out: out_channel) (g: global) : unit = $/;"	v
dumpGraph	cil/src/mergecil.ml	/^let dumpGraph (what: string) (eq: (int * string, 'a node) H.t) : unit = $/;"	v
dumpInit	cil/src/cil.ml	/^let dumpInit (pp: cilPrinter) (out: out_channel) (ind: int) (i: init) : unit = $/;"	v
dumpStmt	cil/src/cil.ml	/^let dumpStmt (pp: cilPrinter) (out: out_channel) (ind: int) (s: stmt) : unit = $/;"	v
dumpSymbols	cil/ocamlutil/util.ml	/^let dumpSymbols () = $/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                              let e = (fst _4) args in$/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                             let e = (fst _2) args in$/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                        let e = $/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                        let e = (fst _3) args in$/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                     let e = (fst _2) args in $/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                   let e = (fst _1) args in$/;"	v
e	cil/obj/x86_LINUX/formatparse.ml	/^                 let e = (fst _3) args in$/;"	v
e	cil/src/ext/predabst.ml	/^	let e = getPred ctxt pid in$/;"	v
e'	cil/src/cil.ml	/^        let e' = fExp e in $/;"	v
e'	cil/src/cil.ml	/^        let e' = fExp e in$/;"	v
e'	cil/src/cil.ml	/^      let e' = vExp e in$/;"	v
e'	cil/src/cil.ml	/^      let e' = visitCilExpr vis e in$/;"	v
e'	cil/src/ext/partial.ml	/^              let e' = S.evaluate state e in$/;"	v
e'	cil/src/frontc/cabsvisit.ml	/^      let e' = visitCabsExpression vis e in   $/;"	v
e'	cil/src/frontc/cabsvisit.ml	/^      let e' = visitCabsExpression vis e in$/;"	v
e'	cil/src/frontc/cabsvisit.ml	/^      let e'= visitCabsExpression vis e in$/;"	v
e1	cil/obj/x86_LINUX/formatparse.ml	/^                               let e1 = (fst _1) args in $/;"	v
e1	cil/src/ext/expcompare.ml	/^      let e1 = stripCastsDeepForPtrArith e1 in$/;"	v	value:stripCastsDeepForPtrArith
e1'	cil/src/cil.ml	/^      let e1' = vExp e1 in let e2' = vExp e2 in let t' = vTyp t in$/;"	v
e1'	cil/src/cil.ml	/^      let e1' = vExp e1 in let t' = vTyp t in$/;"	v
e1'	cil/src/cil.ml	/^      let e1' = vExp e1 in$/;"	v
e1'	cil/src/cil.ml	/^      let t' = vTyp t in let e1' = vExp e1 in$/;"	v
e1l	cil/src/ext/availexpslv.ml	/^    then let e1l = LvExpHash.find_all lvh' lv in$/;"	v
e1l'	cil/src/ext/availexpslv.ml	/^    let e1l' = List.filter (fun e -> not(compareExpStripCasts e e1)) e1l in$/;"	v
e2	cil/obj/x86_LINUX/formatparse.ml	/^                               let e2 = (fst _3) args in $/;"	v
e2	cil/src/ext/expcompare.ml	/^      let e2 = stripCastsDeepForPtrArith e2 in$/;"	v
e2'	cil/src/cil.ml	/^      let e1' = vExp e1 in let e2' = vExp e2 in let t' = vTyp t in$/;"	v
e2l	cil/src/ext/availexpslv.ml	/^    try let e2l = LvExpHash.find_all lvh2 lv in$/;"	v
eAlpha	cil/src/mergecil.ml	/^let eAlpha : (string, location A.alphaTableData ref) H.t $/;"	v
eEq	cil/src/mergecil.ml	/^let eEq: (int * string, enuminfo node) H.t = H.create 111 (* Enums *)$/;"	v
eSyn	cil/src/mergecil.ml	/^let eSyn: (string, enuminfo node) H.t = H.create 111$/;"	v
eattr	cil/src/cil.mli	/^    mutable eattr: attributes;         $/;"	r	type:enuminfo
ed	cil/src/cil.ml	/^          ++ (let ed = self#pExp () e in$/;"	v
edge_t	src/process_cfg/process_cfg.cc	/^typedef pair<int,int> edge_t;$/;"	t	file:
eh_handle_inst	cil/src/ext/availexps.ml	/^let eh_handle_inst i eh = $/;"	v
eh_kill_addrof_or_global	cil/src/ext/availexps.ml	/^let eh_kill_addrof_or_global eh =$/;"	v
eh_kill_lval	cil/src/ext/availexps.ml	/^let eh_kill_lval eh lv =$/;"	v
eh_kill_mem	cil/src/ext/availexps.ml	/^let eh_kill_mem eh =$/;"	v
eh_kill_vi	cil/src/ext/availexps.ml	/^let eh_kill_vi eh vi =$/;"	v
ei	cil/src/mergecil.ml	/^    let ei = einode.ndata in$/;"	v
ei'	cil/src/frontc/cabsvisit.ml	/^      let ei' = mapNoCopy doOneEnumItem ei in$/;"	v
einode	cil/src/mergecil.ml	/^  let einode    = getNode eEq eSyn fidx ei.ename ei None in$/;"	v
eitems	cil/src/cil.mli	/^    mutable eitems: (string * exp * location) list;$/;"	r	type:enuminfo
el_has_volatile	cil/src/ext/deadcodeelim.ml	/^let el_has_volatile =$/;"	v
elements	cil/src/ext/heap.ml	/^          elements  : (int * ('a option)) array ;$/;"	r	type:t
elements	cil/src/ext/pta/setp.ml	/^    let elements s =$/;"	v
elements_aux	cil/src/ext/pta/setp.ml	/^    let rec elements_aux accu = function$/;"	v
elim_dead_code	cil/src/ext/deadcodeelim.ml	/^let elim_dead_code (fd : fundec) :  fundec =$/;"	v
elim_dead_code_fp	cil/src/ext/deadcodeelim.ml	/^let elim_dead_code_fp (fd : fundec) :  fundec =$/;"	v
emitDoc	cil/ocamlutil/pretty.ml	/^let emitDoc $/;"	v
emitIt	cil/src/mergecil.ml	/^          let emitIt:bool = (not mergeGlobals) ||$/;"	v
emittedCompDecls	cil/src/mergecil.ml	/^let emittedCompDecls: (string, bool) H.t = H.create 113$/;"	v
emittedFunDefn	cil/src/mergecil.ml	/^let emittedFunDefn: (string, fundec * location * int) H.t = H.create 113$/;"	v
emittedVarDecls	cil/src/mergecil.ml	/^let emittedVarDecls: (string, bool) H.t = H.create 113$/;"	v
emittedVarDefn	cil/src/mergecil.ml	/^let emittedVarDefn: (string, varinfo * init option * location) H.t = H.create 113$/;"	v
empty	cil/ocamlutil/clist.ml	/^let empty = CList []$/;"	v
empty	cil/ocamlutil/clist.mli	/^val empty: 'a clist               $/;"	v
empty	cil/ocamlutil/intmap.ml	/^let empty = Empty$/;"	v
empty	cil/ocamlutil/intmap.mli	/^val empty: 'a t$/;"	v
empty	cil/src/ext/bitmap.ml	/^let empty b = emptyInt b 0$/;"	v
empty	cil/src/ext/bitmap.mli	/^val  empty  : t -> bool$/;"	v
empty	cil/src/ext/partial.ml	/^  let empty = IntMap.empty$/;"	v
empty	cil/src/ext/pta/setp.ml	/^    let empty = Empty$/;"	v
emptyFunction	cil/src/cil.ml	/^let emptyFunction name = $/;"	v
emptyFunction	cil/src/cil.mli	/^val emptyFunction: string -> fundec$/;"	v
emptyInt	cil/src/ext/bitmap.ml	/^let emptyInt b start = $/;"	v
enabled	cil/src/frontc/whitetrack.ml	/^let enabled = ref false$/;"	v
enabled	cil/src/frontc/whitetrack.mli	/^val enabled : bool ref$/;"	v
ename	cil/src/cil.mli	/^    mutable ename: string;              $/;"	r	type:enuminfo
enclosing_type	cil/src/ext/sfi.ml	/^    let enclosing_type = TComp(bf.fcomp, []) in $/;"	v
endEnv	cil/src/check.ml	/^let endEnv () = $/;"	v
endPt	cil/src/ext/blockinggraph.ml	/^let endPt = { id = 0; point = mkEmptyStmt (); callfun = "end"; infun = "end";$/;"	v
enlarge	cil/src/ext/bitmap.ml	/^let enlarge b newWords = $/;"	v
enqueue	cil/src/ext/partial.ml	/^          let enqueue caller callee state =$/;"	v
enterAlign	cil/ocamlutil/pretty.ml	/^let enterAlign () = $/;"	v
enum:partial-const-func	cil/doc/cil.html	/^<\/LI><LI CLASS="li-enumerate"><A NAME="enum:partial-const-func"><\/A> functions that return a$/;"	a
enum:partial-const-func	cil/doc/ext.html	/^<\/LI><LI CLASS="li-enumerate"><A NAME="enum:partial-const-func"><\/A> functions that return a$/;"	a
enum:partial-empty-proc	cil/doc/cil.html	/^<A NAME="enum:partial-empty-proc"><\/A> empty functions and$/;"	a
enum:partial-empty-proc	cil/doc/ext.html	/^<A NAME="enum:partial-empty-proc"><\/A> empty functions and$/;"	a
enum_item	cil/src/frontc/cabs.ml	/^and enum_item = string * expression * cabsloc$/;"	t
enumeration	cil/ocamlutil/intmap.ml	/^type 'a enumeration = End | More of int * 'a * 'a t * 'a enumeration$/;"	t
enuminfo	cil/src/cil.mli	/^and enuminfo = {$/;"	t
eoc	cil/src/ext/pta/steensgaard.ml	/^let eoc (t,t') : bool =$/;"	v
epicenterHops	cil/src/ext/epicenter.ml	/^let epicenterHops = ref 0$/;"	v
epicenterName	cil/src/ext/epicenter.ml	/^let epicenterName = ref ""$/;"	v
epoints_to	cil/src/ext/pta/golf.ml	/^let epoints_to (t : tau) : Cil.varinfo list =$/;"	v
epoints_to	cil/src/ext/pta/golf.mli	/^val epoints_to : tau -> Cil.varinfo list$/;"	v
epoints_to	cil/src/ext/pta/olf.ml	/^let epoints_to (t : tau) : Cil.varinfo list =$/;"	v
epoints_to	cil/src/ext/pta/olf.mli	/^val epoints_to : tau -> Cil.varinfo list   $/;"	v
eprintf	cil/ocamlutil/pretty.ml	/^let eprintf format = fprintf stderr format$/;"	v
eprintf	cil/ocamlutil/pretty.mli	/^val eprintf: ('a, unit, doc) format -> 'a $/;"	v
equal	cil/ocamlutil/intmap.ml	/^let equal cmp m1 m2 =$/;"	v
equal	cil/ocamlutil/intmap.mli	/^val equal: ('a -> 'a -> bool) -> 'a t -> 'a t -> bool$/;"	v
equal	cil/src/ext/bitmap.ml	/^let equal b1 b2 =$/;"	v
equal	cil/src/ext/bitmap.mli	/^val  equal  : t -> t -> bool$/;"	v
equal	cil/src/ext/partial.ml	/^  let equal t1 t2 = (compare t1 t2 = 0) (* use OCAML here *)$/;"	v
equal	cil/src/ext/pta/setp.ml	/^    let equal s1 s2 =$/;"	v
equal	cil/src/ext/pta/uref.ml	/^let equal (p,p') = (find p == find p')$/;"	v
equal	cil/src/ext/pta/uref.mli	/^val equal: 'a uref * 'a uref -> bool$/;"	v
equalInits	cil/src/mergecil.ml	/^let rec equalInits (x: init) (y: init) : bool =$/;"	v
equalOffsets	cil/src/mergecil.ml	/^and equalOffsets (x: offset) (y: offset) : bool =$/;"	v
equal_absloc	cil/src/ext/pta/olf.ml	/^let equal_absloc = function$/;"	v
equal_c_absloc	cil/src/ext/pta/olf.ml	/^let equal_c_absloc l l' =$/;"	v
equal_tau	cil/src/ext/pta/golf.ml	/^let equal_tau (t : tau) (t' : tau) =$/;"	v
equal_tau	cil/src/ext/pta/olf.ml	/^let equal_tau (t : tau) (t' : tau) =$/;"	v
equals	cil/ocamlutil/util.ml	/^let equals x1 x2 : bool =$/;"	v
equals	cil/ocamlutil/util.mli	/^val equals: 'a -> 'a -> bool$/;"	v
ereferenced	cil/src/cil.mli	/^    mutable ereferenced: bool;         $/;"	r	type:enuminfo
err	cil/src/testcil.ml	/^    let err = Sys.command command in$/;"	v
error	cil/obj/x86_LINUX/clexer.ml	/^let error msg =$/;"	v
error	cil/ocamlutil/errormsg.ml	/^let error (fmt : ('a,unit,doc,unit) format4) : 'a = $/;"	v
error	cil/ocamlutil/errormsg.mli	/^val error:         ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
errorContext	cil/ocamlutil/errormsg.ml	/^let errorContext = ref []$/;"	v
errorLoc	cil/src/cil.ml	/^let errorLoc (loc: location) (fmt : ('a,unit,doc) format) : 'a = $/;"	v
escape_char	cil/src/escape.ml	/^let escape_char = function$/;"	v
escape_char	cil/src/escape.mli	/^val escape_char : char -> string$/;"	v
escape_string	cil/src/escape.ml	/^let escape_string str =$/;"	v
escape_string	cil/src/escape.mli	/^val escape_string : string -> string$/;"	v
escape_wchar	cil/src/escape.ml	/^let escape_wchar =$/;"	v
escape_wchar	cil/src/escape.mli	/^val escape_wchar : wchar -> string$/;"	v
escape_wstring	cil/src/escape.ml	/^let escape_wstring (str : int64 list) =$/;"	v
escape_wstring	cil/src/escape.mli	/^val escape_wstring : wstring -> string$/;"	v
et	cil/src/check.ml	/^          let et = checkExp isconst e in$/;"	v
eval	cil/src/ext/partial.ml	/^  let eval r e =$/;"	v
eval	cil/src/ext/ssa.ml	/^  let eval v =$/;"	v
evaluate	cil/src/ext/partial.ml	/^  let evaluate r e =$/;"	v
ex_	src/base/symbolic_interpreter.h	/^  SymbolicExecution ex_;$/;"	m	class:crest::SymbolicInterpreter
ex_	src/run_crest/concolic_search.h	/^  SymbolicExecution ex_;$/;"	m	class:crest::RandomInputSearch
ex_	src/run_crest/concolic_search.h	/^  SymbolicExecution ex_;$/;"	m	class:crest::RandomSearch
examine_max	cil/src/ext/heap.ml	/^let examine_max heap = $/;"	v
exec_prefix	cil/Makefile	/^exec_prefix = ${prefix}$/;"	m
execution	src/base/symbolic_interpreter.h	/^  const SymbolicExecution& execution() const { return ex_; }$/;"	f	class:crest::SymbolicInterpreter
exists	cil/src/ext/pta/setp.ml	/^    let rec exists p = function$/;"	v
existsAction	cil/src/cil.ml	/^type existsAction = $/;"	t
existsAction	cil/src/cil.mli	/^type existsAction = $/;"	t
existsType	cil/src/cil.ml	/^let existsType (f: typ -> existsAction) (t: typ) : bool = $/;"	v
existsType	cil/src/cil.mli	/^val existsType: (typ -> existsAction) -> typ -> bool$/;"	v
exitAlign	cil/ocamlutil/pretty.ml	/^let exitAlign () = $/;"	v
exp	cil/src/cil.mli	/^and exp =$/;"	t
expContainsDeref	cil/src/ext/predabst.ml	/^    let expContainsDeref e vi =$/;"	v
expContainsGlobal	cil/src/ext/predabst.ml	/^    let expContainsGlobal e =$/;"	v
expContainsVi	cil/src/ext/predabst.ml	/^    let expContainsVi e vi =$/;"	v
expHasAlias	cil/src/ext/predabst.ml	/^    let expHasAlias e ae =$/;"	v
expToAttrParam	cil/src/cil.ml	/^let rec expToAttrParam (e: exp) : attrparam = $/;"	v
expToAttrParam	cil/src/cil.mli	/^val expToAttrParam: exp -> attrparam$/;"	v
exp_has_lval	cil/src/ext/availexps.ml	/^let exp_has_lval lv e =$/;"	v
exp_has_lval	cil/src/ext/availexpslv.ml	/^let exp_has_lval lv e =$/;"	v
exp_has_mem_read	cil/src/ext/availexps.ml	/^let exp_has_mem_read e =$/;"	v
exp_has_mem_read	cil/src/ext/availexpslv.ml	/^let exp_has_mem_read e =$/;"	v
exp_has_vi	cil/src/ext/availexps.ml	/^let exp_has_vi vi e =$/;"	v
exp_has_vi	cil/src/ext/availexpslv.ml	/^let exp_has_vi vi e =$/;"	v
exp_has_volatile	cil/src/ext/deadcodeelim.ml	/^let exp_has_volatile e = $/;"	v
exp_is_volatile	cil/src/ext/availexps.ml	/^let exp_is_volatile e : bool =$/;"	v
exp_is_volatile	cil/src/ext/availexpslv.ml	/^let exp_is_volatile e : bool =$/;"	v
expandLibraries	cil/lib/Cilly.pm	/^sub expandLibraries {$/;"	s
explodeStringToInts	cil/src/frontc/cabshelper.ml	/^let explodeStringToInts (s: string) : int64 list =  $/;"	v
expr	src/base/symbolic_interpreter.h	/^    SymbolicExpr* expr;  \/\/ NULL to indicate concrete.$/;"	m	struct:crest::SymbolicInterpreter::StackElem
expr	src/base/symbolic_predicate.h	/^  const SymbolicExpr& expr() const { return *expr_; }$/;"	f	class:crest::SymbolicPred
exprTransformer	cil/src/frontc/patch.ml	/^class exprTransformer (srcpattern : expression) (destpattern : expression)$/;"	c
expr_	src/base/symbolic_predicate.h	/^  SymbolicExpr* expr_;$/;"	m	class:crest::SymbolicPred
expression	cil/obj/x86_LINUX/formatparse.mli	/^val expression :$/;"	v
expression	cil/src/frontc/cabs.ml	/^and expression =$/;"	t
extractPatternVar	cil/src/frontc/patch.ml	/^let extractPatternVar (s : string) : string =$/;"	v
extract_max	cil/src/ext/heap.ml	/^let extract_max heap = begin$/;"	v
extract_ptlabel	cil/src/ext/pta/golf.ml	/^let extract_ptlabel (lv : lvalue) : label option =$/;"	v
f	cil/src/ext/crestInstrument.ml	/^      let f = open_append "branches" in$/;"	v
f	cil/src/ext/pta/golf.ml	/^  let f = proj_fun t in$/;"	v
f	test/cfg_test.c	/^void f(int a) {$/;"	f
f'	cil/src/cil.ml	/^      let f' = fExp f in let args' = mapNoCopy fExp args in$/;"	v
f0	cil/ocamlutil/pretty.ml	/^    let f0 = doit 0 elements.(0) in$/;"	v
f1	cil/test/small1/init.c	/^  } f1;$/;"	m	struct:__anon1	typeref:struct:__anon1::__anon2	file:
f1	cil/test/small1/init1.c	/^    int *f1;$/;"	m	struct:__anon7::__anon8	file:
f2	cil/test/small1/init1.c	/^    int *f2;$/;"	m	struct:__anon7::__anon8	file:
f3	cil/test/small1/init1.c	/^    int *f3;$/;"	m	struct:__anon7::__anon9	file:
f_int32	cil/ocamlutil/pretty.ml	/^let f_int32 () i = d_int32 i$/;"	v
f_int32	cil/ocamlutil/pretty.mli	/^val f_int32: unit -> int32 -> doc$/;"	v	function:++
f_int64	cil/ocamlutil/pretty.ml	/^let f_int64 () i = d_int64 i$/;"	v
f_int64	cil/ocamlutil/pretty.mli	/^val f_int64: unit -> int64 -> doc$/;"	v	function:++
fail	cil/ocamlutil/errormsg.ml	/^let fail format = Pretty.gprintf (fun x -> Pretty.fprint stderr 80 x; $/;"	v
failed	cil/src/main.ml	/^let failed = ref false $/;"	v
fasBlock	cil/src/ext/cfg.ml	1;"	M
fastMode	cil/ocamlutil/pretty.ml	/^let fastMode       = ref false$/;"	v
fastMode	cil/ocamlutil/pretty.mli	/^val fastMode  : bool ref $/;"	v
fattr	cil/src/cil.mli	/^    mutable fattr: attributes;          $/;"	r	type:fieldinfo
fbitfield	cil/src/cil.mli	/^    mutable fbitfield: int option;      $/;"	r	type:fieldinfo
fcomp	cil/src/cil.mli	/^    mutable fcomp: compinfo;            $/;"	r	type:fieldinfo
fd	cil/src/ext/partial.ml	/^          fd       : Cil.fundec;$/;"	r	type:callGraphNode
fd'	cil/src/ext/deadcodeelim.ml	/^  let fd' = time "useless-elim" (visitCilFunction (new uselessInstrElim)) fd in$/;"	v
fd_description	cil/src/cil.mli	/^    fd_description: string; $/;"	r	type:featureDescr
fd_doit	cil/src/cil.mli	/^    fd_doit: (file -> unit);$/;"	r	type:featureDescr
fd_enabled	cil/src/cil.mli	/^    fd_enabled: bool ref; $/;"	r	type:featureDescr
fd_extraopt	cil/src/cil.mli	/^    fd_extraopt: (string * Arg.spec * string) list; $/;"	r	type:featureDescr
fd_name	cil/src/cil.mli	/^    fd_name: string; $/;"	r	type:featureDescr
fd_post_check	cil/src/cil.mli	/^    fd_post_check: bool; $/;"	r	type:featureDescr
fdec	cil/obj/x86_LINUX/cparser.ml	/^                             let fdec = $/;"	v
fdec	cil/obj/x86_LINUX/cparser.ml	/^                             let fdec = (fst _1,$/;"	v
fdec'	cil/src/mergecil.ml	/^          let fdec' = $/;"	v
feature	cil/src/ext/blockinggraph.mli	/^val feature: Cil.featureDescr$/;"	v
feature	cil/src/ext/callgraph.mli	/^val feature: Cil.featureDescr$/;"	v
feature	cil/src/ext/canonicalize.mli	/^val feature: Cil.featureDescr$/;"	v
feature	cil/src/ext/crestInstrument.ml	/^let feature : featureDescr =$/;"	v
feature	cil/src/ext/dataslicing.ml	/^let feature : featureDescr = $/;"	v
feature	cil/src/ext/dataslicing.mli	/^val feature: Cil.featureDescr$/;"	v
feature	cil/src/ext/epicenter.ml	/^let feature : featureDescr = $/;"	v
feature	cil/src/ext/liveness.ml	/^let feature =$/;"	v
feature	cil/src/ext/logcalls.ml	/^let feature : featureDescr = $/;"	v
feature	cil/src/ext/logcalls.mli	/^val feature: Cil.featureDescr$/;"	v
feature	cil/src/ext/logwrites.ml	/^let feature : featureDescr = $/;"	v
feature	cil/src/ext/oneret.mli	/^val feature : Cil.featureDescr $/;"	v
feature	cil/src/ext/partial.ml	/^let feature : featureDescr = {$/;"	v
feature	cil/src/ext/pta/ptranal.ml	/^let feature : featureDescr = {$/;"	v
feature	cil/src/ext/pta/ptranal.mli	/^val feature: Cil.featureDescr$/;"	v
feature	cil/src/ext/simplemem.ml	/^let feature : featureDescr = $/;"	v
feature	cil/src/ext/simplify.ml	/^let feature : featureDescr = $/;"	v
featureDescr	cil/src/cil.mli	/^type featureDescr = {$/;"	t
features	cil/obj/x86_LINUX/feature_config.ml	/^let features : featureDescr list = [$/;"	v
fetchNextArg	cil/lib/Cilly.pm	/^sub fetchNextArg {$/;"	s
fetch_constraint	cil/src/ext/pta/steensgaard.ml	/^and fetch_constraint () : su_constraint option =$/;"	v
fg'	cil/src/frontc/cabsvisit.ml	/^      let fg' = mapNoCopy childrenFieldGroup fg in$/;"	v
fget	cil/ocamlutil/pretty.ml	/^  let fget    = String.unsafe_get format in$/;"	v
fi	cil/obj/x86_LINUX/formatparse.ml	/^                                let fi = getField t _2 in$/;"	v
fi	cil/obj/x86_LINUX/formatparse.ml	/^                   let fi = getField baset _3 in$/;"	v
fi	cil/src/ext/pta/golf.ml	/^  let fi,ret =$/;"	v
fi	cil/src/ext/pta/olf.ml	/^  let fi, ret =$/;"	v
fidType	cil/src/ext/crestInstrument.ml	/^let fidType  = uintType$/;"	v
fidx	cil/src/mergecil.ml	/^    let fidx = cinode.nfidx in$/;"	v
fidx	cil/src/mergecil.ml	/^    let fidx = tnode.nfidx in$/;"	v
field_group	cil/src/frontc/cabs.ml	/^and field_group = specifier * (name * expression option) list$/;"	t
fieldinfo	cil/src/cil.mli	/^and fieldinfo = { $/;"	t
file	cil/obj/x86_LINUX/cparser.mli	/^val file :$/;"	v
file	cil/ocamlutil/errormsg.ml	/^    { file: string; (** The file name *)$/;"	r	type:location
file	cil/ocamlutil/errormsg.mli	/^    { file: string; (** The file name *)$/;"	r	type:location
file	cil/src/cil.mli	/^    file: string;          (** The name of the source file*)$/;"	r	type:location
file	cil/src/cil.mli	/^type file = $/;"	t
file	cil/src/frontc/cabs.ml	/^and file = string * definition list$/;"	t
file	cil/src/frontc/cprint.ml	/^type loc = { line : int; file : string }$/;"	r	type:loc
file	cil/src/testcil.ml	/^  let file = $/;"	v
fileName	cil/src/cil.mli	/^    { mutable fileName: string;   (** The complete file name *)$/;"	r	type:file
fileNames	cil/src/ciloptions.mli	/^val fileNames : string list ref$/;"	v
fileNames	cil/src/mergecil.ml	/^let fileNames : (int, string) H.t = H.create 113$/;"	v
filename	cil/lib/OutputFile.pm	/^sub filename {$/;"	s
filename	cil/src/frontc/cabs.ml	/^ filename: string;$/;"	r	type:cabsloc
files	cil/src/main.ml	/^      let files = List.map parseOneFile !Ciloptions.fileNames in$/;"	v
fill	cil/ocamlutil/growArray.mli	/^type 'a fill =$/;"	t
fill	cil/ocamlutil/longarray.mli	/^val fill : 'a t -> int -> int -> 'a -> unit$/;"	v
fillOneIdom	cil/src/ext/dominators.ml	/^        let rec fillOneIdom (s: stmt) = $/;"	v
filter	cil/src/ext/deadcodeelim.ml	/^    let filter il stmdat =$/;"	v
filter	cil/src/ext/pta/setp.ml	/^    let filter p s =$/;"	v
filterAttributes	cil/src/cil.mli	/^val filterAttributes: string -> attributes -> attributes$/;"	v
filterNoCopy	cil/ocamlutil/util.mli	/^val filterNoCopy: ('a -> bool) -> 'a list -> 'a list$/;"	v
filterStmt	cil/src/ext/predabst.ml	/^	let filterStmt stm = true$/;"	v
filterStmt	cil/src/ext/reachingdefs.ml	/^    let filterStmt stm = true$/;"	v
filter_match	cil/src/ext/pta/golf.ml	/^  let rec filter_match (i : int) =$/;"	v
final_r	cil/src/ext/partial.ml	/^    let final_r =$/;"	v
finalwhite	cil/src/frontc/whitetrack.ml	/^let finalwhite = ref "\\n"    $/;"	v
find	cil/ocamlutil/growArray.ml	/^let find (ga: 'a t) (fn: 'a -> bool) : int option = $/;"	v
find	cil/ocamlutil/growArray.mli	/^val find: 'a t -> ('a -> bool) -> int option$/;"	v
find	cil/ocamlutil/inthash.ml	/^let find h key =$/;"	v
find	cil/ocamlutil/inthash.mli	/^val find: 'a t -> int -> 'a$/;"	v
find	cil/ocamlutil/intmap.ml	/^let rec find x = function$/;"	v
find	cil/ocamlutil/intmap.mli	/^val find: int -> 'a t -> 'a$/;"	v
find	cil/src/ext/pta/uref.ml	/^let rec find p = $/;"	v
findCallsVisitor	cil/src/ext/blockinggraph.ml	/^class findCallsVisitor (host: node) : cilVisitor = object$/;"	c
findCase	cil/src/check.ml	/^              let rec findCase = function$/;"	v
findCheckPlacement	cil/src/ext/stackoverflow.ml	/^let findCheckPlacement () = $/;"	v
findCompilerVersion	cil/bin/patcher	/^sub findCompilerVersion {$/;"	s
findConfigurationBool	cil/ocamlutil/util.ml	/^let findConfigurationBool (key: string) : bool = $/;"	v
findConfigurationList	cil/ocamlutil/util.ml	/^let findConfigurationList (key: string) : configData list  = $/;"	v
findConfigurationString	cil/ocamlutil/util.ml	/^let findConfigurationString (key: string) : string = $/;"	v
findIkindName	cil/src/cil.ml	/^    let findIkindName (name: string) : ikind = $/;"	v
findIkindSz	cil/src/cil.ml	/^    let findIkindSz (unsigned: bool) (sz: int) : ikind = $/;"	v
findNaturalLoops	cil/src/ext/dominators.mli	/^val findNaturalLoops: Cil.fundec -> $/;"	v
findOrAdd	cil/ocamlutil/util.ml	/^let findOrAdd h arg f = memoize h arg f$/;"	v
findOrAdd	cil/ocamlutil/util.mli	/^val findOrAdd: ('a, 'b) Hashtbl.t ->$/;"	v
findOrCreateFunc	cil/src/cil.ml	/^let findOrCreateFunc (f:file) (name:string) (t:typ) : varinfo = $/;"	v
findOrCreateFunc	cil/src/cil.mli	/^val findOrCreateFunc: file -> string -> typ -> varinfo$/;"	v
findReplacement	cil/src/mergecil.ml	/^let findReplacement$/;"	v
findReturn	cil/src/ext/predabst.ml	/^    let findReturn (fd:fundec) =$/;"	v
findVarsCantSplit	cil/src/ext/simplify.ml	/^let findVarsCantSplit = new findVarsCantSplitClass$/;"	v
findVarsCantSplitClass	cil/src/ext/simplify.ml	/^class findVarsCantSplitClass : cilVisitor = object (self) $/;"	c
find_all	cil/ocamlutil/inthash.ml	/^let find_all h key =$/;"	v
find_all	cil/ocamlutil/inthash.mli	/^val find_all: 'a t -> int -> 'a list$/;"	v
find_rec	cil/ocamlutil/inthash.ml	/^let rec find_rec key = function$/;"	v
find_stmts	cil/src/ext/dataflow.ml	/^let find_stmts (fdec:fundec) : (stmt list * stmt list) =$/;"	v
find_stmts	cil/src/ext/dataflow.mli	/^val find_stmts: Cil.fundec -> (Cil.stmt list * Cil.stmt list)$/;"	v
fingerprintSet	cil/src/ext/blockinggraph.ml	/^            let fingerprintSet =$/;"	v
fingerprintSet	cil/src/ext/blockinggraph.ml	/^        let fingerprintSet =$/;"	v
finish	cil/obj/x86_LINUX/clexer.ml	/^let finish () = $/;"	v
finish	cil/obj/x86_LINUX/clexer.mli	/^val finish: unit -> unit$/;"	v
finish	cil/src/frontc/clexer.mli	/^val finish: unit -> unit$/;"	v
finishArgs	cil/src/ext/simplify.ml	/^          let finishArgs = function$/;"	v
finishParsing	cil/ocamlutil/errormsg.mli	/^val finishParsing: unit -> unit (* Call this function to finish parsing and $/;"	v
finished	cil/src/ext/astslicer.ml	/^let finished = ref true (* set to false if we update something *)$/;"	v
finished	cil/src/ext/partial.ml	/^          let finished = ref false in$/;"	v
finished_constraints	cil/src/ext/pta/golf.ml	/^let finished_constraints () = ()$/;"	v
finished_constraints	cil/src/ext/pta/golf.mli	/^val finished_constraints : unit -> unit (* only for compatability with Olf *)$/;"	v
finished_constraints	cil/src/ext/pta/olf.mli	/^val finished_constraints : unit -> unit$/;"	v
firstData	cil/src/ext/predabst.ml	/^	  let firstData = makeAllBottom currentContext.cPredicates in$/;"	v
firstFree	cil/src/cil.ml	/^      let firstFree      = addTrailing firstFree ftypeAlign in$/;"	v
firstFree	cil/src/cil.ml	/^      let firstFree      = addTrailing sofar.oaFirstFree ftypeAlign in$/;"	v
firstFree	cil/src/cil.ml	/^      let firstFree      = sofar.oaFirstFree in$/;"	v
firstFree	cil/src/cil.ml	/^      let firstFree     = addTrailing sofar.oaFirstFree ftypeAlign in$/;"	v
firstFree	cil/src/cil.ml	/^      let firstFree = $/;"	v
firstFree	cil/src/cil.ml	/^      let firstFree = addTrailing sofar.oaFirstFree ftypeAlign  in$/;"	v
first_stm	cil/src/ext/predabst.ml	/^	  let first_stm = List.hd slst in$/;"	v
first_value	cil/ocamlutil/perfcount.c	/^unsigned static longlong first_value;$/;"	v	file:
fits_byte	cil/src/escape.ml	/^  let fits_byte = limit (Int64.of_int 0x100) in$/;"	v
fits_octal_escape	cil/src/escape.ml	/^  let fits_octal_escape = limit (Int64.of_int 0o1000) in$/;"	v
fits_universal_4	cil/src/escape.ml	/^  let fits_universal_4 = limit (Int64.of_int 0x10000) in$/;"	v
fits_universal_8	cil/src/escape.ml	/^  let fits_universal_8 = limit (Int64.of_string "0x100000000") in$/;"	v
fixForExternCall	cil/src/ext/predabst.ml	/^    let fixForExternCall (ctxt : context)$/;"	v
fixupCsources	cil/lib/Cilly.pm	/^sub fixupCsources {$/;"	s
fkind	cil/src/cil.mli	/^and fkind = $/;"	t
flen	cil/ocamlutil/pretty.ml	/^  let flen    = String.length format in$/;"	v
floatRegexp	cil/ocamlutil/util.ml	/^let floatRegexp = Str.regexp "f\\\\([0-9]+\\\\.[0-9]+\\\\);"$/;"	v
floatType	cil/src/cil.ml	/^  let floatType = TFloat(FFloat, []) in$/;"	v
floc	cil/src/cil.mli	/^    mutable floc: location;$/;"	r	type:fieldinfo
flow	cil/src/ext/pta/steensgaard.ml	/^let rec flow (is_pos : bool) (path : label list) (l : label) : label boundset =$/;"	v
flushOften	cil/ocamlutil/pretty.ml	/^let flushOften = ref false$/;"	v
flushOften	cil/ocamlutil/pretty.mli	/^val flushOften   : bool ref  (** If true the it flushes after every print *)$/;"	v
fn	cil/obj/x86_LINUX/formatparse.ml	/^                        let (fn, ft, _) = (fst _3) ts args in$/;"	v
fn'	cil/src/cil.ml	/^      let lv' = fLval lv in let fn' = fExp fn in $/;"	v
fname	cil/src/check.ml	/^      let fname = vi.vname in$/;"	v
fname	cil/src/cil.mli	/^    mutable fname: string;              $/;"	r	type:fieldinfo
fnord	cil/libstr/ltconfig	/^fnord() { int i=42;}$/;"	f
fnres	cil/src/ext/pta/ptranal.ml	/^          let fnres, site =$/;"	v
fold	cil/ocamlutil/inthash.ml	/^let fold (f: int -> 'a -> 'b -> 'b) (h: 'a t) (init: 'b) =$/;"	v
fold	cil/ocamlutil/inthash.mli	/^val fold: (int -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b$/;"	v
fold	cil/ocamlutil/intmap.ml	/^let rec fold f m accu =$/;"	v
fold	cil/ocamlutil/intmap.mli	/^val fold: (int -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b$/;"	v
fold	cil/src/ext/bitmap.ml	/^let fold f bmp arg =$/;"	v
fold	cil/src/ext/bitmap.mli	/^val  fold   : ('a -> int -> 'a) -> t -> 'a -> 'a $/;"	v
fold	cil/src/ext/pta/setp.ml	/^    let rec fold f s accu =$/;"	v
foldGlobals	cil/src/cil.mli	/^val foldGlobals: file -> ('a -> global -> 'a) -> 'a -> 'a$/;"	v
foldLeftCompound	cil/src/cil.ml	/^let foldLeftCompound$/;"	v
foldLeftCompound	cil/src/cil.mli	/^val foldLeftCompound: $/;"	v
fold_for	cil/ocamlutil/util.mli	/^val fold_for : init:'a -> lo:int -> hi:int -> (int -> 'a -> 'a) -> 'a$/;"	v
fold_left	cil/ocamlutil/clist.ml	/^let fold_left (f: 'acc -> 'a -> 'acc) (start: 'acc) (l: 'a clist) = $/;"	v
fold_left	cil/ocamlutil/clist.mli	/^val fold_left: ('acc -> 'a -> 'acc) -> 'acc -> 'a clist -> 'acc$/;"	v
fold_left	cil/ocamlutil/growArray.ml	/^let fold_left (f: 'acc -> 'a -> 'acc) (acc: 'acc) (ga: 'a t) : 'acc = $/;"	v
fold_left	cil/ocamlutil/growArray.mli	/^val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a$/;"	v
fold_lefti	cil/ocamlutil/growArray.ml	/^let fold_lefti (f: 'acc -> int -> 'a -> 'acc) (acc: 'acc) (ga: 'a t) : 'acc = $/;"	v
fold_lefti	cil/ocamlutil/growArray.mli	/^val fold_lefti : ('a -> int -> 'b -> 'a) -> 'a -> 'b t -> 'a$/;"	v
fold_right	cil/ocamlutil/growArray.ml	/^let fold_right (f: 'a -> 'acc -> 'acc) (ga: 'a t) (acc: 'acc) : 'acc = $/;"	v
fold_right	cil/ocamlutil/growArray.mli	/^val fold_right : ('b -> 'a -> 'a) -> 'b t -> 'a -> 'a$/;"	v
folded	cil/src/ext/availexps.ml	/^  let folded = List.fold_left proc_one [eh] il in$/;"	v
folded	cil/src/ext/reachingdefs.ml	/^  let folded = List.fold_left proc_one [((),s,iosh)] il in$/;"	v
foldednotout	cil/src/ext/availexps.ml	/^  let foldednotout = List.rev (List.tl folded) in$/;"	v
foldednotout	cil/src/ext/reachingdefs.ml	/^  let foldednotout = List.rev (List.tl folded) in$/;"	v
foldedout	cil/src/ext/reachingdefs.ml	/^  let foldedout = List.tl (List.rev folded) in$/;"	v
foo	cil/test/small1/func.c	/^int foo(int (*bar)(int), int n) {$/;"	f
foo	test/structure_test.c	/^struct foo {$/;"	s	file:
for_all	cil/src/ext/pta/setp.ml	/^    let rec for_all p = function$/;"	v
for_clause	cil/src/frontc/cabs.ml	/^and for_clause = $/;"	t
forceIncludeArg	cil/lib/Cilly.pm	/^sub forceIncludeArg {  # Same as for CL$/;"	s
forceIncludeArg	cil/lib/Cilly.pm	/^sub forceIncludeArg { $/;"	s
forceRLArgEval	cil/src/frontc/cabs2cil.mli	/^val forceRLArgEval: bool ref$/;"	v
formalNames	cil/src/mergecil.ml	/^let formalNames: (int * string, string list) H.t = H.create 111$/;"	v
formals	cil/src/ext/pta/steensgaard.ml	/^  let formals,ret =$/;"	v
format_spec	cil/ocamlutil/pretty.ml	/^	    let format_spec = "% " in$/;"	v
found	cil/src/ext/partial.ml	/^           let found = ref false in$/;"	v
fprint	cil/ocamlutil/pretty.ml	/^let fprint (chn: out_channel) ~(width: int) doc =$/;"	v
fprint	cil/ocamlutil/pretty.mli	/^val fprint: out_channel -> width:int -> doc -> unit$/;"	v
fprintf	cil/ocamlutil/pretty.mli	/^val fprintf: out_channel -> ('a, unit, doc) format -> 'a  $/;"	v
fptr	cil/src/formatcil.ml	/^  let fptr = makeLocalVar func "fptr" $/;"	v
fptr	cil/test/small1/init.c	/^int (*fptr)(int) = afunc;$/;"	v
fresh_c_absloc	cil/src/ext/pta/olf.ml	/^let fresh_c_absloc (is_top : bool) : c_absloc =$/;"	v
fresh_label	cil/src/ext/pta/golf.ml	/^let fresh_label (is_global : bool) : label =$/;"	v
fresh_recvar_name	cil/src/ext/pta/golf.ml	/^let fresh_recvar_name (t : tau) : string =$/;"	v
fresh_recvar_name	cil/src/ext/pta/olf.ml	/^let fresh_recvar_name (t : tau) : string =$/;"	v
fresh_recvar_name	cil/src/ext/pta/steensgaard.ml	/^let fresh_recvar_name (t : tau) : string =	    $/;"	v
fresh_succs	cil/src/ext/partial.ml	/^                          let fresh_succs = s.succs in$/;"	v
fromList	cil/ocamlutil/clist.ml	/^let fromList l = CList l$/;"	v
fromList	cil/ocamlutil/clist.mli	/^val fromList: 'a list -> 'a clist $/;"	v
fst3	cil/obj/x86_LINUX/cparser.ml	/^let fst3 (result, _, _) = result$/;"	v
ftype	cil/src/cil.ml	/^  let ftype = unrollType fi.ftype in$/;"	v
ftype	cil/src/cil.mli	/^    mutable ftype: typ;     $/;"	r	type:fieldinfo
ftypeAlign	cil/src/cil.ml	/^  let ftypeAlign = 8 * alignOf_int ftype in$/;"	v
ftypeBits	cil/src/cil.ml	/^  let ftypeBits = bitsSizeOf ftype in$/;"	v
funCount	cil/src/ext/crestInstrument.ml	/^let funCount = ref 0$/;"	v
funSigHash	cil/src/ext/predabst.ml	/^    let funSigHash = IH.create 100$/;"	v
fun_stmt	cil/src/ext/partial.ml	/^                                let fun_stmt = List.hd fd.sbody.bstmts in$/;"	v
func	cil/src/formatcil.ml	/^  let func = emptyFunction "test_formatcil" in$/;"	v
funcSigMakerClass	cil/src/ext/predabst.ml	/^    class funcSigMakerClass = object(self)$/;"	c
functionChecksum	cil/src/mergecil.ml	/^let functionChecksum (dec: fundec) : int =$/;"	v
functionPointerName	cil/src/ext/stackoverflow.ml	/^let functionPointerName = "@@functionPointer@@"$/;"	v
function_id_t	src/base/basic_types.h	/^typedef unsigned int function_id_t;$/;"	t	namespace:crest
fundec	cil/src/cil.mli	/^and fundec =$/;"	t
fundec_of_varinfo	cil/src/ext/partial.ml	/^  let fundec_of_varinfo cg vi =$/;"	v
funspec	cil/src/frontc/cabs.ml	/^and funspec = $/;"	t
g	cil/src/testcil.ml	/^    let g = makeGlobalVar (newName "g") t in$/;"	v
g	cil/test/small1/init.c	/^int  g = { 6 } ;$/;"	v
g	test/cfg_test.c	/^void g(int a) {$/;"	f
g'	cil/src/mergecil.ml	/^          let g' = GFun(fdec', l) in$/;"	v
gc	cil/ocamlutil/stats.ml	/^  let gc = Gc.quick_stat () in $/;"	v
gc_content	cil/libstr/src/gc_content.c	/^float gc_content (char *seq)$/;"	f
gcc	cil/obj/x86_LINUX/machdep.ml	/^let gcc = {$/;"	v
gccBuiltins	cil/src/cil.ml	/^let gccBuiltins = builtinFunctions$/;"	v
gccBuiltins	cil/src/cil.mli	/^val gccBuiltins: (string, typ * typ list * bool) Hashtbl.t$/;"	v
get	cil/ocamlutil/growArray.ml	/^let get (ga: 'a t) (r: int) : 'a = LA.get ga.gaData r$/;"	v
get	cil/ocamlutil/growArray.mli	/^val get : 'a t -> int -> 'a$/;"	v
get	cil/ocamlutil/longarray.mli	/^val get : 'a t -> int -> 'a$/;"	v
get	cil/src/ext/bitmap.ml	/^let get bmp i = $/;"	v
get	cil/src/ext/bitmap.mli	/^val  get : t -> int -> bool$/;"	v
getAEs	cil/src/ext/availexps.ml	/^let getAEs sid =$/;"	v
getAboutString	cil/ocamlutil/pretty.ml	/^let getAboutString () : string =$/;"	v
getAlgoName	cil/ocamlutil/pretty.ml	/^let getAlgoName = function$/;"	v
getAlphaPrefix	cil/ocamlutil/alpha.ml	/^let getAlphaPrefix ~(lookupname:string) : string = $/;"	v
getAlphaPrefix	cil/ocamlutil/alpha.mli	/^val getAlphaPrefix: lookupname:string -> string$/;"	v
getCompField	cil/src/cil.ml	/^let getCompField (cinfo:compinfo) (fieldName:string) : fieldinfo =$/;"	v
getCompField	cil/src/cil.mli	/^val getCompField: compinfo -> string -> fieldinfo$/;"	v
getDefRhs	cil/src/ext/reachingdefs.ml	/^let getDefRhs didstmh stmdat defId =$/;"	v
getGlobInit	cil/src/cil.ml	/^let getGlobInit ?(main_name="main") (fl: file) = $/;"	v
getGlobInit	cil/src/cil.mli	/^val getGlobInit: ?main_name:string -> file -> fundec  $/;"	v
getHPosition	cil/ocamlutil/errormsg.ml	/^let getHPosition () = $/;"	v
getHPosition	cil/ocamlutil/errormsg.mli	/^val getHPosition: unit -> int * string (** high-level position *)$/;"	v
getIdom	cil/src/ext/dominators.mli	/^val getIdom:  Cil.stmt option Inthash.t -> Cil.stmt -> Cil.stmt option$/;"	v
getLocation	cil/ocamlutil/errormsg.mli	/^val getLocation: unit -> location$/;"	v
getNewId	cil/src/ext/crestInstrument.ml	/^let getNewId () = ((idCount := !idCount + 1); !idCount)$/;"	v
getNode	cil/src/mergecil.ml	/^let getNode    (eq: (int * string, 'a node) H.t)$/;"	v
getPAs	cil/src/ext/predabst.ml	/^    let getPAs sid =$/;"	v
getParenthLevel	cil/src/cil.ml	/^let getParenthLevel (e: exp) = $/;"	v
getPosition	cil/ocamlutil/errormsg.ml	/^let getPosition () : int * string * int = $/;"	v
getPosition	cil/ocamlutil/errormsg.mli	/^val getPosition: unit -> int * string * int (* Line number, file name, $/;"	v
getReg	cil/ocamlutil/util.ml	/^let getReg (ga: 'a growArray) (r: int) : 'a = $/;"	v
getRetStmt	cil/src/ext/oneret.ml	/^  let getRetStmt (x: unit) : stmt = $/;"	v
getSpeedFromOS	cil/ocamlutil/perfcount.c	/^  double getSpeedFromOS() {$/;"	f
getSpeedFromOS	cil/ocamlutil/perfcount.c	/^  double getSpeedFromOS(){ $/;"	f
getTypeOffset	cil/src/cil.ml	/^      let getTypeOffset = function$/;"	v
getUseDefFunctionRef	cil/src/ext/usedef.ml	/^let getUseDefFunctionRef: (exp -> exp list -> VS.t * VS.t * exp list) ref = $/;"	v
getVarsInGlobal	cil/src/cil.ml	/^let getVarsInGlobal (g : global) : varinfo list = $/;"	v
getVarsInGlobalClass	cil/src/cil.ml	/^class getVarsInGlobalClass (pacc: varinfo list ref) = object$/;"	c
get_aliases	cil/src/ext/pta/olf.ml	/^let get_aliases (l : c_absloc) =$/;"	v
get_args	cil/src/ext/pta/golf.ml	/^let get_args (t : tau) : tau list =$/;"	v
get_args	cil/src/ext/pta/olf.ml	/^let get_args (t : tau) : tau list =$/;"	v
get_args	cil/src/ext/pta/steensgaard.ml	/^let get_args (t : tau) : tau list ref =$/;"	v
get_bounds	cil/src/ext/pta/golf.ml	/^let get_bounds (p :polarity ) (upper : bool) (l : label) : lblinfo boundset =$/;"	v
get_c_absloc_stamp	cil/src/ext/pta/olf.ml	/^let get_c_absloc_stamp (l : c_absloc) : int =$/;"	v
get_cache	cil/src/ext/pta/steensgaard.ml	/^let get_cache (t : tau) : cache =$/;"	v
get_cur_dat	cil/src/ext/predabst.ml	/^      method get_cur_dat () = cur_pa_dat$/;"	m
get_current_time	cil/ocamlutil/stats.ml	/^let get_current_time () : float = $/;"	v
get_extra_lexeme	cil/obj/x86_LINUX/clexer.mli	/^val get_extra_lexeme: unit -> string$/;"	v
get_extra_lexeme	cil/src/frontc/clexer.mli	/^val get_extra_lexeme: unit -> string$/;"	v
get_finfo	cil/src/ext/pta/golf.ml	/^let get_finfo (t : tau) : finfo =$/;"	v
get_finfo	cil/src/ext/pta/olf.ml	/^let get_finfo (t : tau) : finfo =$/;"	v
get_flow_computed	cil/src/ext/pta/olf.ml	/^let get_flow_computed l =$/;"	v
get_global	cil/src/ext/pta/golf.ml	/^let get_global (t : tau) : bool =$/;"	v
get_globalLoc	cil/src/cil.ml	/^let get_globalLoc (g : global) =$/;"	v
get_initialized_constants	cil/src/ext/partial.ml	/^  method get_initialized_constants = init_const$/;"	m
get_instrLoc	cil/src/cil.ml	/^let get_instrLoc (inst : instr) =$/;"	v
get_label_stamp	cil/src/ext/pta/golf.ml	/^let get_label_stamp (l : label) : int =$/;"	v
get_sinfo	cil/src/ext/partial.ml	/^  let get_sinfo stmt =$/;"	v
get_some_option_list	cil/ocamlutil/util.mli	/^val get_some_option_list : 'a option list -> 'a list$/;"	v
get_stmtLoc	cil/src/cil.ml	/^let rec get_stmtLoc (statement : stmtkind) =$/;"	v
get_switch_count	cil/src/cil.ml	/^let get_switch_count () = $/;"	v
get_vid	cil/src/ext/reachingdefs.ml	/^  let get_vid vid ios io =$/;"	v
get_white	cil/obj/x86_LINUX/clexer.mli	/^val get_white: unit -> string$/;"	v
get_white	cil/src/frontc/clexer.mli	/^val get_white: unit -> string$/;"	v
getg	cil/ocamlutil/growArray.ml	/^let getg (ga: 'a t) (r: int) : 'a = $/;"	v
getg	cil/ocamlutil/growArray.mli	/^val getg : 'a t -> int -> 'a$/;"	v
getident	cil/src/frontc/cabshelper.ml	/^let getident () =$/;"	v
gettime	cil/src/frontc/patch.ml	/^let gettime () : float =$/;"	v
glob1	cil/test/small1/init.c	/^NESTED glob1;$/;"	v
glob2	cil/test/small1/init.c	/^int * glob2 = & glob3;$/;"	v
glob3	cil/test/small1/init.c	/^int glob3;$/;"	v
globStr	cil/src/mergecil.ml	/^    let globStr:string = (P.sprint 1000 (P.dprintf $/;"	v
global	cil/src/cil.mli	/^and global =$/;"	t
globalConstVisitor	cil/src/ext/partial.ml	/^class globalConstVisitor =$/;"	c
globalFinderClass	cil/src/ext/predabst.ml	/^    class globalFinderClass br = object(self)$/;"	c
globalMap	cil/src/rmtmps.ml	/^  let globalMap = Hashtbl.create 137 in$/;"	v
global_lvalue	cil/src/ext/pta/golf.ml	/^let global_lvalue lv = get_global lv.contents$/;"	v
global_lvalue	cil/src/ext/pta/golf.mli	/^val global_lvalue : lvalue -> bool$/;"	v
global_lvalue	cil/src/ext/pta/steensgaard.mli	/^val global_lvalue : lvalue -> bool$/;"	v
global_tau	cil/src/ext/pta/golf.ml	/^let global_tau = get_global$/;"	v
globally_unique_sids	cil/src/ext/ciltools.ml	/^let globally_unique_sids f =$/;"	v
globally_unique_vids	cil/src/ext/ciltools.ml	/^let globally_unique_vids f =$/;"	v
globally_unique_vids	cil/src/ext/partial.ml	/^let globally_unique_vids f =$/;"	v
globals	cil/src/cil.mli	/^      mutable globals: global list; (** List of globals as they will appear $/;"	r	type:file
globinit	cil/src/cil.mli	/^      mutable globinit: fundec option;  $/;"	r	type:file
globinitcalled	cil/src/cil.mli	/^      mutable globinitcalled: bool;     $/;"	r	type:file
gotoTargets	cil/src/check.ml	/^let gotoTargets: (string * stmt) list ref = ref []$/;"	v
gprintf	cil/ocamlutil/pretty.ml	/^let gprintf (finish : doc -> 'b)  $/;"	v
gprintf	cil/ocamlutil/pretty.mli	/^val gprintf: (doc -> 'b) -> ('a, unit, doc, 'b) format4 -> 'a$/;"	v
graph_t	src/process_cfg/process_cfg.cc	/^typedef vector<adj_list_t> graph_t;$/;"	t	file:
guardaction	cil/src/ext/dataflow.mli	/^type 't guardaction = $/;"	t
h	cil/obj/x86_LINUX/cparser.ml	/^                          let h, _, _ = _4 in$/;"	v
h	cil/obj/x86_LINUX/cparser.ml	/^                          let h, _, _ = _5 in$/;"	v
h	cil/src/ext/ssa.ml	/^	let h=List.hd !workList in$/;"	v
h	test/cfg_test.c	/^void h(int a) {$/;"	f
h'	cil/src/cil.ml	/^        let h' = fBlock h in$/;"	v
h_equals	cil/src/ext/predabst.ml	/^    let h_equals h1 h2 =$/;"	v
hadErrors	cil/ocamlutil/errormsg.ml	/^let hadErrors = ref false$/;"	v
hadErrors	cil/ocamlutil/errormsg.mli	/^val hadErrors: bool ref  $/;"	v
handle	cil/src/ext/astslicer.ml	/^let handle ht elt keep drop =$/;"	v
handle	cil/src/ext/astslicer.ml	/^let handle ht elt rep =$/;"	v
handleCallEdgesAndWriteCfg	cil/src/ext/crestInstrument.ml	/^let handleCallEdgesAndWriteCfg cilFile =$/;"	v
handleCallInstr	cil/src/ext/predabst.ml	/^    let handleCallInstr (ctxt     : context)$/;"	v
handleIl	cil/src/ext/predabst.ml	/^    let handleIl (ctxt : context)$/;"	v
handleInstruction	cil/src/ext/dataflow.ml	/^          let handleInstruction (s: T.t) (i: instr) : T.t = $/;"	v
handleSetInstr	cil/src/ext/predabst.ml	/^    let handleSetInstr (ctxt     : context)$/;"	v
handleStmt	cil/src/ext/predabst.ml	/^    let handleStmt (ctxt : context) $/;"	v
handle_choices	cil/src/cil.ml	/^      let rec handle_choices sl = match sl with$/;"	v
handle_loffset	cil/src/ext/simplemem.ml	/^and handle_loffset lv lo = $/;"	v
handler	cil/bin/teetwo	/^handler() {$/;"	f
hasAddress	cil/src/ext/crestInstrument.ml	/^let hasAddress (_, off) =$/;"	v
hasAlready	cil/src/ext/ssa.ml	/^  let hasAlready = Array.create size 0 in $/;"	v
hasAttribute	cil/src/cil.mli	/^val hasAttribute: string -> attributes -> bool$/;"	v
hasChanged	cil/src/cil.ml	/^        let hasChanged = ref false in$/;"	v
hasExportingAttribute	cil/src/rmtmps.ml	/^let hasExportingAttribute funvar =$/;"	v
hasFunctionTypeAttribute	cil/src/ext/blockinggraph.ml	/^let hasFunctionTypeAttribute (n: string) (t: typ) : bool = $/;"	v
hasPrefix	cil/ocamlutil/util.mli	/^val hasPrefix: string -> string -> bool$/;"	v
hasPrefix	cil/src/cil.ml	/^let hasPrefix p s = $/;"	v
hasSuffix	cil/src/cil.ml	/^  let hasSuffix = hasSuffix str in$/;"	v
hasVolatile	cil/src/ext/deadcodeelim.ml	/^class hasVolatile flag = object (self)$/;"	c
has_live_labels	cil/src/ext/partial.ml	/^              let has_live_labels b =$/;"	v
has_performance_counters	cil/ocamlutil/perfcount.c	/^value has_performance_counters() {$/;"	f
has_performance_counters	cil/ocamlutil/stats.mli	/^val has_performance_counters: unit -> bool$/;"	v
hasbva	cil/src/cil.ml	/^  let hasbva = M.gccHas__builtin_va_list in$/;"	v
hash	cil/ocamlutil/inthash.ml	/^let hash key = key land 0x3fffffff$/;"	v
hash	src/process_cfg/process_cfg.cc	/^  template<> struct hash<string> {$/;"	s	namespace:__gnu_cxx	file:
hash_copy_into	cil/ocamlutil/util.mli	/^val hash_copy_into: ('a, 'b) Hashtbl.t -> ('a, 'b) Hashtbl.t -> unit$/;"	v
hash_to_list	cil/ocamlutil/util.ml	/^let hash_to_list (h: ('a, 'b) H.t) : ('a * 'b) list =$/;"	v
hash_to_list	cil/ocamlutil/util.mli	/^val hash_to_list: ('a, 'b) Hashtbl.t -> ('a * 'b) list$/;"	v
haveGoto	cil/src/ext/oneret.ml	/^  let haveGoto = ref false in$/;"	v
headers	cil/src/ext/ssa.ml	/^  let headers = ref(IntSet.empty) in$/;"	v
headers	cil/src/ext/ssa.mli	/^    headers: int list;$/;"	r	type:oneSccInfo
heapify	cil/src/ext/heapify.ml	/^let heapify (f : file) (alloc : exp) (free : exp)  =$/;"	v
heapifyAnalyzeVisitor	cil/src/ext/heapify.ml	/^class heapifyAnalyzeVisitor f alloc free = object $/;"	c
height	cil/ocamlutil/intmap.ml	/^let height = function$/;"	v
helpMessage	cil/bin/cilly	/^sub helpMessage {$/;"	s
helpMessage	cil/lib/Cilly.pm	/^sub helpMessage {$/;"	s
hfile	cil/ocamlutil/errormsg.ml	/^      hfile: string; (** The high-level file name, or "" if not present *)$/;"	r	type:location
hfile	cil/ocamlutil/errormsg.mli	/^      hfile: string; (** The high-level file name, or "" if not present *)$/;"	r	type:location
high	cil/src/cil.ml	/^        let high = Int64.shift_right i 32 in$/;"	v
hl_combine	cil/src/ext/predabst.ml	/^    let hl_combine hl1 hl2 =$/;"	v
hl_equals	cil/src/ext/predabst.ml	/^    let hl_equals hl1 hl2 =$/;"	v
hline	cil/ocamlutil/errormsg.ml	/^      hline: int;    (** The high-level line number, or 0 if not present *)$/;"	r	type:location
hline	cil/ocamlutil/errormsg.mli	/^      hline: int;    (** The high-level line number, or 0 if not present *)$/;"	r	type:location
hose_globals	cil/src/ext/pta/ptranal.ml	/^  let hose_globals () : unit =$/;"	v
htoc1	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1<\/A>&#XA0;&#XA0;Introduction<\/H2><!--SEC END --><P>New: CIL now has a Source Forge page: $/;"	a
htoc1	cil/doc/cil001.html	/^<H2 CLASS="section"><A NAME="htoc1">1<\/A>&#XA0;&#XA0;Introduction<\/H2><P>New: CIL now has a Source Forge page: $/;"	a
htoc10	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">6.1<\/A>&#XA0;&#XA0;Using the visitor<\/H3><!--SEC END --><P><A NAME="sec-visitor"><\/A><\/P><P>One of the most useful tools exported by the CIL API is an implementation of$/;"	a
htoc11	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">6.2<\/A>&#XA0;&#XA0;Interpreted Constructors and Deconstructors<\/H3><!--SEC END --><P>Interpreted constructors and deconstructors are a facility for constructing$/;"	a
htoc12	cil/doc/attributes.html	/^takes the arguments and constructs the statement) is memoized. <\/P><H4 CLASS="subsubsection"><A NAME="htoc12">6.2.1<\/A>&#XA0;&#XA0;Performance considerations for interpreted constructors<\/H4><P>Parsing the patterns is done with a LALR parser and it takes some time. To$/;"	a
htoc12	cil/doc/cil.html	/^<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc12">6.2.1<\/A>&#XA0;&#XA0;Performance considerations for interpreted constructors<\/H4><!--SEC END --><P>Parsing the patterns is done with a LALR parser and it takes some time. To$/;"	a
htoc13	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">6.3<\/A>&#XA0;&#XA0;Printing and Debugging support<\/H3><!--SEC END --><P>The Modules <A HREF="api\/Pretty.html">Pretty<\/A> and <A HREF="api\/Errormsg.html">Errormsg<\/A> contain respectively$/;"	a
htoc14	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">6.4<\/A>&#XA0;&#XA0;Attributes<\/H3><!--SEC END --><P><A NAME="sec-attrib"><\/A><\/P><!--NAME attributes.html-->$/;"	a
htoc15	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc15">7<\/A>&#XA0;&#XA0;The CIL Driver<\/H2><!--SEC END --><P><A NAME="sec-driver"><\/A><\/P><P>We have packaged CIL as an application <TT>cilly<\/TT> that contains certain$/;"	a
htoc15	cil/doc/cil007.html	/^<H2 CLASS="section"><A NAME="htoc15">7<\/A>&#XA0;&#XA0;The CIL Driver<\/H2><P><A NAME="sec-driver"><\/A><\/P><P>We have packaged CIL as an application <TT>cilly<\/TT> that contains certain$/;"	a
htoc16	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">7.1<\/A>&#XA0;&#XA0;<TT>cilly<\/TT> Options<\/H3><!--SEC END --><P>Among the options for the <TT>cilly<\/TT> you can put anything that can normally$/;"	a
htoc17	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc17">7.2<\/A>&#XA0;&#XA0;<TT>cilly.asm<\/TT> Options<\/H3><!--SEC END --><P>$/;"	a
htoc18	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">7.3<\/A>&#XA0;&#XA0;Internal Options<\/H3><!--SEC END --><P>$/;"	a
htoc19	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc19">8<\/A>&#XA0;&#XA0;Library of CIL Modules<\/H2><!--SEC END --><P> <A NAME="sec-Extension"><\/A><\/P><!--NAME ext.html-->$/;"	a
htoc19	cil/doc/ext.html	/^<H2 CLASS="section"><A NAME="htoc19">8<\/A>&#XA0;&#XA0;Library of CIL Modules<\/H2><P> <A NAME="sec-Extension"><\/A><\/P><P>We are developing a suite of modules that use CIL for program analyses and$/;"	a
htoc2	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2<\/A>&#XA0;&#XA0;Installation<\/H2><!--SEC END --><P>You need the following tools to build CIL:$/;"	a
htoc2	cil/doc/cil002.html	/^<H2 CLASS="section"><A NAME="htoc2">2<\/A>&#XA0;&#XA0;Installation<\/H2><P>You need the following tools to build CIL:$/;"	a
htoc20	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">8.1<\/A>&#XA0;&#XA0;Control-Flow Graphs<\/H3><!--SEC END --><P> <A NAME="sec-cfg"><\/A><\/P><P>The <A HREF="api\/Cil.html#TYPEstmt">Cil.stmt<\/A> datatype includes fields for intraprocedural$/;"	a
htoc21	cil/doc/cil.html	/^<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc21">8.1.1<\/A>&#XA0;&#XA0;The CFG module (new in CIL 1.3.5)<\/H4><!--SEC END --><P>The best way to compute the CFG is with the CFG module. Just invoke$/;"	a
htoc21	cil/doc/ext.html	/^compute the CFG using one of these two methods:<\/P><H4 CLASS="subsubsection"><A NAME="htoc21">8.1.1<\/A>&#XA0;&#XA0;The CFG module (new in CIL 1.3.5)<\/H4><P>The best way to compute the CFG is with the CFG module. Just invoke$/;"	a
htoc22	cil/doc/cil.html	/^<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc22">8.1.2<\/A>&#XA0;&#XA0;Simplified control flow<\/H4><!--SEC END --><P>CIL can reduce high-level C control-flow constructs like <TT>switch<\/TT> and$/;"	a
htoc22	cil/doc/ext.html	/^<TT>dot<\/TT> form.<\/P><H4 CLASS="subsubsection"><A NAME="htoc22">8.1.2<\/A>&#XA0;&#XA0;Simplified control flow<\/H4><P>CIL can reduce high-level C control-flow constructs like <TT>switch<\/TT> and$/;"	a
htoc23	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">8.2<\/A>&#XA0;&#XA0;Data flow analysis framework<\/H3><!--SEC END --><P>The <A HREF="api\/Dataflow.html">Dataflow<\/A> module (click for the ocamldoc) contains a$/;"	a
htoc24	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">8.3<\/A>&#XA0;&#XA0;Dominators<\/H3><!--SEC END --><P>The module <A HREF="api\/Dominators.html">Dominators<\/A> contains the computation of immediate$/;"	a
htoc25	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">8.4<\/A>&#XA0;&#XA0;Points-to Analysis<\/H3><!--SEC END --><P>The module <TT>ptranal.ml<\/TT> contains two interprocedural points-to$/;"	a
htoc26	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">8.5<\/A>&#XA0;&#XA0;StackGuard<\/H3><!--SEC END --><P>The module <TT>heapify.ml<\/TT> contains a transformation similar to the one$/;"	a
htoc27	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">8.6<\/A>&#XA0;&#XA0;Heapify<\/H3><!--SEC END --><P>The module <TT>heapify.ml<\/TT> also contains a transformation that moves all$/;"	a
htoc28	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">8.7<\/A>&#XA0;&#XA0;One Return<\/H3><!--SEC END --><P>The module <TT>oneret.ml<\/TT> contains a transformation the ensures that all$/;"	a
htoc29	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">8.8<\/A>&#XA0;&#XA0;Partial Evaluation and Constant Folding<\/H3><!--SEC END --><P>The <TT>partial.ml<\/TT> module provides a simple interprocedural partial$/;"	a
htoc3	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">2.1<\/A>&#XA0;&#XA0;Building CIL on Windows with Microsoft Visual C<\/H3><!--SEC END --><P>Some users might want to build a standalone CIL executable on Windows (an$/;"	a
htoc30	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">8.9<\/A>&#XA0;&#XA0;Reaching Definitions<\/H3><!--SEC END --><P>The <TT>reachingdefs.ml<\/TT> module uses the dataflow framework and CFG$/;"	a
htoc31	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">8.10<\/A>&#XA0;&#XA0;Available Expressions<\/H3><!--SEC END --><P>The <TT>availexps.ml<\/TT> module uses the dataflow framework and CFG$/;"	a
htoc32	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">8.11<\/A>&#XA0;&#XA0;Liveness Analysis<\/H3><!--SEC END --><P>The <TT>liveness.ml<\/TT> module uses the dataflow framework and$/;"	a
htoc33	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">8.12<\/A>&#XA0;&#XA0;Dead Code Elimination<\/H3><!--SEC END --><P>The module <TT>deadcodeelim.ml<\/TT> uses the reaching definitions$/;"	a
htoc34	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">8.13<\/A>&#XA0;&#XA0;Simple Memory Operations<\/H3><!--SEC END --><P>The <TT>simplemem.ml<\/TT> module allows CIL lvalues that contain memory$/;"	a
htoc35	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc35">8.14<\/A>&#XA0;&#XA0;Simple Three-Address Code<\/H3><!--SEC END --><P>The <TT>simplify.ml<\/TT> module further reduces the complexity of program$/;"	a
htoc36	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">8.15<\/A>&#XA0;&#XA0;Converting C to C++<\/H3><!--SEC END --><P>The module canonicalize.ml performs several transformations to correct$/;"	a
htoc37	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc37">9<\/A>&#XA0;&#XA0;Controlling CIL<\/H2><!--SEC END --><P>In the process of converting a C file to CIL we drop the unused prototypes$/;"	a
htoc37	cil/doc/cil009.html	/^<H2 CLASS="section"><A NAME="htoc37">9<\/A>&#XA0;&#XA0;Controlling CIL<\/H2><P>In the process of converting a C file to CIL we drop the unused prototypes$/;"	a
htoc38	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc38">10<\/A>&#XA0;&#XA0;GCC Extensions<\/H2><!--SEC END --><P>The CIL parser handles most of the <TT>gcc<\/TT>$/;"	a
htoc38	cil/doc/cil010.html	/^<H2 CLASS="section"><A NAME="htoc38">10<\/A>&#XA0;&#XA0;GCC Extensions<\/H2><P>The CIL parser handles most of the <TT>gcc<\/TT>$/;"	a
htoc39	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc39">11<\/A>&#XA0;&#XA0;CIL Limitations<\/H2><!--SEC END --><P>There are several implementation details of CIL that might make it unusable$/;"	a
htoc39	cil/doc/cil011.html	/^<H2 CLASS="section"><A NAME="htoc39">11<\/A>&#XA0;&#XA0;CIL Limitations<\/H2><P>There are several implementation details of CIL that might make it unusable$/;"	a
htoc4	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">3<\/A>&#XA0;&#XA0;Distribution Contents<\/H2><!--SEC END --><P>The file <A HREF="distrib\/cil-1.3.6.tar.gz"><TT>distrib\/cil-1.3.6.tar.gz<\/TT><\/A> $/;"	a
htoc4	cil/doc/cil003.html	/^<H2 CLASS="section"><A NAME="htoc4">3<\/A>&#XA0;&#XA0;Distribution Contents<\/H2><P>The file <A HREF="distrib\/cil-1.3.6.tar.gz"><TT>distrib\/cil-1.3.6.tar.gz<\/TT><\/A> $/;"	a
htoc40	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc40">12<\/A>&#XA0;&#XA0;Known Bugs and Limitations<\/H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">In the new versions of <TT>glibc<\/TT> there is a function$/;"	a
htoc40	cil/doc/cil012.html	/^<H2 CLASS="section"><A NAME="htoc40">12<\/A>&#XA0;&#XA0;Known Bugs and Limitations<\/H2><UL CLASS="itemize"><LI CLASS="li-itemize">In the new versions of <TT>glibc<\/TT> there is a function$/;"	a
htoc41	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">13<\/A>&#XA0;&#XA0;Using the merger<\/H2><!--SEC END --><P><A NAME="sec-merger"><\/A><\/P><!--NAME merger.html-->$/;"	a
htoc41	cil/doc/merger.html	/^<H2 CLASS="section"><A NAME="htoc41">13<\/A>&#XA0;&#XA0;Using the merger<\/H2><P><A NAME="sec-merger"><\/A><\/P><P>There are many program analyses that are more effective when$/;"	a
htoc42	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc42">14<\/A>&#XA0;&#XA0;Using the patcher<\/H2><!--SEC END --><P><A NAME="sec-patcher"><\/A><\/P><!--NAME patcher.html-->$/;"	a
htoc42	cil/doc/patcher.html	/^<H2 CLASS="section"><A NAME="htoc42">14<\/A>&#XA0;&#XA0;Using the patcher<\/H2><P><A NAME="sec-patcher"><\/A><\/P><P>Occasionally we have needed to modify slightly the standard include files.$/;"	a
htoc43	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc43">15<\/A>&#XA0;&#XA0;Debugging support<\/H2><!--SEC END --><P><A NAME="sec-debugger"><\/A><\/P><P>Most of the time we debug our code using the Errormsg module along with the$/;"	a
htoc43	cil/doc/cil015.html	/^<H2 CLASS="section"><A NAME="htoc43">15<\/A>&#XA0;&#XA0;Debugging support<\/H2><P><A NAME="sec-debugger"><\/A><\/P><P>Most of the time we debug our code using the Errormsg module along with the$/;"	a
htoc44	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc44">16<\/A>&#XA0;&#XA0;Who Says C is Simple?<\/H2><!--SEC END --><P><A NAME="sec-simplec"><\/A><\/P><P>When I (George) started to write CIL I thought it was going to take two weeks.$/;"	a
htoc44	cil/doc/cil016.html	/^<H2 CLASS="section"><A NAME="htoc44">16<\/A>&#XA0;&#XA0;Who Says C is Simple?<\/H2><P><A NAME="sec-simplec"><\/A><\/P><P>When I (George) started to write CIL I thought it was going to take two weeks.$/;"	a
htoc45	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc45">16.1<\/A>&#XA0;&#XA0;Standard C<\/H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Why does the following code return 0 for most values of <TT>x<\/TT>? (This$/;"	a
htoc46	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc46">16.2<\/A>&#XA0;&#XA0;GCC ugliness<\/H3><!--SEC END --><P><A NAME="sec-ugly-gcc"><\/A><\/P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">GCC has generalized lvalues. You can take the address of a lot of$/;"	a
htoc47	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc47">16.3<\/A>&#XA0;&#XA0;Microsoft VC ugliness<\/H3><!--SEC END --><P>This compiler has few extensions, so there is not much to say here.<\/P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">$/;"	a
htoc48	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc48">17<\/A>&#XA0;&#XA0;Authors<\/H2><!--SEC END --><P>The CIL parser was developed starting from Hugues Casse's <TT>frontc<\/TT>$/;"	a
htoc48	cil/doc/cil017.html	/^<H2 CLASS="section"><A NAME="htoc48">17<\/A>&#XA0;&#XA0;Authors<\/H2><P>The CIL parser was developed starting from Hugues Casse's <TT>frontc<\/TT>$/;"	a
htoc49	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc49">18<\/A>&#XA0;&#XA0;License<\/H2><!--SEC END --><P>Copyright (c) 2001-2007, $/;"	a
htoc49	cil/doc/cil018.html	/^<H2 CLASS="section"><A NAME="htoc49">18<\/A>&#XA0;&#XA0;License<\/H2><P>Copyright (c) 2001-2007, $/;"	a
htoc5	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">4<\/A>&#XA0;&#XA0;Compiling C to CIL<\/H2><!--SEC END --><P><A NAME="sec-cabs2cil"><\/A><\/P><P>In this section we try to describe a few of the many transformations that are$/;"	a
htoc5	cil/doc/cil004.html	/^<H2 CLASS="section"><A NAME="htoc5">4<\/A>&#XA0;&#XA0;Compiling C to CIL<\/H2><P><A NAME="sec-cabs2cil"><\/A><\/P><P>In this section we try to describe a few of the many transformations that are$/;"	a
htoc50	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc50">19<\/A>&#XA0;&#XA0;Bug reports<\/H2><!--SEC END --><P>We are certain that there are still some remaining bugs in CIL. If you find$/;"	a
htoc50	cil/doc/cil019.html	/^<H2 CLASS="section"><A NAME="htoc50">19<\/A>&#XA0;&#XA0;Bug reports<\/H2><P>We are certain that there are still some remaining bugs in CIL. If you find$/;"	a
htoc51	cil/doc/changes.html	/^<H2 CLASS="section"><A NAME="htoc51">20<\/A>&#XA0;&#XA0;Changes<\/H2><P><A NAME="sec-changes"><\/A><\/P><UL CLASS="itemize"><LI CLASS="li-itemize">$/;"	a
htoc51	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">20<\/A>&#XA0;&#XA0;Changes<\/H2><!--SEC END --><P><A NAME="sec-changes"><\/A><\/P><!--NAME changes.html-->$/;"	a
htoc6	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">5<\/A>&#XA0;&#XA0;How to Use CIL<\/H2><!--SEC END --><P><A NAME="sec-cil"><\/A><\/P><!--NAME cilly.html-->$/;"	a
htoc6	cil/doc/cilly.html	/^<H2 CLASS="section"><A NAME="htoc6">5<\/A>&#XA0;&#XA0;How to Use CIL<\/H2><P><A NAME="sec-cil"><\/A><\/P><P>There are two predominant ways to use CIL to write a program analysis or$/;"	a
htoc7	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">5.1<\/A>&#XA0;&#XA0;Using <TT>cilly<\/TT>, the CIL driver<\/H3><!--SEC END --><P>The most common way to use CIL is to write an Ocaml module containing your$/;"	a
htoc8	cil/doc/cil.html	/^<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">5.2<\/A>&#XA0;&#XA0;Using CIL as a library<\/H3><!--SEC END --><P>CIL can also be built as a library that is called from your stand-alone$/;"	a
htoc9	cil/doc/attributes.html	/^<H2 CLASS="section"><A NAME="htoc9">6<\/A>&#XA0;&#XA0;CIL API Documentation<\/H2><P><A NAME="sec-api"><\/A> <\/P><P>The CIL API is documented in the file <TT>src\/cil.mli<\/TT>. We also have an$/;"	a
htoc9	cil/doc/cil.html	/^<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc9">6<\/A>&#XA0;&#XA0;CIL API Documentation<\/H2><!--SEC END --><P><A NAME="sec-api"><\/A> <\/P><P>The CIL API is documented in the file <TT>src\/cil.mli<\/TT>. We also have an$/;"	a
i	cil/ocamlutil/errormsg.ml	/^  let i = !current in$/;"	v
i	cil/ocamlutil/errormsg.ml	/^  let i = $/;"	v
i	cil/src/cil.ml	/^          let i = get_switch_count () in $/;"	v
i	cil/src/cil.ml	/^      let i = get_switch_count () in $/;"	v
i	cil/src/cil.ml	/^    let i = $/;"	v
i	cil/src/ext/heap.ml	/^  let i = ref heap.size in$/;"	v
i	cil/src/ext/reachingdefs.ml	/^	(try let ((i,(_,_,diosh)),(_,_,iosh_in)) = List.find (fun ((i,(_,_,iosh')),_) ->$/;"	v
i	cil/src/ext/ssa.ml	/^      let i = idom.(x) in$/;"	v
i	cil/src/testcil.ml	/^            let i = Random.int leni in$/;"	v
i	test/cfg_test.c	/^void i(int a) {$/;"	f
i'	cil/src/cil.ml	/^          let i' = visitCilInit vis forglob (addOffset o' atoff) i in$/;"	v
i'	cil/src/cil.ml	/^          let i', _ = truncateInteger64 nk i in$/;"	v
i'_uses	cil/src/ext/deadcodeelim.ml	/^	      let i'_uses = IH.find defUseSetHash i' in$/;"	v
i1	cil/src/cil.ml	/^    let i1 = Int64.shift_left i (64 - nrBits) in$/;"	v
i1	cil/test/small1/init.c	/^    int * i1;$/;"	m	struct:__anon1::__anon3	file:
i1'	cil/src/cil.ml	/^          let i1', i2', _ = convertInts i1 ik1 i2 ik2 in$/;"	v
i1'	cil/src/cil.ml	/^          let i1', i2', ik' = convertInts i1 ik1 i2 ik2 in$/;"	v
i1'	cil/src/cil.ml	/^    let i1',_ = truncateInteger64 ik' i1 in$/;"	v
i2	cil/src/cil.ml	/^    let i2 = $/;"	v
i2'	cil/src/cil.ml	/^    let i2',_ = truncateInteger64 ik' i2 in$/;"	v
i64_to_int	cil/src/cil.mli	/^val i64_to_int: int64 -> int$/;"	v
iEq	cil/src/mergecil.ml	/^let iEq: (int * string, varinfo node) H.t = H.create 111 (* Inlines *)$/;"	v
iSyn	cil/src/mergecil.ml	/^let iSyn: (string, varinfo node) H.t = H.create 111 (* Inlines *)$/;"	v
ic	cil/ocamlutil/util.ml	/^    let ic = open_in fname in$/;"	v
idCount	cil/src/ext/crestInstrument.ml	/^let idCount = ref 0$/;"	v
idMaker	cil/src/ext/reachingdefs.ml	/^let idMaker () start =$/;"	v
idType	cil/src/ext/crestInstrument.ml	/^let idType   = intType$/;"	v
id_t	src/base/basic_types.h	/^typedef int id_t;$/;"	t	namespace:crest
ident	cil/src/frontc/cabs.ml	/^ ident : int;$/;"	r	type:cabsloc
identity	cil/src/frontc/patch.ml	/^let identity x = x$/;"	v
idomData	cil/src/ext/dominators.ml	/^  let idomData: stmt option IH.t = IH.create 13 in$/;"	v
idomData	cil/src/ext/dominators.ml	/^  let idomData: stmt option IH.t = IH.create 64 in$/;"	v
idomInfo	cil/src/ext/ssa.mli	/^type idomInfo = int array  (* immediate dominator *)$/;"	t
ifSuccs	cil/src/ext/dataflow.ml	/^    let ifSuccs (s:stmt) : stmt * stmt = $/;"	v
ignore_merge_conflicts	cil/src/mergecil.mli	/^val ignore_merge_conflicts: bool ref$/;"	v
ih_inter	cil/src/ext/reachingdefs.ml	/^let ih_inter ih1 ih2 =$/;"	v
ih_union	cil/src/ext/reachingdefs.ml	/^let ih_union ih1 ih2 =$/;"	v
iihl	cil/src/ext/reachingdefs.ml	/^	let iihl = List.combine (List.combine il ivihl) ivihl_in in$/;"	v
ik'	cil/src/cil.ml	/^      let ik' = $/;"	v
ikind	cil/src/cil.mli	/^and ikind = $/;"	t
il'	cil/src/cil.ml	/^        let il' = mapNoCopyList fInst il in$/;"	v
il''	cil/src/cil.ml	/^        let il'' = $/;"	v
ilVersion	cil/Makefile	/^	echo "let cilVersion      = \\"1.3.6\\""  >>$@ $/;"	m
ilVersionMajor	cil/Makefile	/^	echo "let cilVersionMajor = 1" >>$@$/;"	m
ilVersionMinor	cil/Makefile	/^	echo "let cilVersionMinor = 3" >>$@$/;"	m
ilVersionRev	cil/Makefile	/^	echo "let cilVersionRev   = 6"   >>$@$/;"	m
ils	cil/src/cil.ml	/^        let ils = Clist.fromList il in$/;"	v
inchan	cil/ocamlutil/errormsg.ml	/^  let inchan = $/;"	v
incoming_state	cil/src/ext/partial.ml	/^    incoming_state : (int, S.t) Hashtbl.t;$/;"	r	type:sinfo
increm	cil/src/cil.ml	/^let increm (e: exp) (i: int) =$/;"	v
increm	cil/src/cil.mli	/^val increm: exp -> int -> exp$/;"	v
ind	cil/ocamlutil/trace.ml	/^  let rec ind (i : int) : string =$/;"	v
indent	cil/ocamlutil/pretty.ml	/^let indent n d = text (String.make n ' ') ++ (align ++ (d ++ unalign))$/;"	v
indent	cil/ocamlutil/pretty.mli	/^val indent: int -> doc -> doc$/;"	v	function:++
indentIfNeeded	cil/ocamlutil/pretty.ml	/^  let indentIfNeeded () =$/;"	v
indexLevel	cil/src/cil.ml	/^let indexLevel = 20$/;"	v
init	cil/obj/x86_LINUX/clexer.ml	/^let init ~(filename: string) : Lexing.lexbuf =$/;"	v
init	cil/obj/x86_LINUX/clexer.mli	/^val init: filename:string -> Lexing.lexbuf$/;"	v
init	cil/obj/x86_LINUX/formatparse.ml	/^                     let init = _4 args in$/;"	v
init	cil/ocamlutil/longarray.mli	/^val init : int -> (int -> 'a) -> 'a t$/;"	v
init	cil/src/cil.mli	/^    mutable init : init option;$/;"	r	type:initinfo
init	cil/src/cil.mli	/^and init = $/;"	t
init	cil/src/ext/bitmap.mli	/^val  init : int -> (int -> bool) -> t   (* Also initialize it *)$/;"	v
init	cil/src/ext/dataflow.ml	/^      let init: T.t = $/;"	v
init	cil/src/ext/stackoverflow.ml	/^let init () = $/;"	v
init	cil/src/frontc/clexer.mli	/^val init: filename:string -> Lexing.lexbuf$/;"	v
init	cil/src/mergecil.ml	/^let init () = $/;"	v
initCIL	cil/src/cil.ml	/^let initCIL () = $/;"	v
initCIL	cil/src/cil.mli	/^val initCIL: unit -> unit$/;"	v
initCIL_called	cil/src/cil.ml	/^let initCIL_called = ref false$/;"	v
initGccBuiltins	cil/src/cil.ml	/^let initGccBuiltins () : unit =$/;"	v
initGlobals	cil/src/frontc/cabs2cil.ml	/^let initGlobals () = theFile := []; theFileTypes := []$/;"	v
initList'	cil/src/ext/canonicalize.ml	/^	let initList' = List.map$/;"	v
initMsvcBuiltins	cil/src/cil.ml	/^let initMsvcBuiltins () : unit =$/;"	v
init_expression	cil/src/frontc/cabs.ml	/^and init_expression =$/;"	t
init_name	cil/src/frontc/cabs.ml	/^and init_name = name * init_expression$/;"	t
init_name_group	cil/src/frontc/cabs.ml	/^and init_name_group = specifier * init_name list$/;"	t
initbt	cil/src/cil.ml	/^      let initbt = makeZeroInit bt in$/;"	v
initial	cil/obj/x86_LINUX/clexer.mli	/^val initial: Lexing.lexbuf -> Cparser.token$/;"	v
initial	cil/src/frontc/clexer.mli	/^val initial: Lexing.lexbuf -> Cparser.token$/;"	v
initial_si	cil/src/ext/partial.ml	/^              let initial_si = get_sinfo initial_stmt in$/;"	v
initialize	cil/obj/x86_LINUX/formatparse.mli	/^val initialize :$/;"	v
initialized_constants	cil/src/ext/partial.ml	/^let initialized_constants = ref false$/;"	v
initinfo	cil/src/cil.mli	/^and initinfo = {$/;"	t
initl'	cil/src/cil.ml	/^        let initl' = if !hasChanged then List.rev !newinitl else initl in$/;"	v
initwhat	cil/src/frontc/cabs.ml	/^and initwhat =$/;"	t
inline	cil/ocamlutil/perfcount.c	31;"	d	file:
inlineBodies	cil/src/mergecil.ml	/^let inlineBodies : (P.doc, varinfo node) H.t = H.create 111$/;"	v
inode	cil/src/mergecil.ml	/^            let inode = $/;"	v
inputchar	cil/libstr/src/inputchar.c	/^char inputchar (void) $/;"	f
inputcharstream	cil/libstr/src/inputchar.c	/^char inputcharstream (FILE *input)$/;"	f
inputs	src/base/symbolic_execution.h	/^  const vector<value_t>& inputs() const { return inputs_; }$/;"	f	class:crest::SymbolicExecution
inputs_	src/base/symbolic_execution.h	/^  vector<value_t> inputs_;$/;"	m	class:crest::SymbolicExecution
ins	cil/obj/x86_LINUX/cparser.ml	/^                        ( let (ins, clobs) = _3 in$/;"	v
ins'	cil/src/cil.ml	/^      let ins'  = mapNoCopy (fun ((id,s,e) as pair) -> $/;"	v
insert	cil/ocamlutil/pretty.mli	/^val insert: unit -> doc -> doc$/;"	v
insertImplicitCasts	cil/src/cil.mli	/^val insertImplicitCasts: bool ref$/;"	v
insertInstr	cil/src/ext/blockinggraph.ml	/^let insertInstr (newInstr: instr) (s: stmt) : unit =$/;"	v
inserted	cil/src/cil.ml	/^      let inserted = ref false in$/;"	v
install_cma	cil/Makefile	/^install_cma := $(addprefix $(OBJDIR)\/cil., cma cmxa a)$/;"	m
install_cmi	cil/Makefile	/^install_cmi := $(install_mli:%.mli=$(OBJDIR)\/%.cmi)$/;"	m
install_lib	cil/Makefile	/^install_lib := $(OCAML_CIL_LIB_CMODULES:%=$(OBJDIR)\/lib%.a)$/;"	m
install_mli	cil/Makefile	/^install_mli := $(filter $(OCAML_CIL_LIB_MODULES:=.mli), $(all_mli))$/;"	m
instantiate	cil/src/ext/pta/golf.mli	/^val instantiate : lvalue -> int -> lvalue$/;"	v
instantiate	cil/src/ext/pta/olf.ml	/^let instantiate (lv : lvalue) (i : int) : lvalue =$/;"	v
instantiate	cil/src/ext/pta/olf.mli	/^val instantiate : lvalue -> int -> lvalue$/;"	v
instantiate	cil/src/ext/pta/steensgaard.mli	/^val instantiate : lvalue -> int -> lvalue$/;"	v
instantiate_int	cil/src/ext/pta/steensgaard.ml	/^let rec instantiate_int (t,(i,p),t' : tau * (int * polarity) * tau) =$/;"	v
instr	cil/obj/x86_LINUX/formatparse.mli	/^val instr :$/;"	v
instr	cil/src/cil.mli	/^and instr =$/;"	t
instrlist	cil/src/ext/ssa.mli	/^    instrlist: instruction list;$/;"	r	type:cfgBlock
instrs	cil/src/ext/dataslicing.ml	/^      let instrs, args' =$/;"	v
instruction	cil/src/ext/ssa.mli	/^and instruction = (reg list * reg list) $/;"	t
instrumentBlockingPoints	cil/src/ext/blockinggraph.ml	/^let instrumentBlockingPoints () =$/;"	v
instruses	cil/src/ext/deadcodeelim.ml	/^	  let instruses = viSetToDefIdSet iosh instruses in$/;"	v
int64_to_char	cil/obj/x86_LINUX/cparser.ml	/^let int64_to_char value =$/;"	v
intEnumInfo	cil/src/mergecil.ml	/^let intEnumInfo =$/;"	v
intPtrType	cil/src/cil.ml	/^let intPtrType = TPtr(intType, [])$/;"	v
intPtrType	cil/src/cil.mli	/^val intPtrType: typ$/;"	v
intRegexp	cil/ocamlutil/util.ml	/^let intRegexp = Str.regexp "i\\\\([0-9]+\\\\);"$/;"	v
intType	cil/src/cil.ml	/^let intType = TInt(IInt,[])$/;"	v
intType	cil/src/cil.mli	/^val intType: typ$/;"	v
int_range_list	cil/ocamlutil/util.mli	/^val int_range_list : int -> int -> int list$/;"	v
integer	cil/src/cil.ml	/^let integer (i: int) = Const (CInt64(Int64.of_int i, IInt, None))$/;"	v
integer	cil/src/cil.mli	/^val integer: int -> exp$/;"	v
interpret	cil/obj/x86_LINUX/cparser.mli	/^val interpret :$/;"	v
inters	cil/src/ext/bitmap.ml	/^let inters b1 b2 = $/;"	v
inters	cil/src/ext/bitmap.mli	/^val  inters : t -> t -> unit$/;"	v
intfun	cil/test/small1/func.c	/^typedef int (*intfun)(int);$/;"	t	file:
intlist_to_string	cil/obj/x86_LINUX/clexer.ml	/^let rec intlist_to_string (str: int64 list):string =$/;"	v
intlist_to_string	cil/obj/x86_LINUX/cparser.ml	/^let rec intlist_to_string (str: int64 list):string =$/;"	v
ints	cil/test/small1/vararg1.c	/^  int ints;                   \/* We only pass ints to this one *\/$/;"	m	union:vararg_average	file:
invalidStmt	cil/src/cil.ml	/^let invalidStmt = mkStmt (Instr [])$/;"	v
invalidStmt	cil/src/cil.mli	/^val invalidStmt: stmt$/;"	v
ios	cil/src/ext/deadcodeelim.ml	/^	      let ios = IH.find iosh vi.vid in$/;"	v
ios2	cil/src/ext/reachingdefs.ml	/^      try let ios2 = IH.find iosh2 vid in$/;"	v
iosh''	cil/src/ext/reachingdefs.ml	/^	else let iosh'' = IH.copy iosh' in$/;"	v
iosh_combine	cil/src/ext/reachingdefs.ml	/^let iosh_combine iosh1 iosh2 =$/;"	v
iosh_defId_find	cil/src/ext/reachingdefs.ml	/^let iosh_defId_find iosh defId =$/;"	v
iosh_equals	cil/src/ext/reachingdefs.ml	/^let iosh_equals iosh1 iosh2 =$/;"	v
iosh_filter_dead	cil/src/ext/reachingdefs.ml	/^let iosh_filter_dead iosh vs =$/;"	v
iosh_lookup	cil/src/ext/reachingdefs.ml	/^let iosh_lookup iosh vi =$/;"	v
iosh_replace	cil/src/ext/reachingdefs.ml	/^let iosh_replace iosh i vi =$/;"	v
iosh_singleton_lookup	cil/src/ext/reachingdefs.ml	/^let iosh_singleton_lookup iosh vi =$/;"	v
isAbsolute	cil/bin/patcher	/^sub isAbsolute {$/;"	s
isArithmeticType	cil/src/cil.ml	/^let isArithmeticType t = $/;"	v
isArithmeticType	cil/src/cil.mli	/^val isArithmeticType: typ -> bool$/;"	v
isArrayType	cil/src/cil.ml	/^let isArrayType t = $/;"	v
isArrayType	cil/src/cil.mli	/^val isArrayType: typ -> bool$/;"	v
isCompleteProgramRoot	cil/src/rmtmps.ml	/^let isCompleteProgramRoot global =$/;"	v
isCompleteProgramRoot	cil/src/rmtmps.mli	/^val isCompleteProgramRoot : rootsFilter$/;"	v
isCompleteType	cil/src/cil.ml	/^let rec isCompleteType t =$/;"	v
isCompleteType	cil/src/cil.mli	/^val isCompleteType: typ -> bool  $/;"	v
isCompositeType	cil/src/ext/ciltools.ml	/^let rec isCompositeType tp =$/;"	v
isConstant	cil/src/cil.ml	/^let rec isConstant = function$/;"	v
isConstant	cil/src/cil.mli	/^val isConstant: exp -> bool$/;"	v
isDefaultRoot	cil/src/rmtmps.ml	/^let isDefaultRoot = isExportedRoot$/;"	v
isDefaultRoot	cil/src/rmtmps.mli	/^val isDefaultRoot : rootsFilter$/;"	v
isExportedRoot	cil/src/rmtmps.ml	/^let isExportedRoot global =$/;"	v
isExportedRoot	cil/src/rmtmps.mli	/^val isExportedRoot : rootsFilter$/;"	v
isFunPtrType	cil/src/ext/pta/ptranal.ml	/^let isFunPtrType (t : typ) : bool =$/;"	v
isFunctionType	cil/src/cil.ml	/^let isFunctionType t = $/;"	v
isFunctionType	cil/src/cil.mli	/^val isFunctionType: typ -> bool$/;"	v
isInteger	cil/src/cil.ml	/^let rec isInteger : exp -> int64 option = function$/;"	v
isInteger	cil/src/cil.mli	/^val isInteger: exp -> int64 option$/;"	v
isIntegralType	cil/src/cil.ml	/^let isIntegralType t = $/;"	v
isIntegralType	cil/src/cil.mli	/^val isIntegralType: typ -> bool$/;"	v
isNone	cil/src/frontc/frontc.ml	/^let isNone (o : 'a option) : bool =$/;"	v
isOne	cil/src/ext/ciltools.ml	/^let isOne e = $/;"	v
isPatternVar	cil/src/frontc/patch.ml	/^let isPatternVar (s : string) : bool =$/;"	v
isPointerType	cil/src/cil.ml	/^let isPointerType t = $/;"	v
isPointerType	cil/src/cil.mli	/^val isPointerType: typ -> bool$/;"	v
isPragmaRoot	cil/src/rmtmps.ml	/^let isPragmaRoot keepers = function$/;"	v
isRoot	cil/src/rmtmps.ml	/^      let isRoot global =$/;"	v
isSigned	cil/src/cil.ml	/^let isSigned = function$/;"	v
isSigned	cil/src/cil.mli	/^val isSigned: ikind -> bool$/;"	v
isSome	cil/src/ext/crestInstrument.ml	/^let isSome o =$/;"	v
isSymbolicType	cil/src/ext/crestInstrument.ml	/^let isSymbolicType ty = isIntegralType (unrollType ty)$/;"	v
isTypeVolatile	cil/src/ext/expcompare.ml	/^let isTypeVolatile t =$/;"	v
isVar	cil/src/ext/simplify.ml	/^let isVar lv =$/;"	v
isVoidPtrType	cil/src/cil.ml	/^let isVoidPtrType t = $/;"	v
isVoidPtrType	cil/src/cil.mli	/^val isVoidPtrType: typ -> bool$/;"	v
isVoidType	cil/src/cil.ml	/^let isVoidType t = $/;"	v
isVoidType	cil/src/cil.mli	/^val isVoidType: typ -> bool$/;"	v
isZero	cil/src/cil.ml	/^let rec isZero (e: exp) : bool = isInteger e = Some Int64.zero$/;"	v
isZero	cil/src/cil.mli	/^val isZero: exp -> bool$/;"	v
is_bitfield	cil/src/ext/sfi.ml	/^let rec is_bitfield lo = match lo with$/;"	v
is_empty	cil/ocamlutil/intmap.ml	/^let is_empty = function Empty -> true | _ -> false$/;"	v
is_empty	cil/ocamlutil/intmap.mli	/^val is_empty: 'a t -> bool$/;"	v
is_empty	cil/ocamlutil/util.mli	/^  val is_empty : 'a t -> bool$/;"	v	Module:STACK
is_empty	cil/src/ext/pta/setp.ml	/^    let is_empty = function Empty -> true | _ -> false$/;"	v
is_false	cil/src/ext/partial.ml	/^              and is_false e = isZero e$/;"	v
is_global_label	cil/src/ext/pta/golf.ml	/^let is_global_label l = (find l).l_global$/;"	v
is_param_label	cil/src/ext/pta/golf.ml	/^let is_param_label l = (find l).l_param || (find l).l_global$/;"	v
is_ret_label	cil/src/ext/pta/golf.ml	/^let is_ret_label l = (find l).l_ret  || (find l).l_global (* todo - check *)$/;"	v
is_seeded_label	cil/src/ext/pta/golf.ml	/^let is_seeded_label l = (find l).l_seeded$/;"	v
is_true	cil/src/ext/partial.ml	/^              and is_true e =$/;"	v
is_volatile_tp	cil/src/ext/ciltools.ml	/^let is_volatile_tp tp =$/;"	v
isinvalid	cil/src/cil.ml	/^    let isinvalid = $/;"	v
islong	cil/src/cil.ml	/^                (let islong = $/;"	v
islong	cil/src/cil.ml	/^              ++ (let islong = $/;"	v
ist	cil/Makefile	/^	echo "let features : featureDescr list = [" >> $@$/;"	m
iter	cil/ocamlutil/clist.ml	/^let iter (f: 'a -> unit) (l: 'a clist) : unit = $/;"	v
iter	cil/ocamlutil/clist.mli	/^val iter: ('a -> unit) -> 'a clist -> unit$/;"	v
iter	cil/ocamlutil/growArray.mli	/^val iter : ('a -> unit) -> 'a t -> unit$/;"	v
iter	cil/ocamlutil/inthash.ml	/^let iter (f: int -> 'a -> unit) (h: 'a t) : unit =$/;"	v
iter	cil/ocamlutil/inthash.mli	/^val iter: (int -> 'a -> unit) -> 'a t -> unit$/;"	v
iter	cil/ocamlutil/intmap.ml	/^let rec iter f = function$/;"	v
iter	cil/ocamlutil/intmap.mli	/^val iter: (int -> 'a -> unit) -> 'a t -> unit$/;"	v
iter	cil/ocamlutil/util.mli	/^  val iter : ('a -> unit) -> 'a t -> unit$/;"	v	Module:STACK
iter	cil/src/ext/bitmap.ml	/^let iter f t = fold (fun x y -> f y) t ()$/;"	v
iter	cil/src/ext/bitmap.mli	/^val  iter   : (int -> unit) -> t -> unit$/;"	v
iter	cil/src/ext/pta/setp.ml	/^    let rec iter f = function$/;"	v
iter2	cil/ocamlutil/growArray.mli	/^val iter2 : (int -> 'a -> 'b -> unit) -> 'a t -> 'b t -> unit$/;"	v
iterGlobals	cil/src/cil.ml	/^let iterGlobals (fl: file)$/;"	v
iterGlobals	cil/src/cil.mli	/^val iterGlobals: file -> (global -> unit) -> unit$/;"	v
iteri	cil/ocamlutil/growArray.mli	/^val iteri : (int -> 'a -> unit) -> 'a t -> unit$/;"	v
iters_left_	src/run_crest/concolic_search.h	/^  int iters_left_;$/;"	m	class:crest::CfgHeuristicSearch
j	cil/src/ext/ssa.ml	/^  let j = ref(0) in $/;"	v
j'	cil/ocamlutil/pretty.ml	/^	    let j' = succ j in (* eat the d,i,x etc. *)$/;"	v
join	cil/src/ext/pta/golf.mli	/^val join : tau -> tau -> tau$/;"	v
join	cil/src/ext/pta/olf.mli	/^val join : tau -> tau -> tau$/;"	v
join	cil/src/ext/pta/setp.ml	/^    let rec join l x r =$/;"	v
join	cil/src/ext/pta/steensgaard.mli	/^val join : tau -> tau -> tau$/;"	v
join2	cil/src/ext/partial.ml	/^  let join2 (r1 : t) (r2 : t) =$/;"	v
joinStrings	cil/ocamlutil/util.ml	/^let rec joinStrings (sep: string) (sl: string list) = $/;"	v
joinStrings	cil/ocamlutil/util.mli	/^val joinStrings: string -> string list -> string$/;"	v
join_inits	cil/src/ext/pta/golf.mli	/^val join_inits : tau list -> tau$/;"	v
join_inits	cil/src/ext/pta/olf.mli	/^val join_inits : tau list -> tau$/;"	v
join_inits	cil/src/ext/pta/steensgaard.ml	/^let join_inits (tl : tau list) : tau = $/;"	v
join_inits	cil/src/ext/pta/steensgaard.mli	/^val join_inits : tau list -> tau$/;"	v
k	cil/ocamlutil/util.ml	/^        let k = input_line ic in$/;"	v
kCallId	src/base/basic_types.h	/^static const branch_id_t kCallId = -1;$/;"	m	namespace:crest
kInfiniteDistance	src/run_crest/concolic_search.h	/^  static const size_t kInfiniteDistance = 10000;$/;"	m	class:crest::CfgHeuristicSearch
kMaxValue	src/base/basic_types.cc	/^const value_t kMaxValue[] = {$/;"	m	namespace:crest	file:
kMaxValueStr	src/base/basic_types.cc	/^const char* kMaxValueStr[] = {$/;"	m	namespace:crest	file:
kMinValue	src/base/basic_types.cc	/^const value_t kMinValue[] = {$/;"	m	namespace:crest	file:
kMinValueStr	src/base/basic_types.cc	/^const char* kMinValueStr[] = {$/;"	m	namespace:crest	file:
kOpTable	src/libcrest/crest.cc	/^static const int kOpTable[] =$/;"	v	file:
kReturnId	src/base/basic_types.h	/^static const branch_id_t kReturnId = -2;$/;"	m	namespace:crest
keepUnused	cil/src/rmtmps.mli	/^val keepUnused: bool ref (* Set this to true to turn off this module *)$/;"	v
keepers	cil/src/rmtmps.ml	/^      let keepers = categorizePragmas file in$/;"	v
keys	cil/ocamlutil/util.mli	/^val keys: ('a, 'b) Hashtbl.t -> 'a list$/;"	v
kindOfSizeOf	cil/src/cil.ml	/^let kindOfSizeOf = ref IUInt$/;"	v
kindOfSizeOf	cil/src/cil.mli	/^val kindOfSizeOf: ikind ref$/;"	v
kinteger	cil/src/cil.ml	/^let kinteger (k: ikind) (i: int) = kinteger64 k (Int64.of_int i)$/;"	v
kinteger	cil/src/cil.mli	/^val kinteger: ikind -> int -> exp$/;"	v
kinteger64	cil/src/cil.ml	/^let kinteger64 (k: ikind) (i: int64) : exp = $/;"	v
kinteger64	cil/src/cil.mli	/^val kinteger64: ikind -> int64 -> exp$/;"	v
l	cil/obj/x86_LINUX/cparser.ml	/^                                 ( let l = currentLoc () in$/;"	v
l	cil/obj/x86_LINUX/formatparse.ml	/^                              let l = (fst _1) args in$/;"	v
l	cil/ocamlutil/errormsg.ml	/^  let l = String.length str1 in$/;"	v
l	cil/src/cil.ml	/^  let l = String.length s in$/;"	v
l'	cil/src/cil.ml	/^      let l' = $/;"	v
lab	cil/src/check.ml	/^          let lab = $/;"	v
label	cil/src/cil.mli	/^and label = $/;"	t
labels	cil/src/check.ml	/^let labels: (string, unit) H.t = H.create 17$/;"	v
labels	cil/src/cil.mli	/^    mutable labels: label list;        $/;"	r	type:stmt
labels'	cil/src/cil.ml	/^  let labels' = $/;"	v
labelsToKeep	cil/src/rmtmps.ml	/^let labelsToKeep (ll: label list) : (string * location * bool) * label list = $/;"	v
last	cil/src/cil.ml	/^          let last = self#getLastNamedArgument vi.vname in$/;"	v
lastFileName	cil/src/cil.ml	/^  val mutable lastFileName = ""$/;"	v
lastPathSep	cil/src/cil.ml	/^        let lastPathSep = findLastPathSep (len - 1) in$/;"	v
lastTime	cil/ocamlutil/stats.ml	/^let lastTime = ref 0.0$/;"	v
lastTime	cil/ocamlutil/stats.mli	/^val lastTime: float ref$/;"	v
last_str	cil/src/frontc/whitetrack.ml	/^let last_str = ref ""$/;"	v
last_used_state	cil/src/ext/partial.ml	/^    mutable last_used_state : S.t option;$/;"	r	type:sinfo
last_was_maybe	cil/src/frontc/whitetrack.ml	/^let last_was_maybe = ref false    $/;"	v
lastline	cil/src/frontc/whitetrack.ml	/^let lastline = ref 0$/;"	v
leaveAlone	cil/lib/Cilly.pm	/^sub leaveAlone {$/;"	s
leftflush	cil/ocamlutil/pretty.ml	/^let leftflush     = LeftFlush$/;"	v
leftflush	cil/ocamlutil/pretty.mli	/^val leftflush    : doc$/;"	v	function:++
len	cil/ocamlutil/pretty.ml	/^    let len = String.length str in$/;"	v
len	cil/src/ext/blockinggraph.ml	/^          let len = List.length instrs in$/;"	v
len	cil/src/mergecil.ml	/^    let len = List.length ci.cfields in$/;"	v
lenOfArray	cil/src/cil.ml	/^let lenOfArray (eo: exp option) : int = $/;"	v
lenOfArray	cil/src/cil.mli	/^val lenOfArray: exp option -> int$/;"	v
length	cil/ocamlutil/clist.ml	/^let length l = length 0 l  (* The external version *)$/;"	v
length	cil/ocamlutil/clist.ml	/^let rec length (acc: int) = function$/;"	v
length	cil/ocamlutil/clist.mli	/^val length: 'a clist -> int   $/;"	v
length	cil/ocamlutil/inthash.mli	/^val length : 'a t -> int$/;"	v
length	cil/ocamlutil/longarray.mli	/^val length : 'a t -> int$/;"	v
length	cil/ocamlutil/util.mli	/^  val length : 'a t -> int$/;"	v	Module:STACK
leni	cil/src/testcil.ml	/^            let leni = $/;"	v
lexbuf	cil/ocamlutil/errormsg.ml	/^  let lexbuf = Lexing.from_channel inchan in$/;"	v
lhost	cil/src/cil.mli	/^and lhost = $/;"	t
li	cil/src/ext/pta/golf.ml	/^  let li = find l$/;"	v
libDir	cil/src/cilutil.ml	/^let libDir = ref ""$/;"	v
libdir	cil/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
limit	cil/src/escape.ml	/^  let limit upper probe = (Int64.to_float (Int64.sub upper probe)) > 0.5 in$/;"	v
line	cil/ocamlutil/errormsg.ml	/^      line: int;    (** The line number *)$/;"	r	type:location
line	cil/ocamlutil/errormsg.mli	/^      line: int;    (** The line number *)$/;"	r	type:location
line	cil/ocamlutil/pretty.ml	/^let line          = Line$/;"	v
line	cil/ocamlutil/pretty.mli	/^val line         : doc$/;"	v	function:++
line	cil/src/cil.mli	/^    line: int;		   (** The line number. -1 means "do not know" *)$/;"	r	type:location
line	cil/src/frontc/cprint.ml	/^type loc = { line : int; file : string }$/;"	r	type:loc
lineDirective	cil/bin/patcher	/^sub lineDirective {$/;"	s
lineDirective	cil/lib/Cilly.pm	/^sub lineDirective {$/;"	s
lineno	cil/src/frontc/cabs.ml	/^ lineno : int;$/;"	r	type:cabsloc
link	cil/lib/Cilly.pm	/^sub link {$/;"	s
link	cil/src/cil.ml	/^let link source dest = begin$/;"	v
link	cil/src/ext/ssa.ml	/^  let link v w =$/;"	v
linkOutputFile	cil/lib/Cilly.pm	/^sub linkOutputFile {$/;"	s
link_after_cil	cil/lib/Cilly.pm	/^sub link_after_cil {$/;"	s
linktolib	cil/lib/Cilly.pm	/^sub linktolib {$/;"	s
listInit	cil/src/ext/predabst.ml	/^    let rec listInit n x =$/;"	v
list_append	cil/ocamlutil/util.mli	/^val list_append: ('a list) -> ('a list) -> ('a list) (* tail-recursive append*)$/;"	v
list_drop	cil/ocamlutil/util.mli	/^val list_drop : int -> 'a list -> 'a list$/;"	v
list_droptail	cil/ocamlutil/util.ml	/^let list_droptail (n : int) (xs : 'a list) : 'a list =$/;"	v
list_droptail	cil/ocamlutil/util.mli	/^val list_droptail : int -> 'a list -> 'a list$/;"	v
list_find_first	cil/ocamlutil/util.ml	/^let rec list_find_first (l: 'a list) (f: 'a -> 'b option) : 'b option = $/;"	v
list_find_first	cil/ocamlutil/util.mli	/^val list_find_first: 'a list -> ('a -> 'b option) -> 'b option $/;"	v
list_fold_lefti	cil/ocamlutil/util.ml	/^let list_fold_lefti (f: 'acc -> int -> 'a -> 'acc) (start: 'acc) $/;"	v
list_fold_lefti	cil/ocamlutil/util.mli	/^val list_fold_lefti: ('acc -> int -> 'a -> 'acc) -> 'acc -> 'a list -> 'acc$/;"	v
list_head_default	cil/ocamlutil/util.mli	/^val list_head_default: 'a -> 'a list -> 'a$/;"	v
list_init	cil/ocamlutil/util.ml	/^let list_init (len : int) (init_fun : int -> 'a) : 'a list =$/;"	v
list_init	cil/ocamlutil/util.mli	/^val list_init : int -> (int -> 'a) -> 'a list$/;"	v
list_insert_by	cil/ocamlutil/util.mli	/^val list_insert_by: ('a -> 'a -> int) -> 'a -> 'a list -> 'a list$/;"	v
list_iter3	cil/ocamlutil/util.mli	/^val list_iter3 : ('a -> 'b -> 'c -> unit) ->$/;"	v
list_iteri	cil/ocamlutil/util.ml	/^let list_iteri (f: int -> 'a -> unit) (l: 'a list) : unit = $/;"	v
list_iteri	cil/ocamlutil/util.mli	/^val list_iteri: (int -> 'a -> unit) -> 'a list -> unit$/;"	v
list_mapi	cil/ocamlutil/util.ml	/^let list_mapi (f: int -> 'a -> 'b) (l: 'a list) : 'b list = $/;"	v
list_mapi	cil/ocamlutil/util.mli	/^val list_mapi: (int -> 'a -> 'b) -> 'a list -> 'b list$/;"	v
list_span	cil/ocamlutil/util.ml	/^let rec list_span (p : 'a -> bool) (xs : 'a list) : 'a list * 'a list = $/;"	v
list_span	cil/ocamlutil/util.mli	/^val list_span: ('a -> bool) -> ('a list) -> 'a list * 'a list$/;"	v
listifyOnto	cil/ocamlutil/clist.ml	/^let rec listifyOnto (tail: 'a list) = function$/;"	v
literal	cil/ocamlutil/pretty.ml	/^  let rec literal acc i = $/;"	v
little_endian	cil/obj/x86_LINUX/machdep.ml	/^  little_endian: bool; (* whether the machine is little endian *)$/;"	r	type:mach
livevars	cil/src/ext/ssa.mli	/^    mutable livevars: (reg * int) list;  $/;"	r	type:cfgBlock
loadBinaryFile	cil/src/cil.mli	/^val loadBinaryFile : string -> file $/;"	v
loadConfiguration	cil/ocamlutil/util.ml	/^let loadConfiguration (fname: string) : unit = $/;"	v
loadTop	cil/doc/attributes.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/changes.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil001.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil002.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil003.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil004.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil007.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil009.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil010.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil011.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil012.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil015.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil016.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil017.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil018.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cil019.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/cilly.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/ciltoc.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/ext.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/merger.html	/^function loadTop(url) {$/;"	f
loadTop	cil/doc/patcher.html	/^function loadTop(url) {$/;"	f
loc	cil/obj/x86_LINUX/cparser.ml	/^          ( let (loc, specs, decl) = _1 in$/;"	v
loc	cil/src/ext/stackoverflow.ml	/^              let loc = makeLocalVar fdec "__a_local" intType in$/;"	v
loc	cil/src/frontc/cprint.ml	/^type loc = { line : int; file : string }$/;"	t
locUnknown	cil/ocamlutil/errormsg.ml	/^let locUnknown = { file = ""; hfile = ""; line = -1; hline = -1 }$/;"	v
locUnknown	cil/ocamlutil/errormsg.mli	/^val locUnknown: location$/;"	v
location	cil/ocamlutil/errormsg.ml	/^type location = $/;"	t
location	cil/ocamlutil/errormsg.mli	/^type location = $/;"	t
location	cil/src/cil.mli	/^and location = { $/;"	t
locc	cil/src/ext/pta/olf.ml	/^  let locc = C.add my_absloc C.empty$/;"	v
log	cil/ocamlutil/errormsg.ml	/^let log (fmt : ('a,unit,doc,unit) format4) : 'a = $/;"	v
log	cil/ocamlutil/errormsg.mli	/^val log:           ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
logAlloc	cil/src/ext/sfi.ml	/^let logAlloc = mkProto "logAlloc" [ ("addr", voidPtrType, []);$/;"	v
logCalls	cil/src/cilutil.ml	/^let logCalls = ref false (* Whether to produce a log with all the function $/;"	v
logCallsVisitorClass	cil/src/ext/logcalls.ml	/^class logCallsVisitorClass = object$/;"	c
logChannel	cil/ocamlutil/errormsg.ml	/^let logChannel : out_channel ref = ref stderr$/;"	v
logChannel	cil/ocamlutil/errormsg.mli	/^val logChannel : out_channel ref$/;"	v
logFree	cil/src/ext/sfi.ml	/^let logFree = mkProto "logFree" [ ("addr", voidPtrType, []);$/;"	v
logReads	cil/src/ext/sfi.ml	/^let logReads = mkProto "logRead" [ ("addr", voidPtrType, []);$/;"	v
logStackFrame	cil/src/ext/sfi.ml	/^let logStackFrame  = mkProto "logStackFrame" [ ("func", charPtrType, []) ]$/;"	v
logWriteVisitor	cil/src/ext/logwrites.ml	/^class logWriteVisitor = object$/;"	c
logWrites	cil/src/cilutil.ml	/^let logWrites = ref false (* Whether to produce a log with all the mem $/;"	v
logWrites	cil/src/ext/sfi.ml	/^let logWrites = mkProto "logWrite" [ ("addr", voidPtrType, []);$/;"	v
logg	cil/ocamlutil/errormsg.ml	/^let logg (fmt : ('a,unit,doc,unit) format4) : 'a =$/;"	v
logg	cil/ocamlutil/errormsg.mli	/^val logg:          ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
longDoubleType	cil/src/cil.ml	/^  let longDoubleType = TFloat (FLongDouble, []) in$/;"	v
longType	cil/src/cil.ml	/^let longType = TInt(ILong,[])$/;"	v
longType	cil/src/cil.mli	/^val longType: typ$/;"	v
longlong	cil/ocamlutil/perfcount.c	17;"	d	file:
longlong	cil/ocamlutil/perfcount.c	30;"	d	file:
lookupTime	cil/ocamlutil/stats.ml	/^let lookupTime (label:string) : float =$/;"	v
lookupTime	cil/ocamlutil/stats.mli	/^val lookupTime: string -> float$/;"	v
loop	cil/ocamlutil/errormsg.ml	/^  let rec loop (copyto: int) (i: int) = $/;"	v
loop	cil/ocamlutil/pretty.ml	/^    let rec loop (acc: doc) i =$/;"	v
loop	cil/src/cil.ml	/^  let rec loop (acc: global list) = function$/;"	v
loop	cil/src/cil.ml	/^  let rec loop t = $/;"	v
loop	cil/src/ext/deadcodeelim.ml	/^	    let rec loop n =$/;"	v
loop	cil/src/ext/deadcodeelim.ml	/^	  let rec loop n =$/;"	v
loop	cil/src/ext/deadcodeelim.ml	/^	let rec loop n =$/;"	v
loop	cil/src/ext/deadcodeelim.ml	/^  let rec loop fd =$/;"	v
loop	cil/src/frontc/frontc.ml	/^  let rec loop (d : Cabs.definition) = begin$/;"	v
loop	cil/src/frontc/patch.ml	/^  let rec loop pat tgt : binding list =$/;"	v
loopArgs	cil/src/check.ml	/^          let rec loopArgs targs formals = $/;"	v
loopCont	cil/ocamlutil/pretty.ml	/^  let rec loopCont (abscol: int) (d: doc) (cont: int -> unit) : unit $/;"	v
loopElems	cil/src/cil.ml	/^      let rec loopElems acc i = $/;"	v
loopFields	cil/src/check.ml	/^                let rec loopFields $/;"	v
loopFormals	cil/src/cil.ml	/^  let rec loopFormals = function$/;"	v
lowerConstants	cil/src/cil.mli	/^val lowerConstants: bool ref$/;"	v
lowerEnumVisitor	cil/src/cillower.ml	/^let lowerEnumVisitor = new lowerEnumVisitorClass$/;"	v
lowerEnumVisitor	cil/src/cillower.mli	/^val lowerEnumVisitor : Cil.cilVisitor$/;"	v
lowercase	cil/libstr/src/case.c	/^void lowercase (char str[])$/;"	f
lu	cil/src/cil.ml	/^let lu = locUnknown$/;"	v
lu	cil/src/frontc/cprint.ml	/^let lu = {line = -1; file = "loc unknown";}$/;"	v
lv	cil/src/ext/dataslicing.ml	/^      let lv =$/;"	v
lv'	cil/src/cil.ml	/^      let lv' = fLval lv in let fn' = fExp fn in $/;"	v
lv'	cil/src/cil.ml	/^      let lv' = vLval lv in$/;"	v
lv'	cil/src/ext/simplify.ml	/^                  let lv' = $/;"	v
lvPtr	cil/src/ext/sfi.ml	/^    let lvPtr = mkCast ~e:(mkAddrOf (new_lv)) ~newt:(charPtrType) in$/;"	v
lval	cil/obj/x86_LINUX/formatparse.mli	/^val lval :$/;"	v
lval	cil/src/cil.mli	/^and lval =$/;"	t
lvalFinderClass	cil/src/ext/availexps.ml	/^class lvalFinderClass lv br = object(self)$/;"	c
lvalFinderClass	cil/src/ext/availexpslv.ml	/^class lvalFinderClass lv br = object(self)$/;"	c
lval_has_addrof_or_global	cil/src/ext/availexpslv.ml	/^let lval_has_addrof_or_global lv =$/;"	v
lval_has_lval	cil/src/ext/availexpslv.ml	/^let lval_has_lval lv (host,hostoff) =$/;"	v
lval_has_mem_read	cil/src/ext/availexpslv.ml	/^let lval_has_mem_read lv =$/;"	v
lval_has_vi	cil/src/ext/availexpslv.ml	/^let lval_has_vi vi lv =$/;"	v
lvalue	cil/src/ext/pta/golf.mli	/^type lvalue$/;"	t
lvalue	cil/src/ext/pta/olf.mli	/^type lvalue$/;"	t
lvalue	cil/src/ext/pta/steensgaard.mli	/^type lvalue$/;"	t
lvh_equals	cil/src/ext/availexpslv.ml	/^let lvh_equals lvh1 lvh2 =$/;"	v
lvh_handle_inst	cil/src/ext/availexpslv.ml	/^let lvh_handle_inst i lvh = $/;"	v
lvh_kill_addrof_or_global	cil/src/ext/availexpslv.ml	/^let lvh_kill_addrof_or_global lvh =$/;"	v
lvh_kill_mem	cil/src/ext/availexpslv.ml	/^let lvh_kill_mem lvh =$/;"	v
lvh_kill_vi	cil/src/ext/availexpslv.ml	/^let lvh_kill_vi lvh vi =$/;"	v
mach	cil/obj/x86_LINUX/machdep.ml	/^type mach = {$/;"	t
main	cil/config.guess	/^		main()$/;"	f
main	cil/config.guess	/^	main ()$/;"	f
main	cil/config.guess	/^main ()$/;"	f
main	cil/libstr/config.guess	/^		main()$/;"	f
main	cil/libstr/config.guess	/^	main ()$/;"	f
main	cil/libstr/config.guess	/^main ()$/;"	f
main	cil/libstr/ltconfig	/^main() { void *self, *ptr1, *ptr2; self=dlopen(0,LTDL_GLOBAL|LTDL_LAZY_OR_NOW);$/;"	f
main	cil/libstr/ltconfig	/^main(){nm_test_var='a';nm_test_func();return(0);}$/;"	f
main	cil/ocamlutil/perfcount.c	/^int main() {$/;"	f
main	cil/src/ext/stackoverflow.ml	/^    let main = H.find functionNodes "main" in$/;"	v
main	cil/src/machdep.c	/^int main() {$/;"	f
main	cil/test/small1/hello.c	/^int main() {$/;"	f
main	cil/test/small1/init.c	/^int main() {$/;"	f
main	cil/test/small1/init1.c	/^int main() {$/;"	f
main	cil/test/small1/vararg1.c	/^int main( void )$/;"	f
main	cil/test/small1/wchar1.c	/^int main() {$/;"	f
main	src/process_cfg/process_cfg.cc	/^int main(void) {$/;"	f
main	src/run_crest/run_crest.cc	/^int main(int argc, char* argv[]) {$/;"	f
main	src/tools/print_execution.cc	/^int main(void) {$/;"	f
main	test/cfg_search_test.c	/^int main(void) {$/;"	f
main	test/cfg_test.c	/^int main(void) {$/;"	f
main	test/concrete_return.c	/^int main(void) {$/;"	f
main	test/function.c	/^int main(void) {$/;"	f
main	test/math.c	/^int main(void) {$/;"	f
main	test/simple.c	/^int main(void) {$/;"	f
main	test/structure_return.c	/^int main(void) {$/;"	f
main	test/structure_test.c	/^int main(void) {$/;"	f
main	test/uniform_test.c	/^int main(void) {$/;"	f
make	cil/ocamlutil/growArray.ml	/^let make (initsz: int) (fill: 'a fill) : 'a t = $/;"	v
make	cil/ocamlutil/growArray.mli	/^val make : int -> 'a fill -> 'a t$/;"	v
make	cil/src/ext/bitmap.ml	/^let make size = $/;"	v
make	cil/src/ext/bitmap.mli	/^val  make : int -> t$/;"	v
makeAllBottom	cil/src/ext/predabst.ml	/^    let makeAllBottom (eh : exp IH.t) : boolLat IH.t =$/;"	v
makeAndDumpBlockingGraphs	cil/src/ext/blockinggraph.ml	/^let makeAndDumpBlockingGraphs () : unit =$/;"	v
makeAndDumpFunctionCallGraph	cil/src/ext/stackoverflow.ml	/^let makeAndDumpFunctionCallGraph (f: file) = $/;"	v
makeAndDumpFunctionCallGraph	cil/src/ext/stackoverflow.mli	/^val makeAndDumpFunctionCallGraph: Cil.file -> unit$/;"	v
makeBasic	cil/src/ext/simplify.ml	1;"	M
makeBlockingGraph	cil/src/ext/blockinggraph.ml	/^let makeBlockingGraph (start: node) =$/;"	v
makeCFG	cil/src/cilutil.ml	/^let makeCFG = ref false (* turn the input CIL file into something more like$/;"	v
makeDisjunction	cil/src/ext/predabst.ml	/^      let makeDisjunction pl =$/;"	v
makeFormalPreds	cil/src/ext/predabst.ml	/^    let makeFormalPreds (locals : varinfo list)$/;"	v
makeFormalVar	cil/src/cil.ml	/^let makeFormalVar fdec ?(where = "$") name typ : varinfo = $/;"	v
makeFormalVar	cil/src/cil.mli	/^val makeFormalVar: fundec -> ?where:string -> string -> typ -> varinfo$/;"	v
makeFunctionCallGraph	cil/src/ext/blockinggraph.ml	/^let makeFunctionCallGraph (f: Cil.file) : unit = $/;"	v
makeFunctionCallGraph	cil/src/ext/stackoverflow.ml	/^let makeFunctionCallGraph (f: Cil.file) : unit = $/;"	v
makeFunctionSigs	cil/src/ext/predabst.ml	/^    let makeFunctionSigs (f:file) =$/;"	v
makeGlobalVar	cil/src/cil.ml	/^let makeGlobalVar name typ =$/;"	v
makeGlobalVar	cil/src/cil.mli	/^val makeGlobalVar: string -> typ -> varinfo$/;"	v
makeInstr	cil/src/formatcil.ml	/^  let makeInstr () = $/;"	v
makeLocalVar	cil/src/cil.mli	/^val makeLocalVar: fundec -> ?insert:bool -> string -> typ -> varinfo$/;"	v
makeOutArguments	cil/lib/Cilly.pm	/^sub makeOutArguments { $/;"	s
makeStartNodeLinks	cil/src/ext/blockinggraph.ml	/^let makeStartNodeLinks () : unit =$/;"	v
makeStartNodeTable	cil/src/ext/blockinggraph.ml	/^let makeStartNodeTable (globs: global list) : global list =$/;"	v
makeTempVar	cil/src/cil.mli	/^val makeTempVar: fundec -> ?name: string -> ?descr:Pretty.doc ->$/;"	v
makeValidSymbolName	cil/src/cil.ml	/^let makeValidSymbolName (s: string) = $/;"	v
makeVarinfo	cil/src/cil.ml	/^let makeVarinfo global name typ =$/;"	v
makeVarinfo	cil/src/cil.mli	/^val makeVarinfo: bool -> string -> typ -> varinfo$/;"	v
makeZeroInit	cil/src/cil.mli	/^val makeZeroInit: typ -> init$/;"	v
make_bound	cil/src/ext/pta/golf.ml	/^let make_bound (i, a : int * label) : lblinfo bound =$/;"	v
make_bound	cil/src/ext/pta/olf.ml	/^let make_bound (a : c_absloc) : c_abslocinfo bound =$/;"	v
make_c_absloc	cil/src/ext/pta/olf.ml	/^let make_c_absloc (is_top : bool) (name : string) (vio : Cil.varinfo option) =$/;"	v
make_fresh	cil/src/ext/pta/golf.ml	/^let make_fresh (name : string) : tau =$/;"	v
make_fresh	cil/src/ext/pta/golf.mli	/^val make_fresh : string -> tau$/;"	v
make_fresh	cil/src/ext/pta/olf.ml	/^let make_fresh (name : string) : tau =$/;"	v
make_fresh	cil/src/ext/pta/olf.mli	/^val make_fresh : string -> tau$/;"	v
make_fresh	cil/src/ext/pta/steensgaard.ml	/^let make_fresh (name : string) : tau =$/;"	v
make_fresh	cil/src/ext/pta/steensgaard.mli	/^val make_fresh : string -> tau$/;"	v
make_function	cil/src/ext/pta/golf.ml	/^let make_function (name : string) (formals : lvalue list) (ret : tau) : tau =$/;"	v
make_function	cil/src/ext/pta/golf.mli	/^val make_function :  string -> lvalue list -> tau -> tau$/;"	v
make_function	cil/src/ext/pta/olf.mli	/^val make_function :  string -> lvalue list -> tau -> tau$/;"	v
make_function	cil/src/ext/pta/steensgaard.ml	/^let make_function (name : string) (formals : lvalue list) (ret : tau) : tau = $/;"	v
make_function	cil/src/ext/pta/steensgaard.mli	/^val make_function :  string -> lvalue list -> tau -> tau$/;"	v
make_label	cil/src/ext/pta/golf.ml	/^let make_label (is_global : bool) (name : string) (vio : Cil.varinfo option) : label =$/;"	v
make_lval	cil/src/ext/pta/steensgaard.ml	/^let make_lval (lbl,t : label * tau) : lvalue = $/;"	v
make_lvalue	cil/src/ext/pta/golf.ml	/^let make_lvalue (is_global : bool) (name : string) (vio : Cil.varinfo option) : lvalue =$/;"	v
make_lvalue	cil/src/ext/pta/golf.mli	/^val make_lvalue : bool -> string -> (Cil.varinfo option) -> lvalue$/;"	v
make_lvalue	cil/src/ext/pta/olf.ml	/^let make_lvalue (b : bool ) (name : string) (vio : Cil.varinfo option) =$/;"	v
make_lvalue	cil/src/ext/pta/olf.mli	/^val make_lvalue : bool -> string -> (Cil.varinfo option) -> lvalue$/;"	v
make_lvalue	cil/src/ext/pta/steensgaard.ml	/^let make_lvalue (is_global : bool) (name : string) : lvalue = $/;"	v
make_lvalue	cil/src/ext/pta/steensgaard.mli	/^val make_lvalue : bool -> string -> lvalue$/;"	v
make_path	cil/src/ext/pta/golf.ml	/^let make_path (k, l, l', b) =$/;"	v
make_summary	cil/src/ext/pta/golf.ml	/^let make_summary = leq_label$/;"	v
make_undefined_lvalue	cil/src/ext/pta/olf.ml	/^let make_undefined_lvalue () =$/;"	v
make_undefined_rvalue	cil/src/ext/pta/olf.ml	/^let make_undefined_rvalue () =$/;"	v
make_var_hash	cil/src/ext/availexps.ml	/^let make_var_hash fd =$/;"	v
makeit	cil/src/cil.ml	/^  let makeit () : varinfo = $/;"	v
map	cil/ocamlutil/clist.ml	/^let map (f: 'a -> 'b) (l: 'a clist) : 'b clist = $/;"	v
map	cil/ocamlutil/clist.mli	/^val map: ('a -> 'b) -> 'a clist -> 'b clist $/;"	v
map	cil/ocamlutil/intmap.ml	/^let rec map f = function$/;"	v
map	cil/ocamlutil/intmap.mli	/^val map: ('a -> 'b) -> 'a t -> 'b t$/;"	v
map	cil/ocamlutil/longarray.mli	/^val map : ('a -> 'b) -> 'a t -> 'b t$/;"	v
mapGlobals	cil/src/cil.ml	/^let mapGlobals (fl: file) $/;"	v
mapGlobals	cil/src/cil.mli	/^val mapGlobals: file -> (global -> global) -> unit$/;"	v
mapNoCopy	cil/ocamlutil/util.mli	/^val mapNoCopy: ('a -> 'a) -> 'a list -> 'a list$/;"	v
mapNoCopy	cil/src/cil.ml	/^let rec mapNoCopy (f: 'a -> 'a) = function$/;"	v
mapNoCopy	cil/src/frontc/cabsvisit.ml	/^let rec mapNoCopy (f: 'a -> 'a) = function$/;"	v
mapNoCopyList	cil/ocamlutil/util.ml	/^let rec mapNoCopyList (f: 'a -> 'a list) = function$/;"	v
mapNoCopyList	cil/ocamlutil/util.mli	/^val mapNoCopyList: ('a -> 'a list) -> 'a list -> 'a list$/;"	v
mapNoCopyList	cil/src/cil.ml	/^let rec mapNoCopyList (f: 'a -> 'a list) = function$/;"	v
mapNoCopyList	cil/src/frontc/cabsvisit.ml	/^let rec mapNoCopyList (f: 'a -> 'a list) = function$/;"	v
mapOptional	cil/src/ext/crestInstrument.ml	/^let rec mapOptional f ls =$/;"	v
mapi	cil/ocamlutil/intmap.ml	/^let rec mapi f = function$/;"	v
mapi	cil/ocamlutil/intmap.mli	/^val mapi: (int -> 'a -> 'b) -> 'a t -> 'b t$/;"	v
mark	cil/ocamlutil/pretty.ml	/^let mark          = Mark$/;"	v
mark	cil/ocamlutil/pretty.mli	/^val mark: doc$/;"	v	function:++
mark	cil/src/ext/astslicer.ml	/^  let mark ht stmt wanted = match wanted with$/;"	v
mark	cil/src/ext/astslicer.ml	/^type mark = Wanted | Unwanted | Unspecified$/;"	t
markReachable	cil/src/rmtmps.ml	/^let markReachable file isRoot =$/;"	v
markReachableVisitor	cil/src/rmtmps.ml	/^class markReachableVisitor $/;"	c
markUsedLabels	cil/src/rmtmps.ml	/^class markUsedLabels (labelMap: (string, unit) H.t) = object$/;"	c
markVar	cil/src/ext/blockinggraph.ml	/^let markVar (vi: varinfo) : unit =$/;"	v
markYieldPoints	cil/src/ext/blockinggraph.ml	/^let markYieldPoints (n: node) : unit =$/;"	v
mark_file	cil/src/ext/astslicer.ml	/^let mark_file (f : Cil.file) (names : (string, mark) Hashtbl.t) = $/;"	v
markup	cil/ocamlutil/pretty.ml	/^let markup d = mark ++ d ++ unmark$/;"	v
markup	cil/ocamlutil/pretty.mli	/^val markup: doc -> doc$/;"	v	function:++
matchBinopEq	cil/obj/x86_LINUX/formatparse.ml	/^let matchBinopEq (bopeq: binop -> bool) lvt et = $/;"	v
matchCompInfo	cil/src/mergecil.ml	/^and matchCompInfo (oldfidx: int) (oldci: compinfo) $/;"	v
matchEnumInfo	cil/src/mergecil.ml	/^and matchEnumInfo (oldfidx: int) (oldei: enuminfo) $/;"	v
matchFloatType	cil/obj/x86_LINUX/formatparse.ml	/^let matchFloatType (fk: fkind) (t:typ) : formatArg list option = $/;"	v
matchInlines	cil/src/mergecil.ml	/^let matchInlines (oldfidx: int) (oldi: varinfo) $/;"	v
matchIntType	cil/obj/x86_LINUX/formatparse.ml	/^let matchIntType (ik: ikind) (t:typ) : formatArg list option = $/;"	v
matchTypeInfo	cil/src/mergecil.ml	/^and matchTypeInfo (oldfidx: int) (oldti: typeinfo) $/;"	v
matchVarinfo	cil/src/mergecil.ml	/^  let matchVarinfo (vi: varinfo) (l: location * int) = $/;"	v
matched_backward_rules	cil/src/ext/pta/golf.ml	/^    let matched_backward_rules p =$/;"	v
matching	cil/src/ext/pta/golf.ml	/^                       let matching =$/;"	v
matching	cil/src/ext/pta/golf.ml	/^               let matching =$/;"	v
max_branch_	src/run_crest/concolic_search.h	/^  branch_id_t max_branch_;$/;"	m	class:crest::Search
max_depth_	src/run_crest/concolic_search.h	/^  int max_depth_;$/;"	m	class:crest::BoundedDepthFirstSearch
max_depth_	src/run_crest/concolic_search.h	/^  size_t max_depth_;$/;"	m	class:crest::UniformRandomSearch
max_elt	cil/src/ext/pta/setp.ml	/^    let rec max_elt = function$/;"	v
max_function_	src/run_crest/concolic_search.h	/^  function_id_t max_function_;$/;"	m	class:crest::Search
max_init_index	cil/ocamlutil/growArray.ml	/^let max_init_index (ga: 'a t) : int =$/;"	v
max_init_index	cil/ocamlutil/growArray.mli	/^val max_init_index : 'a t -> int$/;"	v
max_iters_	src/run_crest/concolic_search.h	/^  const int max_iters_; $/;"	m	class:crest::Search
may_alias	cil/src/ext/pta/golf.ml	/^let may_alias (t1 : tau) (t2 : tau) : bool =$/;"	v
may_alias	cil/src/ext/pta/golf.mli	/^val may_alias : tau -> tau -> bool$/;"	v
may_alias	cil/src/ext/pta/olf.ml	/^let may_alias (t1 : tau) (t2 : tau) : bool =$/;"	v
may_alias	cil/src/ext/pta/olf.mli	/^val may_alias : tau -> tau -> bool$/;"	v
may_alias	cil/src/ext/pta/ptranal.mli	/^val may_alias : Cil.exp -> Cil.exp -> bool$/;"	v
mem	cil/ocamlutil/inthash.ml	/^let mem h key =$/;"	v
mem	cil/ocamlutil/inthash.mli	/^val mem: 'a t -> int -> bool$/;"	v
mem	cil/ocamlutil/intmap.ml	/^let rec mem x = function$/;"	v
mem	cil/ocamlutil/intmap.mli	/^val mem: int -> 'a t -> bool$/;"	v
mem	cil/src/ext/pta/setp.ml	/^    let rec mem x = function$/;"	v
memReadOrAddrOfFinderClass	cil/src/ext/availexpslv.ml	/^class memReadOrAddrOfFinderClass br = object(self)$/;"	c
mem_	src/base/symbolic_interpreter.h	/^  map<addr_t,SymbolicExpr*> mem_;$/;"	m	class:crest::SymbolicInterpreter
member_one	cil/test/small1/init.c	/^enum { member_one, member_two, member_three };$/;"	e	enum:__anon6	file:
member_three	cil/test/small1/init.c	/^enum { member_one, member_two, member_three };$/;"	e	enum:__anon6	file:
member_two	cil/test/small1/init.c	/^enum { member_one, member_two, member_three };$/;"	e	enum:__anon6	file:
memoize	cil/ocamlutil/inthash.ml	/^let memoize (h: 'a t) (key: int) (f: int -> 'a) : 'a = $/;"	v
memoize	cil/ocamlutil/inthash.mli	/^val memoize: 'a t -> int -> (int -> 'a) -> 'a$/;"	v
memoize	cil/ocamlutil/util.mli	/^val memoize: ('a, 'b) Hashtbl.t ->$/;"	v
memory	cil/test/small1/init1.c	/^} memory[10] = { 1 };$/;"	v	typeref:struct:__anon7
merge	cil/ocamlutil/intmap.ml	/^let merge t1 t2 =$/;"	v
merge	cil/src/ext/pta/setp.ml	/^    let rec merge t1 t2 =$/;"	v
merge	cil/src/mergecil.ml	/^let merge (files: file list) (newname: string) : file = $/;"	v
merge	cil/src/mergecil.mli	/^val merge: Cil.file list -> string -> Cil.file$/;"	v
mergePushGlobal	cil/src/mergecil.ml	/^let mergePushGlobal (g: global) : unit = $/;"	v
mergePushGlobals	cil/src/mergecil.ml	/^let mergePushGlobals gl = List.iter mergePushGlobal gl$/;"	v
merge_cache	cil/src/ext/pta/steensgaard.ml	/^and merge_cache (rep : tau) (i : int) (p,t' : polarity * tau) : unit =$/;"	v
min_binding	cil/ocamlutil/intmap.ml	/^let rec min_binding = function$/;"	v
min_elt	cil/src/ext/pta/setp.ml	/^    let rec min_elt = function$/;"	v
missingFieldName	cil/src/cil.ml	/^let missingFieldName = "___missing_field_name"$/;"	v
missingFieldName	cil/src/cil.mli	/^val missingFieldName: string $/;"	v
mkAddrOf	cil/src/cil.mli	/^val mkAddrOf: lval -> exp               $/;"	v
mkAddrOrStartOf	cil/src/cil.ml	/^let mkAddrOrStartOf (lv: lval) : exp = $/;"	v
mkAddrOrStartOf	cil/src/cil.mli	/^val mkAddrOrStartOf: lval -> exp$/;"	v
mkArrayType	cil/src/testcil.ml	/^let mkArrayType () = $/;"	v
mkBlock	cil/src/cil.mli	/^val mkBlock: stmt list -> block$/;"	v
mkCast	cil/src/cil.ml	/^let mkCast ~(e: exp) ~(newt: typ) = $/;"	v
mkCast	cil/src/cil.mli	/^val mkCast: e:exp -> newt:typ -> exp $/;"	v
mkCastT	cil/src/cil.mli	/^val mkCastT: e:exp -> oldt:typ -> newt:typ -> exp$/;"	v
mkCompInfo	cil/src/cil.ml	/^let mkCompInfo$/;"	v
mkCompInfo	cil/src/cil.mli	/^val mkCompInfo: bool ->      (* whether it is a struct or a union *)$/;"	v
mkEmptyStmt	cil/src/cil.mli	/^val mkEmptyStmt: unit -> stmt$/;"	v
mkFor	cil/src/cil.ml	/^let mkFor ~(start: stmt list) ~(guard: exp) ~(next: stmt list) $/;"	v
mkFor	cil/src/cil.mli	/^val mkFor: start:stmt list -> guard:exp -> next: stmt list -> $/;"	v
mkForIncr	cil/src/cil.ml	/^let mkForIncr ~(iter : varinfo) ~(first: exp) ~stopat:(past: exp) ~(incr: exp) $/;"	v
mkForIncr	cil/src/cil.mli	/^val mkForIncr:  iter:varinfo -> first:exp -> stopat:exp -> incr:exp $/;"	v
mkMem	cil/src/cil.mli	/^val mkMem: addr:exp -> off:offset -> lval$/;"	v
mkPrint	cil/src/ext/logcalls.ml	/^let mkPrint (format: string) (args: exp list) : instr = $/;"	v
mkProto	cil/src/ext/sfi.ml	/^let mkProto (name: string) (args: (string * typ * attributes) list) = $/;"	v
mkPtrType	cil/src/testcil.ml	/^let mkPtrType () = TPtr(TVoid([]), [])$/;"	v
mkSimpleField	cil/src/ext/heapify.ml	/^let mkSimpleField ci fn ft fl =$/;"	v
mkStmt	cil/src/cil.ml	/^let mkStmt (sk: stmtkind) : stmt = $/;"	v
mkStmt	cil/src/cil.mli	/^val mkStmt: stmtkind -> stmt$/;"	v
mkStmtOneInstr	cil/src/cil.mli	/^val mkStmtOneInstr: instr -> stmt$/;"	v
mkString	cil/src/cil.ml	/^let mkString s = Const(CStr s)$/;"	v
mkString	cil/src/cil.mli	/^val mkString: string -> exp$/;"	v
mkWhile	cil/src/cil.ml	/^let mkWhile ~(guard:exp) ~(body: stmt list) : stmt list = $/;"	v
mkWhile	cil/src/cil.mli	/^val mkWhile: guard:exp -> body:stmt list -> stmt list$/;"	v
mode	cil/src/ext/astslicer.ml	/^let mode = ref false (* was our parented wanted? *)$/;"	v
modify	cil/src/ext/heapify.ml	/^        let modify = new heapifyModifyVisitor (Var(vi)) ci.cfields$/;"	v
mone	cil/src/cil.ml	/^let mone      = integer (-1)$/;"	v
mone	cil/src/cil.mli	/^val mone: exp$/;"	v
movingRight	cil/ocamlutil/pretty.ml	/^let movingRight (abscol: int) : int = $/;"	v
msg	cil/src/mergecil.ml	/^        let msg = $/;"	v
msg	cil/src/mergecil.ml	/^      let msg = $/;"	v
msg	cil/src/mergecil.ml	/^      let msg = Printf.sprintf $/;"	v
msg	cil/src/mergecil.ml	/^      let msg:string = (P.sprint 1000 (P.dprintf "(different type constructors: %a vs. %a)"$/;"	v
msvcBuiltins	cil/src/cil.ml	/^let msvcBuiltins = builtinFunctions$/;"	v
msvcBuiltins	cil/src/cil.mli	/^val msvcBuiltins: (string, typ * typ list * bool) Hashtbl.t$/;"	v
msvc_preprocess	cil/lib/Cilly.pm	/^sub msvc_preprocess {$/;"	s
mustEq	cil/src/frontc/patch.ml	/^let mustEq (x : 'a) (y : 'a) : unit =$/;"	v
mustLogLval	cil/src/ext/sfi.ml	/^let mustLogLval (forwrite: bool) (lv: lval) : bool = $/;"	v
mustTurnIntoDef	cil/src/frontc/cabs2cil.ml	/^let mustTurnIntoDef: bool IH.t = IH.create 117$/;"	v
must_recompute	cil/src/ext/partial.ml	/^                            let must_recompute =$/;"	v
must_recompute	cil/src/ext/partial.ml	/^                    let must_recompute, incoming_state =$/;"	v
mutable_inputs	src/base/symbolic_execution.h	/^  vector<value_t>* mutable_inputs() { return &inputs_; }$/;"	f	class:crest::SymbolicExecution
mutable_path	src/base/symbolic_execution.h	/^  SymbolicPath* mutable_path() { return &path_; }$/;"	f	class:crest::SymbolicExecution
mutable_vars	src/base/symbolic_execution.h	/^  map<var_t,type_t>* mutable_vars() { return &vars_; }$/;"	f	class:crest::SymbolicExecution
mydebug	cil/lib/Cilly.pm	/^sub mydebug {$/;"	s
n	cil/obj/x86_LINUX/cparser.ml	/^                                      ( let (n, decl, a) = _2 in$/;"	v
n	cil/obj/x86_LINUX/cparser.ml	/^                                     let n, decl = _1 in$/;"	v
n	cil/obj/x86_LINUX/cparser.ml	/^                                    ( let (n,decl,al,loc) = _1 in$/;"	v
n	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let (n, decl) = _1 in$/;"	v
n	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let (n,decl,al,loc) = _3 in$/;"	v
n	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let n, decl = _1 in$/;"	v
n	cil/obj/x86_LINUX/cparser.ml	/^                               ( let (n, decl) = _2 in$/;"	v
n	cil/obj/x86_LINUX/formatparse.ml	/^                         ( let n = parseInt _1 in$/;"	v
n	cil/obj/x86_LINUX/formatparse.ml	/^                     let (n, t, _) = (fst _3) ts args in$/;"	v
n	cil/ocamlutil/util.ml	/^      let n = mkname (id - fst) in$/;"	v
n	cil/src/cil.ml	/^        let n = comp.cname in$/;"	v
n	cil/src/cil.ml	/^      let n =  $/;"	v
name	cil/ocamlutil/stats.ml	/^type t = { name : string;$/;"	r	type:t
name	cil/src/cil.ml	/^    let name = match nameOpt with None -> nil | Some d -> d in$/;"	v
name	cil/src/cil.ml	/^  let name = findUniqueName () in$/;"	v
name	cil/src/ext/heapify.ml	/^        let name = (fundec.svar.vname ^ "_heapify") in$/;"	v
name	cil/src/ext/ssa.mli	/^    name: string; (* The function name *)$/;"	r	type:cfgInfo
name	cil/src/frontc/cabs.ml	/^and name = string * decl_type * attribute list * cabsloc$/;"	t
name	cil/test/small1/init.c	/^  char *name;$/;"	m	struct:s	file:
name'	cil/src/cil.ml	/^        let name' = $/;"	v
name'	cil/src/cil.ml	/^        let name' = text "*" ++ printAttributes a ++ name in$/;"	v
name''	cil/src/cil.ml	/^        let name'' = (* Put the parenthesis *)$/;"	v
nameId	cil/src/mergecil.ml	/^              let nameId = ref 0 in $/;"	v
nameKind	cil/src/frontc/cabsvisit.mli	/^type nameKind = $/;"	t
name_group	cil/src/frontc/cabs.ml	/^and name_group = specifier * name list$/;"	t
names_	src/base/symbolic_interpreter.h	/^  map<addr_t,string*> names_;$/;"	m	class:crest::SymbolicInterpreter
names_trigger_	src/base/symbolic_interpreter.h	/^  map<addr_t,string*> names_trigger_;$/;"	m	class:crest::SymbolicInterpreter
names_typs_	src/base/symbolic_interpreter.h	/^  map<addr_t,int> names_typs_;$/;"	m	class:crest::SymbolicInterpreter
nbhr_it	src/process_cfg/process_cfg.cc	/^typedef adj_list_t::iterator nbhr_it;$/;"	t	file:
nbhr_list_t	src/run_crest/concolic_search.h	/^  typedef vector<branch_id_t> nbhr_list_t;$/;"	t	class:crest::CfgHeuristicSearch
nd	cil/src/ext/stackoverflow.ml	/^            let nd = getFunctionNode fdec.svar.vname in$/;"	v
nd	cil/src/mergecil.ml	/^                  let nd = H.find sEq (!currentFidx, ci.cname) in$/;"	v
nd1	cil/src/mergecil.ml	/^  let nd1 = find true nd1 in$/;"	v
nd2	cil/src/mergecil.ml	/^  let nd2 = find true nd2 in $/;"	v
new	cil/lib/Cilly.pm	/^sub new {$/;"	s
new	cil/lib/KeptFile.pm	/^sub new {$/;"	s
new	cil/lib/OutputFile.pm	/^sub new {$/;"	s
new	cil/lib/TempFile.pm	/^sub new {$/;"	s
newAlphaName	cil/ocamlutil/alpha.mli	/^val newAlphaName: alphaTable:(string, 'a alphaTableData ref) Hashtbl.t ->$/;"	v
newArgs	cil/src/ext/canonicalize.ml	/^	      let newArgs = try$/;"	v
newDom	cil/src/ext/ssa.ml	/^      let newDom = idom.(idom.(w)) in$/;"	v
newE	cil/src/ext/canonicalize.ml	/^		    let newE = mkCast e fi.ftype in$/;"	v
newFormals	cil/src/ext/canonicalize.ml	/^		  let newFormals = List.map$/;"	v
newFuncPtr	cil/src/ext/canonicalize.ml	/^		  let newFuncPtr = Lval(Mem(mkCast fp newFuncPtrType), off) in$/;"	v
newFuncPtrType	cil/src/ext/canonicalize.ml	/^		  let newFuncPtrType =$/;"	v
newGrowArray	cil/ocamlutil/util.ml	/^let newGrowArray (initsz: int) (fill: 'a growArrayFill) : 'a growArray = $/;"	v
newHline	cil/ocamlutil/errormsg.mli	/^val newHline: unit -> unit $/;"	v
newI	cil/src/ext/canonicalize.ml	/^	      let newI = Call(dest, f, newArgs, l) in$/;"	v
newI	cil/src/ext/canonicalize.ml	/^	    let newI = Set(dest, mkCast exp typeOfDest, l) in$/;"	v
newStart	cil/src/cil.ml	/^      let newStart = addTrailing sofar.oaFirstFree ftypeAlign  in$/;"	v
newVID	cil/src/cil.ml	/^let newVID () = $/;"	v
newVID	cil/src/cil.mli	/^val newVID: unit -> int$/;"	v
new_block	cil/src/cil.ml	/^          let new_block = mkBlock [ this_stmt ; break_stmt ] in$/;"	v
new_f	cil/src/ext/astslicer.ml	/^      let new_f = { f with sbody = { f.sbody with $/;"	v
new_lv	cil/src/ext/sfi.ml	/^    let new_lv = (lh, new_lv_offset) in $/;"	v
new_lv_offset	cil/src/ext/sfi.ml	/^    let new_lv_offset, bf = split_offset_and_bitfield lo in$/;"	v
new_sid	cil/src/cil.ml	/^let new_sid () =$/;"	v
new_sid	cil/src/cil.mli	/^val new_sid : unit -> int$/;"	v
new_vi	cil/src/ext/simplemem.ml	/^        let new_vi = make_temp (typeOf e) in$/;"	v
newacc	cil/ocamlutil/pretty.ml	/^              let newacc = $/;"	v
newbounds	cil/src/ext/pta/steensgaard.ml	/^	  let newbounds = ref B.empty in$/;"	v
newformals	cil/src/cil.ml	/^  let newformals = $/;"	v
newformals	cil/src/ext/simplify.ml	/^      let newformals = $/;"	v
newinitl	cil/src/cil.ml	/^        let newinitl : (offset * init) list ref = ref [] in$/;"	v
newio	cil/src/cil.ml	/^          let newio = $/;"	v
newline	cil/ocamlutil/errormsg.mli	/^val newline: unit -> unit  (* Call this function to announce a new line *)$/;"	v
newline	cil/ocamlutil/pretty.ml	/^  let newline () =$/;"	v
newname	cil/src/mergecil.ml	/^                       let newname, _ = $/;"	v
newname	cil/src/mergecil.ml	/^                let newname, _ = $/;"	v
newname	cil/src/mergecil.ml	/^              let newname = fdec'.svar.vname in$/;"	v
newrep	cil/src/mergecil.ml	/^      let newrep, _ = union oldeinode einode in$/;"	v
newrep	cil/src/mergecil.ml	/^      let newrep, _ = union oldvinode vinode in $/;"	v
newrep	cil/src/mergecil.ml	/^    let newrep, undo = union oldcinode cinode in$/;"	v
newstmt	cil/src/ext/astslicer.ml	/^      let newstmt = mkStmtOneInstr newinst in$/;"	v
newstorage	cil/src/mergecil.ml	/^      let newstorage = $/;"	v
newsuffix	cil/ocamlutil/alpha.ml	/^                let newsuffix = alphaSeparator ^ (string_of_int (max + 1)) in$/;"	v
newtype	cil/src/mergecil.ml	/^            let newtype = $/;"	v
newtype	cil/src/mergecil.ml	/^      let newtype = $/;"	v
newv	cil/src/ext/canonicalize.ml	/^	  let newv = {v with vstorage = oldS} in$/;"	v
next	cil/src/ext/simplify.ml	/^          let next, restoff = offsetToInt fi.ftype off' in$/;"	v
next	cil/src/ext/simplify.ml	/^        let next, restoff = offsetToInt telem off' in$/;"	v
nextSymbolId	cil/ocamlutil/util.ml	/^let nextSymbolId = ref 0 $/;"	v
nextident	cil/src/frontc/cabshelper.ml	/^let nextident = ref 0$/;"	v
nextidx	cil/src/frontc/whitetrack.ml	/^let nextidx = ref 0$/;"	v
ng'	cil/src/frontc/cabsvisit.ml	/^      let ng' = childrenNameGroup vis NType ng in$/;"	v
nil	cil/ocamlutil/pretty.ml	/^let nil           = Nil$/;"	v
nil	cil/ocamlutil/pretty.mli	/^val nil          : doc$/;"	v
nm	cil/test/small1/init.c	/^char *nm[] = {$/;"	v
noAddr	cil/src/ext/crestInstrument.ml	/^let noAddr = zero$/;"	v
noMemoize	cil/src/formatcil.mli	/^val noMemoize: bool ref$/;"	v
no_flow	cil/src/ext/pta/golf.mli	/^val no_flow : bool ref$/;"	v
no_flow	cil/src/ext/pta/olf.mli	/^val no_flow : bool ref$/;"	v
no_flow	cil/src/ext/pta/ptranal.mli	/^val no_flow : bool ref $/;"	v
no_flow	cil/src/ext/pta/steensgaard.mli	/^val no_flow : bool ref$/;"	v
no_sub	cil/src/ext/pta/golf.mli	/^val no_sub : bool ref$/;"	v
no_sub	cil/src/ext/pta/olf.mli	/^val no_sub : bool ref$/;"	v
no_sub	cil/src/ext/pta/ptranal.mli	/^val no_sub : bool ref$/;"	v
no_sub	cil/src/ext/pta/steensgaard.mli	/^val no_sub : bool ref$/;"	v
nocil	cil/src/frontc/cabs2cil.mli	/^val nocil: int ref$/;"	v
nodeCall	cil/src/ext/blockinggraph.ml	/^      let nodeCall = Call (None, Lval (var nodeFun.svar), [], locUnknown) in$/;"	v
nodeFun	cil/src/ext/blockinggraph.ml	/^      let nodeFun = emptyFunction ("NODE_CALL_"^(string_of_int node.nodeid)) in$/;"	v
nodeList	cil/src/ext/cfg.mli	/^val nodeList : stmt list ref$/;"	v
nodeList	cil/src/ext/ssa.ml	/^  let nodeList = List.filter (fun i -> (i != -1)) (Array.to_list nodes) in$/;"	v
nodeName	cil/src/ext/callgraph.mli	/^val nodeName: nodeinfo -> string$/;"	v
nodeinfo	cil/src/ext/callgraph.mli	/^and nodeinfo = $/;"	t
nodepost	cil/src/cil.ml	/^      let nodepost = children vis nodepre in$/;"	v
nodes	cil/src/ext/ssa.ml	/^  let nodes = Array.make nrNodes (-1) in$/;"	v
nodes	cil/src/ext/ssa.mli	/^    nodes: int list;$/;"	r	type:oneSccInfo
nodespost	cil/src/cil.ml	/^      let nodespost = mapNoCopy (children vis) nodespre in$/;"	v
nodespost	cil/src/frontc/cabsvisit.ml	/^      let nodespost = mapNoCopy (children vis) nodespre in$/;"	v
nodespre	cil/src/cil.ml	/^      let nodespre = match action with$/;"	v
nodespre	cil/src/frontc/cabsvisit.ml	/^      let nodespre = match action with$/;"	v
noidx	cil/src/frontc/whitetrack.ml	/^let noidx = -1  $/;"	v
nopCabsVisitor	cil/src/frontc/cabsvisit.mli	/^class nopCabsVisitor: cabsVisitor$/;"	c
nopCilVisitor	cil/src/cil.ml	/^class nopCilVisitor : cilVisitor = object$/;"	c
nopCilVisitor	cil/src/cil.mli	/^class nopCilVisitor: cilVisitor$/;"	c
normalizeConditionalsVisitor	cil/src/ext/crestInstrument.ml	/^class normalizeConditionalsVisitor =$/;"	c
normalizeFileName	cil/lib/Cilly.pm	/^sub normalizeFileName {$/;"	s
nrBits	cil/src/ext/bitmap.ml	/^           mutable nrBits   : int;      (* This is 31 * nrWords *)$/;"	r	type:t
nrRegs	cil/src/ext/ssa.mli	/^    mutable nrRegs: int;$/;"	r	type:cfgInfo
nrScc	cil/src/ext/ssa.ml	/^  let nrScc = Array.length all_sccArray in$/;"	v
nrWords	cil/src/ext/bitmap.ml	/^type t = { mutable nrWords  : int;$/;"	r	type:t
null	cil/ocamlutil/errormsg.ml	/^let null (fmt : ('a,unit,doc,unit) format4) : 'a =$/;"	v
null	cil/ocamlutil/errormsg.mli	/^val null : ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
null	cil/test/small1/init.c	/^char *null = (void*)0;$/;"	v
null_adder	cil/src/ext/liveness.ml	/^let null_adder fdec =$/;"	v
num	cil/ocamlutil/pretty.ml	/^let num  i        = text (string_of_int i)$/;"	v
num	cil/ocamlutil/pretty.mli	/^val num          : int    -> doc$/;"	v	function:++
numNodes	cil/src/ext/cfg.mli	/^val numNodes : int ref$/;"	v
num_alloc_index	cil/ocamlutil/growArray.ml	/^let num_alloc_index (ga: 'a t) : int = $/;"	v
num_alloc_index	cil/ocamlutil/growArray.mli	/^val num_alloc_index: 'a t -> int$/;"	v
num_covered_	src/run_crest/concolic_search.h	/^  unsigned int num_covered_;$/;"	m	class:crest::Search
num_inner_lucky_successes_	src/run_crest/concolic_search.h	/^  unsigned num_inner_lucky_successes_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_nonzero_successes_	src/run_crest/concolic_search.h	/^  unsigned num_inner_nonzero_successes_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_pred_fails_	src/run_crest/concolic_search.h	/^  unsigned num_inner_pred_fails_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_recursive_successes_	src/run_crest/concolic_search.h	/^  unsigned num_inner_recursive_successes_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_solves_	src/run_crest/concolic_search.h	/^  unsigned num_inner_solves_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_successes_pred_fail_	src/run_crest/concolic_search.h	/^  unsigned num_inner_successes_pred_fail_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_unsats_	src/run_crest/concolic_search.h	/^  unsigned num_inner_unsats_;$/;"	m	class:crest::CfgHeuristicSearch
num_inner_zero_successes_	src/run_crest/concolic_search.h	/^  unsigned num_inner_zero_successes_;$/;"	m	class:crest::CfgHeuristicSearch
num_inputs_	src/base/symbolic_interpreter.h	/^  unsigned int num_inputs_;$/;"	m	class:crest::SymbolicInterpreter
num_iters_	src/run_crest/concolic_search.h	/^  int num_iters_;$/;"	m	class:crest::Search
num_solve_all_concrete_	src/run_crest/concolic_search.h	/^  unsigned num_solve_all_concrete_;$/;"	m	class:crest::CfgHeuristicSearch
num_solve_no_paths_	src/run_crest/concolic_search.h	/^  unsigned num_solve_no_paths_;$/;"	m	class:crest::CfgHeuristicSearch
num_solve_pred_fails_	src/run_crest/concolic_search.h	/^  unsigned num_solve_pred_fails_;$/;"	m	class:crest::CfgHeuristicSearch
num_solve_recurses_	src/run_crest/concolic_search.h	/^  unsigned num_solve_recurses_;$/;"	m	class:crest::CfgHeuristicSearch
num_solve_sat_attempts_	src/run_crest/concolic_search.h	/^  unsigned num_solve_sat_attempts_;$/;"	m	class:crest::CfgHeuristicSearch
num_solve_successes_	src/run_crest/concolic_search.h	/^  unsigned num_solve_successes_;$/;"	m	class:crest::CfgHeuristicSearch
num_solve_unsats_	src/run_crest/concolic_search.h	/^  unsigned num_solve_unsats_;$/;"	m	class:crest::CfgHeuristicSearch
num_solves_	src/run_crest/concolic_search.h	/^  unsigned num_solves_;$/;"	m	class:crest::CfgHeuristicSearch
num_stmts	cil/src/ext/partial.ml	/^        let num_stmts = ref 1 in$/;"	v
num_top_solve_successes_	src/run_crest/concolic_search.h	/^  unsigned num_top_solve_successes_;$/;"	m	class:crest::CfgHeuristicSearch
num_top_solves_	src/run_crest/concolic_search.h	/^  unsigned num_top_solves_;$/;"	m	class:crest::CfgHeuristicSearch
o	cil/src/frontc/frontc.ml	/^          let o = (open_out outFname) in$/;"	v
o'	cil/src/cil.ml	/^      let o' = vOff o in$/;"	v
oaFirstFree	cil/src/cil.ml	/^    { oaFirstFree: int;        (* The first free bit *)$/;"	r	type:offsetAcc
oaLastFieldStart	cil/src/cil.ml	/^      oaLastFieldStart: int;   (* Where the previous field started *)$/;"	r	type:offsetAcc
oaLastFieldWidth	cil/src/cil.ml	/^      oaLastFieldWidth: int;   (* The width of the previous field. Might not $/;"	r	type:offsetAcc
oaPrevBitPack	cil/src/cil.ml	/^      oaPrevBitPack: (int * ikind * int) option; (* If the previous fields $/;"	r	type:offsetAcc
obj	cil/src/ext/callgraph.ml	/^  let obj:cgComputer = new cgComputer graph in$/;"	v
oc	cil/ocamlutil/util.ml	/^    let oc = open_out fname in$/;"	v
ocaml_int_to_cil	cil/src/ext/ciltools.ml	/^let ocaml_int_to_cil v n s =$/;"	v
octalhex	cil/src/cil.ml	/^  let octalhex = (l >= 1 && String.get str 0 = '0') in $/;"	v
off'	cil/src/cil.ml	/^      let off' = vOff off in$/;"	v
offidx	cil/src/ext/simplify.ml	/^      let offidx, restoff = offsetToInt (typeOfLval (Mem a, NoOffset)) off in$/;"	v
offidx	cil/src/ext/simplify.ml	/^      let offidx, restoff = offsetToInt v.vtype off in$/;"	v
offset	cil/obj/x86_LINUX/formatparse.mli	/^val offset :$/;"	v
offset	cil/src/cil.mli	/^and offset = $/;"	t
offsetAcc	cil/src/cil.ml	/^type offsetAcc = $/;"	t
offsetOfFieldAcc	cil/src/cil.ml	/^and offsetOfFieldAcc ~(fi: fieldinfo) $/;"	v
offsetOfFieldAcc_GCC	cil/src/cil.ml	/^let rec offsetOfFieldAcc_GCC (fi: fieldinfo) $/;"	v
offsetOfFieldAcc_MSVC	cil/src/cil.ml	/^and offsetOfFieldAcc_MSVC (fi: fieldinfo) $/;"	v
old	cil/ocamlutil/errormsg.ml	/^  let old = !errorContext in$/;"	v
old	cil/src/rmtmps.ml	/^	  let old = c.creferenced in$/;"	v
old	cil/src/rmtmps.ml	/^	  let old = ti.treferenced in$/;"	v
oldNames	cil/src/mergecil.ml	/^              let oldNames : string list ref = ref [] in$/;"	v
oldOut	cil/src/frontc/frontc.ml	/^        let oldOut = !out in$/;"	v
oldS	cil/src/ext/canonicalize.ml	/^	  let oldS = v.vstorage in$/;"	v
old_activeMarkups	cil/ocamlutil/pretty.ml	/^  let old_activeMarkups = !activeMarkups in $/;"	v
old_alignDepth	cil/ocamlutil/pretty.ml	/^  let old_alignDepth = !alignDepth in $/;"	v
old_breaks	cil/ocamlutil/pretty.ml	/^  let old_breaks = !breaks in $/;"	v
old_len	cil/src/mergecil.ml	/^    let old_len = List.length oldci.cfields in$/;"	v
oldattr	cil/src/cil.ml	/^         let oldattr = fdec.svar.vattr in$/;"	v
oldattr	cil/src/cil.ml	/^        let oldattr = fundec.svar.vattr in$/;"	v
oldbl	cil/src/ext/predabst.ml	/^	let oldbl = try IH.find oldss pid with Not_found -> Bottom in$/;"	v
oldci	cil/src/mergecil.ml	/^    let oldci = oldcinode.ndata in$/;"	v
oldcinode	cil/src/mergecil.ml	/^  let oldcinode = getNode sEq sSyn oldfidx oldci.cname oldci None in$/;"	v
oldei	cil/src/mergecil.ml	/^    let oldei = oldeinode.ndata in$/;"	v
oldeinode	cil/src/mergecil.ml	/^  let oldeinode = getNode eEq eSyn oldfidx oldei.ename oldei None in$/;"	v
oldfidx	cil/src/mergecil.ml	/^    let oldfidx = oldcinode.nfidx in$/;"	v
oldfidx	cil/src/mergecil.ml	/^    let oldfidx = oldtnode.nfidx in$/;"	v
oldinode	cil/src/mergecil.ml	/^              let oldinode = H.find inlineBodies printout in$/;"	v
oldloc	cil/src/mergecil.ml	/^      let oldloc, _ = $/;"	v
oldnames	cil/src/mergecil.ml	/^          let oldnames, foundthem = $/;"	v
oldprintln	cil/src/mergecil.ml	/^              let oldprintln = !lineDirectiveStyle in$/;"	v
oldrep	cil/src/mergecil.ml	/^    let oldrep = norep.nrep in$/;"	v
oldti	cil/src/mergecil.ml	/^    let oldti = oldtnode.ndata in$/;"	v
oldtnode	cil/src/mergecil.ml	/^  let oldtnode = getNode tEq tSyn oldfidx oldti.tname oldti None in$/;"	v
oldvi	cil/src/mergecil.ml	/^      let oldvi     = oldvinode.ndata in$/;"	v
oldvinode	cil/src/mergecil.ml	/^      let oldvinode = find true (H.find vEnv vi.vname) in $/;"	v
one	cil/src/cil.ml	/^let one       = integer 1$/;"	v
one	cil/src/cil.mli	/^val one: exp$/;"	v
one	cil/src/main.ml	/^      let one =$/;"	v
oneFilePass1	cil/src/mergecil.ml	/^let rec oneFilePass1 (f:file) : unit = $/;"	v
oneSccInfo	cil/src/ext/ssa.mli	/^and oneSccInfo = {$/;"	t
one_instruction_per_statement	cil/src/ext/ciltools.ml	/^let one_instruction_per_statement f =$/;"	v
oneret	cil/src/ext/oneret.mli	/^val oneret: Cil.fundec -> unit$/;"	v
op	src/base/symbolic_predicate.h	/^  compare_op_t op() const { return op_; }$/;"	f	class:crest::SymbolicPred
opType	cil/src/ext/crestInstrument.ml	/^let opType   = intType  (* enum *)$/;"	v
op_	src/base/symbolic_predicate.h	/^  compare_op_t op_;$/;"	m	class:crest::SymbolicPred
openFile	cil/src/main.ml	/^  let openFile (what: string) (takeit: outfile -> unit) (fl: string) = $/;"	v
open_append	cil/src/ext/crestInstrument.ml	/^let open_append fname =$/;"	v
operator ()	src/process_cfg/process_cfg.cc	/^    size_t operator()(const string& x) const {$/;"	f	struct:__gnu_cxx::hash
operator ()	src/run_crest/concolic_search.cc	/^  bool operator()(const ScoredBranch& a, const ScoredBranch& b) const {$/;"	f	struct:crest::__anon11::ScoredBranchComp
operator *=	src/base/symbolic_expression.cc	/^const SymbolicExpr& SymbolicExpr::operator*=(value_t c) {$/;"	f	class:crest::SymbolicExpr
operator +=	src/base/symbolic_expression.cc	/^const SymbolicExpr& SymbolicExpr::operator+=(const SymbolicExpr& e) {$/;"	f	class:crest::SymbolicExpr
operator +=	src/base/symbolic_expression.cc	/^const SymbolicExpr& SymbolicExpr::operator+=(value_t c) {$/;"	f	class:crest::SymbolicExpr
operator -=	src/base/symbolic_expression.cc	/^const SymbolicExpr& SymbolicExpr::operator-=(const SymbolicExpr& e) {$/;"	f	class:crest::SymbolicExpr
operator -=	src/base/symbolic_expression.cc	/^const SymbolicExpr& SymbolicExpr::operator-=(value_t c) {$/;"	f	class:crest::SymbolicExpr
operator ==	src/base/symbolic_expression.cc	/^bool SymbolicExpr::operator==(const SymbolicExpr& e) const {$/;"	f	class:crest::SymbolicExpr
ops	src/base/basic_types.h	/^namespace ops {$/;"	n	namespace:crest
options	cil/bin/patcher	/^options: $/;"	l
options	cil/src/ciloptions.ml	/^let options : (string * Arg.spec * string) list =$/;"	v
options	cil/src/ciloptions.mli	/^val options : (string * Arg.spec * string) list $/;"	v
order	cil/src/ext/dominators.ml	/^type order = PreOrder | PostOrder$/;"	t
order	cil/src/ext/dominators.mli	/^type order = PreOrder | PostOrder$/;"	t
origType	cil/src/mergecil.ml	/^              let origType = fdec'.svar.vtype in$/;"	v
originalVarNames	cil/src/mergecil.ml	/^let originalVarNames: (string, string) H.t = H.create 113$/;"	v
origname	cil/src/mergecil.ml	/^          let origname = $/;"	v
out	cil/src/ext/crestInstrument.ml	/^    let out = open_append "cfg_func_map" in$/;"	v
out	cil/src/frontc/whitetrack.ml	/^let out = ref stdout$/;"	v
outFname	cil/src/frontc/frontc.ml	/^          let outFname:string = fname ^ ".patched" in$/;"	v
outgoing_state	cil/src/ext/partial.ml	/^                          let outgoing_state =$/;"	v
outputElements	cil/src/cil.ml	/^      let rec outputElements (isfirst: bool) (room_on_line: int) = function$/;"	v
outputFile	cil/lib/Cilly.pm	/^sub outputFile {$/;"	s
outs'	cil/src/cil.ml	/^      let outs' = mapNoCopy (fun ((id,s,lv) as pair) -> $/;"	v
p	cil/src/ext/logcalls.ml	/^     let p = makePrintfFunction () in $/;"	v
p	cil/src/ext/partial.ml	/^                  let p, s = Heap.extract_max worklist in$/;"	v
p	cil/src/ext/pta/golf.ml	/^        let p = Q.take path_worklist in$/;"	v
pArg	cil/src/cil.ml	/^                          let pArg (aname, atype, aattr) = $/;"	v
pAttr	cil/src/cil.ml	/^  method pAttr (Attr(an, args): attribute) : doc * bool =$/;"	m
pAttrParam	cil/src/cil.ml	/^  method pAttrParam () a = $/;"	m
pAttrs	cil/src/cil.ml	/^  method pAttrs () (a: attributes) = $/;"	m
pExp	cil/src/cil.ml	/^  method pExp () (e:exp) : doc =$/;"	m
pExp	cil/src/cil.ml	/^  method pExp () = function$/;"	m
pFieldDecl	cil/src/cil.ml	/^   method pFieldDecl () fi = $/;"	m
pGlobal	cil/src/cil.ml	/^  method pGlobal () (g:global) : doc =       (* global (vars, types, etc.) *)$/;"	m
pInit	cil/src/cil.ml	/^  method pInit () = function$/;"	m
pInstr	cil/src/cil.ml	/^  method pInstr () (i:instr) =       (* imperative instruction *)$/;"	m
pLineDirective	cil/src/cil.ml	/^  method pLineDirective ?(forcefile=false) l = $/;"	m
pStmt	cil/src/cil.ml	/^  method pStmt () (s:stmt) =        (* control-flow statement *)$/;"	m
pType	cil/src/cil.ml	/^  method pType (nameOpt: doc option) (* Whether we are declaring a name or $/;"	m
paVisitorClass	cil/src/ext/predabst.ml	/^    class paVisitorClass = object(self)$/;"	c
paired_branch_	src/run_crest/concolic_search.h	/^  vector<branch_id_t> paired_branch_;$/;"	m	class:crest::Search
par_decl	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let par_decl, isva = doOldParDecl _3 _5 in$/;"	v
params	cil/obj/x86_LINUX/cparser.ml	/^                                        ( let (params, isva) = _3 in $/;"	v
params	cil/obj/x86_LINUX/cparser.ml	/^                                     let (params, isva) = _3 in$/;"	v
params	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let (params, isva) = _2 in $/;"	v
params	cil/obj/x86_LINUX/cparser.ml	/^                                   ( let (params, isva) = _3 in$/;"	v
params	cil/obj/x86_LINUX/cparser.ml	/^                           ( let (params, isva) = _3 in$/;"	v
pardecl	cil/obj/x86_LINUX/cparser.ml	/^                             let pardecl, isva = doOldParDecl _3 _5 in $/;"	v
pardecl	cil/obj/x86_LINUX/cparser.ml	/^                             let pardecl, isva = doOldParDecl _3 _5 in$/;"	v
paren	cil/src/cil.ml	/^        let (paren: doc option), (bt': typ) = $/;"	v
pars	cil/obj/x86_LINUX/formatparse.ml	/^                        let (pars : (string * typ * attributes) list), $/;"	v
pars	cil/obj/x86_LINUX/formatparse.ml	/^                        let pars, isva = (fst _6) args in$/;"	v
parse	cil/src/frontc/frontc.ml	/^let parse fname = (fun () -> snd(parse_helper fname ()))$/;"	v
parse	cil/src/frontc/frontc.mli	/^val parse: string -> (unit -> Cil.file)$/;"	v
parseInt	cil/src/cil.ml	/^let parseInt (str: string) : exp = $/;"	v
parseInt	cil/src/cil.mli	/^val parseInt: string -> exp$/;"	v
parseLinkerScript	cil/lib/Cilly.pm	/^sub parseLinkerScript {$/;"	s
parseOneFile	cil/src/libmaincil.ml	/^let parseOneFile (fname: string) : file =$/;"	v
parse_error	cil/ocamlutil/errormsg.mli	/^val parse_error: string -> (* A message *) $/;"	v
parse_helper	cil/src/frontc/frontc.ml	/^let parse_helper fname =$/;"	v
parse_to_cabs_inner	cil/src/frontc/frontc.ml	/^and parse_to_cabs_inner (fname : string) =$/;"	v
parse_with_cabs	cil/src/frontc/frontc.mli	/^val parse_with_cabs: string -> (unit -> Cabs.file * Cil.file)$/;"	v
partInstr	cil/src/formatcil.ml	/^  let partInstr = $/;"	v
partial	cil/src/ext/partial.ml	/^let partial (f : Cil.file) (root : string) (assumptions : (Cil.lval * Cil.exp) list) =$/;"	v
partial_stmt	cil/src/ext/partial.ml	/^    let partial_stmt c state stmt handle_funcall =$/;"	v
partition	cil/src/ext/pta/setp.ml	/^    let partition p s =$/;"	v
partitionAttributes	cil/src/cil.ml	/^let partitionAttributes $/;"	v
partitionAttributes	cil/src/cil.mli	/^val partitionAttributes:  default:attributeClass -> $/;"	v
passes	cil/src/ext/partial.ml	/^          let passes = ref 0 in$/;"	v
pat'	cil/src/frontc/patch.ml	/^  let pat' = (List.stable_sort compare pat) in$/;"	v
patchDefn	cil/src/frontc/patch.ml	/^  let rec patchDefn (patch : definition list) (d : definition) : definition list =$/;"	v
patchFile	cil/src/frontc/frontc.ml	/^let patchFile : Cabs.file option ref = ref None$/;"	v
patchFileName	cil/src/frontc/frontc.ml	/^let patchFileName : string ref = ref ""      (* by default do no patching *)$/;"	v
patchOneFile	cil/bin/patcher	/^sub patchOneFile {$/;"	s
patched	cil/src/frontc/frontc.ml	/^  let patched = match !patchFile with$/;"	v
path	src/base/symbolic_execution.h	/^  const SymbolicPath& path() const      { return path_; }$/;"	f	class:crest::SymbolicExecution
path_	src/base/symbolic_execution.h	/^  SymbolicPath path_;  $/;"	m	class:crest::SymbolicExecution
path_signature	cil/src/ext/pta/golf.ml	/^let path_signature k l l' b : int list =$/;"	v
pattern	cil/src/rmtmps.ml	/^  let pattern = "\\\\(" ^ (String.concat "\\\\|" names) ^ "\\\\)" ^ alpha ^ "$" in$/;"	v
peepHole2	cil/src/cil.ml	/^let rec peepHole2  (* Process two statements and possibly replace them both *)$/;"	v
pfun1	cil/test/small1/func.c	/^int (*pfun1)(int (*)(int), int);$/;"	v
pfun2	cil/test/small1/func.c	/^int (*pfun2)(int (*)(int), int);$/;"	v
phonyAddrOf	cil/src/ext/pta/golf.ml	/^let phonyAddrOf (lv : lvalue) : lvalue =$/;"	v
phonyAddrOf	cil/src/ext/pta/golf.mli	/^val phonyAddrOf : lvalue -> lvalue$/;"	v
pkgdatadir	cil/Makefile	/^pkgdatadir = $(datadir)\/cil$/;"	m
pkglibdir	cil/Makefile	/^pkglibdir = $(libdir)\/cil$/;"	m
pl	cil/src/ext/predabst.ml	/^	    let pl = helper e in$/;"	v
pl1	cil/src/ext/predabst.ml	/^	    let pl1 = helper e1 in$/;"	v
pl2	cil/src/ext/predabst.ml	/^	    let pl2 = helper e2 in$/;"	v
plainCilPrinter	cil/src/cil.ml	/^let plainCilPrinter = new plainCilPrinterClass$/;"	v
plainCilPrinterClass	cil/src/cil.ml	/^class plainCilPrinterClass =$/;"	c
points_to	cil/src/ext/pta/golf.mli	/^val points_to : lvalue -> Cil.varinfo list$/;"	v
points_to	cil/src/ext/pta/olf.ml	/^let points_to (lv : lvalue) : Cil.varinfo list =$/;"	v
points_to	cil/src/ext/pta/olf.mli	/^val points_to : lvalue -> Cil.varinfo list$/;"	v
points_to	cil/src/ext/pta/steensgaard.ml	/^let points_to (lv : lvalue) : string list =$/;"	v
points_to	cil/src/ext/pta/steensgaard.mli	/^val points_to : lvalue -> string list    $/;"	v
points_to_aux	cil/src/ext/pta/golf.ml	/^let points_to_aux (t : tau) : constant list =$/;"	v
points_to_aux	cil/src/ext/pta/olf.ml	/^let points_to_aux (t : tau) : absloc list =$/;"	v
points_to_names	cil/src/ext/pta/golf.ml	/^let points_to_names (lv : lvalue) : string list =$/;"	v
points_to_names	cil/src/ext/pta/golf.mli	/^val points_to_names : lvalue -> string list$/;"	v
points_to_names	cil/src/ext/pta/olf.ml	/^let points_to_names (lv : lvalue) : string list =$/;"	v
points_to_names	cil/src/ext/pta/olf.mli	/^val points_to_names : lvalue -> string list$/;"	v
points_to_tau	cil/src/ext/pta/steensgaard.ml	/^  let rec points_to_tau (t : tau) : constantset =$/;"	v
pop	cil/ocamlutil/util.mli	/^  val pop : 'a t -> 'a$/;"	v	Module:STACK
popContext	cil/ocamlutil/errormsg.ml	/^let popContext () = $/;"	v
popContext	cil/ocamlutil/errormsg.mli	/^val popContext   : unit -> unit$/;"	v
popGlobals	cil/src/frontc/cabs2cil.ml	/^let popGlobals () = $/;"	v
pop_context	cil/obj/x86_LINUX/clexer.ml	/^let pop_context _ = $/;"	v
pop_context	cil/obj/x86_LINUX/clexer.mli	/^val pop_context: unit -> unit (* Remove all names added in this context  *)$/;"	v
pop_context	cil/src/frontc/clexer.mli	/^val pop_context: unit -> unit (* Remove all names added in this context  *)$/;"	v
pos_flow	cil/src/ext/pta/steensgaard.ml	/^let pos_flow l : constantset  = $/;"	v
pos_neg_flow	cil/src/ext/pta/steensgaard.ml	/^let pos_neg_flow(l : label) : constantset  =$/;"	v
post	cil/src/ext/ssa.ml	/^  let post = Array.make nrNodes (-1) in$/;"	v
prTree	cil/ocamlutil/stats.ml	/^  let rec prTree ind node = $/;"	v
pre	cil/src/ext/predabst.ml	/^      let pre = $/;"	v
pre	cil/src/ext/predabst.ml	/^      let pre =$/;"	v
pre	cil/src/ext/ssa.ml	/^  let pre = Array.make nrNodes (-1) in$/;"	v
pre_symbolic	src/libcrest/crest.cc	/^static int pre_symbolic;$/;"	v	file:
pred_	src/base/symbolic_interpreter.h	/^  SymbolicPred* pred_;$/;"	m	class:crest::SymbolicInterpreter
predecessors	cil/src/ext/ssa.ml	/^  let predecessors = Array.init nrNodes (fun i -> set2list predecessorsSet.(i)) in$/;"	v
predecessors	cil/src/ext/ssa.ml	/^ let predecessors = Array.init size (fun i -> List.filter (fun s -> reachable.(s)) f.predecessors.(i)) in$/;"	v
predecessors	cil/src/ext/ssa.mli	/^    predecessors: int list array;   $/;"	r	type:cfgInfo
predecessorsSet	cil/src/ext/ssa.ml	/^  let predecessorsSet = Array.make nrNodes (IntSet.empty) in$/;"	v
preds	cil/src/cil.mli	/^    mutable preds: stmt list;          $/;"	r	type:stmt
prefix	cil/Makefile	/^prefix = \/usr\/local$/;"	m
prefix	cil/src/cil.ml	/^      let prefix : string = $/;"	v
preorder	cil/src/ext/ssa.ml	/^let preorder (nrNodes: int) (successors: (int list) array) (r: int): oneSccInfo = $/;"	v
prepareCFG	cil/src/cil.mli	/^val prepareCFG: fundec -> unit$/;"	v
prepareGlobalForCFG	cil/src/ext/crestInstrument.ml	/^let prepareGlobalForCFG glob =$/;"	v
preparePatchFile	cil/bin/patcher	/^sub preparePatchFile {$/;"	s
prependToBlock	cil/src/ext/crestInstrument.ml	/^let prependToBlock (is : instr list) (b : block) =$/;"	v
preprocess	cil/lib/Cilly.pm	/^sub preprocess {$/;"	s
preprocessAfterOutputFile	cil/lib/Cilly.pm	/^sub preprocessAfterOutputFile {$/;"	s
preprocessOutputFile	cil/lib/Cilly.pm	/^sub preprocessOutputFile {$/;"	s
preprocess_after_cil	cil/lib/Cilly.pm	/^sub preprocess_after_cil {$/;"	s
preprocess_before_cil	cil/lib/Cilly.pm	/^sub preprocess_before_cil {$/;"	s
preprocess_compile	cil/lib/Cilly.pm	/^sub preprocess_compile {$/;"	s
pretty	cil/src/ext/predabst.ml	/^	let pretty () ss = match ss with$/;"	v
prettyprint	cil/src/ext/reachingdefs.ml	/^let prettyprint didstmh stmdat () (_,s,iosh) = text ""$/;"	v
prevFun	cil/src/mergecil.ml	/^                  let prevFun, prevLoc, prevSum =$/;"	v
prevStatements	cil/src/check.ml	/^          let prevStatements = !statements in$/;"	v
prevVar	cil/src/mergecil.ml	/^              let prevVar, prevInitOpt, prevLoc =$/;"	v
prev_ex_	src/run_crest/concolic_search.h	/^  SymbolicExecution prev_ex_;$/;"	m	class:crest::UniformRandomSearch
price	test/structure_return.c	/^  int price;$/;"	m	struct:banana	file:
print	cil/ocamlutil/stats.ml	/^let print chn msg = $/;"	v
print	cil/ocamlutil/stats.mli	/^val print : out_channel -> string -> unit$/;"	v
print	cil/src/frontc/whitetrack.ml	/^let print str =$/;"	v
print	cil/src/frontc/whitetrack.mli	/^val print : string -> unit$/;"	v
printAttr	cil/src/cil.ml	/^let printAttr (pp: cilPrinter) () (a: attribute) : doc = $/;"	v
printAttributes	cil/src/cil.ml	/^    let printAttributes (a: attributes) = $/;"	v
printAttrs	cil/src/cil.ml	/^let printAttrs (pp: cilPrinter) () (a: attributes) : doc = $/;"	v
printBlock	cil/src/cil.ml	/^let printBlock (pp: cilPrinter) () (b: block) : doc = $/;"	v
printCfgChannel	cil/src/ext/cfg.ml	/^let printCfgChannel (chan : out_channel) (fd : fundec) =$/;"	v
printCfgChannel	cil/src/ext/cfg.mli	/^val printCfgChannel : out_channel -> fundec -> unit$/;"	v
printCfgFilename	cil/src/ext/cfg.ml	/^let printCfgFilename (filename : string) (fd : fundec) =$/;"	v
printCfgFilename	cil/src/ext/cfg.mli	/^val printCfgFilename : string -> fundec -> unit$/;"	v
printDeclType	cil/src/frontc/patch.ml	/^let printDeclType (pat : decl_type) (tgt : decl_type) =$/;"	v
printDefn	cil/src/frontc/patch.ml	/^let printDefn (d : definition) =$/;"	v
printDepth	cil/ocamlutil/pretty.ml	/^let printDepth = ref 10000000 (* WRW: must see whole thing *)$/;"	v
printDepth	cil/ocamlutil/pretty.mli	/^val printDepth   : int ref$/;"	v
printEOF	cil/src/frontc/whitetrack.ml	/^let printEOF () = output_string !out !finalwhite$/;"	v
printEOF	cil/src/frontc/whitetrack.mli	/^val printEOF : unit -> unit$/;"	v
printExp	cil/src/cil.ml	/^let printExp (pp: cilPrinter) () (e: exp) : doc = $/;"	v
printExpr	cil/src/frontc/patch.ml	/^let printExpr (e : expression) =$/;"	v
printGlobal	cil/src/cil.ml	/^let printGlobal (pp: cilPrinter) () (g: global) : doc = $/;"	v
printGraph	cil/src/ext/callgraph.ml	/^let printGraph (out:out_channel) (g:callgraph) : unit = begin $/;"	v
printGraph	cil/src/ext/callgraph.mli	/^val printGraph : out_channel -> callgraph -> unit$/;"	v
printHelp	cil/bin/patcher	/^sub printHelp {$/;"	s
printHelp	cil/lib/Cilly.pm	/^sub printHelp {$/;"	s
printIndent	cil/ocamlutil/pretty.ml	/^let printIndent = ref true$/;"	v
printIndent	cil/ocamlutil/pretty.mli	/^val printIndent  : bool ref  (** If false then does not indent *)$/;"	v
printInit	cil/src/cil.ml	/^let printInit (pp: cilPrinter) () (i: init) : doc = $/;"	v
printInstr	cil/src/cil.ml	/^let printInstr (pp: cilPrinter) () (i: instr) : doc = $/;"	v
printInstrTerminator	cil/src/cil.ml	/^  val mutable printInstrTerminator = ";"$/;"	v
printLval	cil/src/cil.ml	/^let printLval (pp: cilPrinter) () (lv: lval) : doc = $/;"	v
printM	cil/ocamlutil/stats.ml	/^  let printM (w: float) : string = $/;"	v
printPatchedFiles	cil/src/frontc/frontc.ml	/^let printPatchedFiles : bool ref = ref false$/;"	v
printSpec	cil/src/frontc/patch.ml	/^let printSpec (spec: spec_elem list) =$/;"	v
printSpecs	cil/src/frontc/patch.ml	/^let printSpecs (pat : spec_elem list) (tgt : spec_elem list) =$/;"	v
printStages	cil/src/cilutil.ml	/^let printStages = ref false$/;"	v
printStats	cil/src/cilutil.ml	/^let printStats = ref false$/;"	v
printStmt	cil/src/cil.ml	/^let printStmt (pp: cilPrinter) () (s: stmt) : doc = $/;"	v
printType	cil/src/cil.ml	/^let printType (pp: cilPrinter) () (t: typ) : doc = $/;"	v
printVersion	cil/lib/Cilly.pm	/^sub printVersion {$/;"	s
print_block	cil/src/frontc/cprint.ml	/^and print_block blk = $/;"	v
print_constraint	cil/src/ext/pta/golf.ml	/^let print_constraint (c : tconstraint) =$/;"	v
print_constraint	cil/src/ext/pta/olf.ml	/^let print_constraint (c : tconstraint) =$/;"	v
print_constraint	cil/src/ext/pta/steensgaard.ml	/^let print_constraint (c : su_constraint) = $/;"	v
print_constraints	cil/src/ext/pta/golf.mli	/^val print_constraints : bool ref$/;"	v
print_constraints	cil/src/ext/pta/olf.mli	/^val print_constraints : bool ref$/;"	v
print_constraints	cil/src/ext/pta/ptranal.mli	/^val print_constraints : bool ref$/;"	v
print_constraints	cil/src/ext/pta/steensgaard.mli	/^val print_constraints : bool ref$/;"	v
print_decl	cil/src/frontc/cprint.ml	/^and print_decl (n: string) = function$/;"	v
print_everything	cil/src/ext/liveness.ml	/^let print_everything () =$/;"	v
print_fields	cil/src/frontc/cprint.ml	/^and print_fields (flds : field_group list) =$/;"	v
print_maybe	cil/src/frontc/whitetrack.ml	/^let print_maybe str =$/;"	v
print_maybe	cil/src/frontc/whitetrack.mli	/^val print_maybe : string -> unit$/;"	v
print_path	cil/src/ext/pta/golf.ml	/^let print_path (p : lblinfo path) : unit =$/;"	v
print_result	cil/src/ext/pta/ptranal.ml	/^  let print_result (name, set) =$/;"	v
print_tau_list	cil/src/ext/pta/golf.ml	/^let rec print_tau_list (l : tau list) : unit =$/;"	v
print_tau_list	cil/src/ext/pta/olf.ml	/^let rec print_tau_list (l : tau list) : unit =$/;"	v
print_tau_list	cil/src/ext/pta/steensgaard.ml	/^let rec print_tau_list (l : tau list) : unit = $/;"	v
print_types	cil/src/ext/pta/ptranal.ml	/^let print_types () : unit =$/;"	v
print_types	cil/src/ext/pta/ptranal.mli	/^val print_types : unit -> unit$/;"	v
printerForMaincil	cil/src/cil.ml	/^let printerForMaincil = ref defaultCilPrinter$/;"	v
printf	cil/ocamlutil/pretty.ml	/^let printf format = fprintf stdout format$/;"	v
printf	cil/ocamlutil/pretty.mli	/^val printf: ('a, unit, doc) format -> 'a $/;"	v
printl	cil/src/frontc/whitetrack.ml	/^let printl strs = $/;"	v
printl	cil/src/frontc/whitetrack.mli	/^val printl : string list -> unit$/;"	v
printout	cil/src/mergecil.ml	/^            let printout = $/;"	v
printu	cil/src/frontc/whitetrack.ml	/^let printu str =$/;"	v
printu	cil/src/frontc/whitetrack.mli	/^val printu : string -> unit$/;"	v
priority	cil/src/ext/partial.ml	/^    mutable priority : int;$/;"	r	type:sinfo
private	cil/src/cil.ml	/^  method private d_plainoffset () = function$/;"	m
private	cil/src/cil.ml	/^  method private getPrintInstrTerminator () = printInstrTerminator$/;"	m
private	cil/src/cil.ml	/^  method private pAttrPrec (contextprec: int) () (a: attrparam) = $/;"	m
private	cil/src/cil.ml	/^  method private pLabel () = function$/;"	m
private	cil/src/cil.ml	/^  method private pStmtKind (next: stmt) () = function$/;"	m
private	cil/src/cil.ml	/^  method private pStmtNext (next: stmt) () (s: stmt) =$/;"	m
private	cil/src/cil.ml	/^  method private setPrintInstrTerminator (term : string) =$/;"	m
processArguments	cil/lib/Cilly.pm	/^sub processArguments {$/;"	s
processFundec	cil/src/ext/blockinggraph.ml	/^                let processFundec (fd: fundec) : unit =$/;"	v
processLocal	cil/src/cil.ml	/^          let processLocal (v: varinfo) = $/;"	v
processOneGlobal	cil/src/mergecil.ml	/^  let processOneGlobal (g: global) : unit = $/;"	v
processStmt	cil/src/ext/dataflow.ml	/^    let processStmt (s: stmt) : unit = $/;"	v
processVarinfo	cil/src/mergecil.ml	/^    let processVarinfo (vi: varinfo) (vloc: location) : varinfo =  $/;"	v
processed	cil/src/ext/ssa.ml	/^  let processed = Array.make size false in (* to record the nodes added to work_list *) $/;"	v
program_	src/run_crest/concolic_search.h	/^  const string program_;$/;"	m	class:crest::Search
proj_ref	cil/src/ext/pta/olf.ml	/^let proj_ref (t : tau) : tau =$/;"	v
proj_ref	cil/src/ext/pta/steensgaard.ml	/^let proj_ref (t : tau) : tau = $/;"	v
proper_subterm	cil/src/ext/pta/steensgaard.ml	/^let proper_subterm (t,t') = $/;"	v
protect	cil/lib/OutputFile.pm	/^sub protect {$/;"	s
proto	cil/src/cil.ml	/^         let proto = $/;"	v
proto	cil/src/cil.ml	/^        let proto = $/;"	v
prototypes	cil/configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
prune_cfg	cil/src/ext/ssa.ml	/^let prune_cfg (f: cfgInfo): cfgInfo = $/;"	v
prune_cfg	cil/src/ext/ssa.mli	/^val prune_cfg: cfgInfo -> cfgInfo$/;"	v
ptrAnalysis	cil/src/ext/pta/ptranal.ml	/^let ptrAnalysis = ref false$/;"	v
ptrResults	cil/src/ext/pta/ptranal.ml	/^let ptrResults = ref false$/;"	v
ptrTypes	cil/src/ext/pta/ptranal.ml	/^let ptrTypes = ref false$/;"	v
ptsets	cil/src/ext/pta/golf.ml	/^  let ptsets =$/;"	v
pullTypesForward	cil/src/cil.ml	/^let pullTypesForward = true$/;"	v
push	cil/ocamlutil/util.mli	/^  val push : 'a -> 'a t -> unit$/;"	v	Module:STACK
pushContext	cil/ocamlutil/errormsg.ml	/^let pushContext f = errorContext := f :: (!errorContext)$/;"	v
pushContext	cil/ocamlutil/errormsg.mli	/^val pushContext  : (unit -> Pretty.doc) -> unit$/;"	v
pushGlobal	cil/src/cil.ml	/^let pushGlobal (g: global) $/;"	v
pushGlobal	cil/src/cil.mli	/^val pushGlobal: global -> types: global list ref $/;"	v
push_context	cil/obj/x86_LINUX/clexer.ml	/^let push_context _ = context := []::!context$/;"	v
push_context	cil/obj/x86_LINUX/clexer.mli	/^val push_context: unit -> unit (* Start a context  *)$/;"	v
push_context	cil/src/frontc/clexer.mli	/^val push_context: unit -> unit (* Start a context  *)$/;"	v
q	cil/test/small1/init.c	/^short q[4][3][2] = {$/;"	v
q1	cil/test/small1/init.c	/^short q1[4][3][2] = {$/;"	v
query	cil/src/ext/predabst.ml	/^    let query (blh : boolLat IH.t) (e : exp) : boolLat =$/;"	v
questionLevel	cil/src/cil.ml	/^let questionLevel = 100$/;"	v
queue	cil/obj/x86_LINUX/cparser.ml	/^      let queue = Queue.create () in$/;"	v
queue	cil/obj/x86_LINUX/cparser.ml	/^     let queue, location = _1 in$/;"	v
quoteIfNecessary	cil/lib/Cilly.pm	/^sub quoteIfNecessary {$/;"	s
reachable	cil/src/ext/ssa.mli	/^    mutable reachable: bool;$/;"	r	type:cfgBlock
reachable_branches_	src/run_crest/concolic_search.h	/^  unsigned int reachable_branches_;$/;"	m	class:crest::Search
reachable_functions_	src/run_crest/concolic_search.h	/^  unsigned int reachable_functions_;$/;"	m	class:crest::Search
reachable_preds	cil/src/ext/partial.ml	/^    reachable_preds : (int, bool) Hashtbl.t;$/;"	r	type:sinfo
reached_	src/run_crest/concolic_search.h	/^  vector<bool> reached_;$/;"	m	class:crest::Search
readBranches	src/process_cfg/process_cfg.cc	/^void readBranches(set<int>* branches) {$/;"	f
readCfg	src/process_cfg/process_cfg.cc	/^void readCfg(graph_t* graph) {$/;"	f
readCounter	cil/src/ext/crestInstrument.ml	/^let readCounter fname =$/;"	v
readFunCount	cil/src/ext/crestInstrument.ml	/^let readFunCount () = (funCount := readCounter "funcount")$/;"	v
readIdCount	cil/src/ext/crestInstrument.ml	/^let readIdCount () = (idCount := readCounter "idcount")$/;"	v
readIncludeLine	cil/bin/patcher	/^sub readIncludeLine {$/;"	s
readStmtCount	cil/src/ext/crestInstrument.ml	/^let readStmtCount () = (stmtCount := readCounter "stmtcount")$/;"	v
read_pentium_perfcount	cil/ocamlutil/perfcount.c	/^value read_pentium_perfcount()$/;"	f
read_ppc	cil/ocamlutil/perfcount.c	/^inline unsigned longlong read_ppc(void) {$/;"	f
readingFromStdin	cil/ocamlutil/errormsg.ml	/^let readingFromStdin = ref false$/;"	v
readingFromStdin	cil/ocamlutil/errormsg.mli	/^val readingFromStdin: bool ref$/;"	v
real	cil/ocamlutil/pretty.ml	/^let real f        = text (string_of_float f)$/;"	v
real	cil/ocamlutil/pretty.mli	/^val real         : float  -> doc$/;"	v	function:++
recordFile	cil/src/ciloptions.mli	/^val recordFile: string -> unit$/;"	v
record_alias	cil/src/ext/pta/golf.ml	/^  let record_alias s lo s' lo' =$/;"	v
recurse	cil/src/rmtmps.ml	/^	      let recurse f = visitType f.ftype in$/;"	v
reg	cil/src/ext/partial.ml	/^  type reg = {$/;"	t
reg	cil/src/ext/ssa.mli	/^and reg = int$/;"	t
regToVarinfo	cil/src/ext/ssa.mli	/^    mutable regToVarinfo: Cil.varinfo array; (** Map register IDs to varinfo *)$/;"	r	type:cfgInfo
registerAlphaName	cil/ocamlutil/alpha.mli	/^val registerAlphaName: alphaTable:(string, 'a alphaTableData ref) Hashtbl.t -> $/;"	v
registerSymbolName	cil/ocamlutil/util.ml	/^let registerSymbolName (n: string) : symbol = $/;"	v
registeredSymbolNames	cil/ocamlutil/util.ml	/^let registeredSymbolNames: (string, symbol) H.t = H.create 113$/;"	v
remove	cil/ocamlutil/inthash.ml	/^let remove h key =$/;"	v
remove	cil/ocamlutil/inthash.mli	/^val remove: 'a t -> int -> unit$/;"	v
remove	cil/ocamlutil/intmap.ml	/^let rec remove x = function$/;"	v
remove	cil/ocamlutil/intmap.mli	/^val remove: int -> 'a t -> 'a t$/;"	v
remove	cil/src/ext/partial.ml	/^              let remove stmt b =$/;"	v
remove	cil/src/ext/pta/setp.ml	/^    let rec remove x = function$/;"	v
removeMappingsThatDependOn	cil/src/ext/partial.ml	/^  let removeMappingsThatDependOn regFile l =$/;"	v
removeOffset	cil/src/cil.mli	/^val removeOffset:   offset -> offset * offset$/;"	v
removeOffsetLval	cil/src/cil.ml	/^let removeOffsetLval ((b, off): lval) : lval * offset = $/;"	v
removeOffsetLval	cil/src/cil.mli	/^val removeOffsetLval: lval -> lval * offset$/;"	v
removeUnmarked	cil/src/rmtmps.ml	/^let removeUnmarked file =$/;"	v
removeUnusedLabels	cil/src/rmtmps.ml	/^class removeUnusedLabels (labelMap: (string, unit) H.t) = object$/;"	c
removeUnusedTemps	cil/src/rmtmps.ml	/^let rec removeUnusedTemps ?(isRoot : rootsFilter = isDefaultRoot) file =$/;"	v
removeUnusedTemps	cil/src/rmtmps.mli	/^val removeUnusedTemps: ?isRoot:rootsFilter -> Cil.file -> unit$/;"	v
remove_all	cil/ocamlutil/inthash.ml	/^let remove_all h key =$/;"	v
remove_all	cil/ocamlutil/inthash.mli	/^val remove_all: 'a t -> int -> unit$/;"	v
remove_min_binding	cil/ocamlutil/intmap.ml	/^let rec remove_min_binding = function$/;"	v
removedCount	cil/src/ext/deadcodeelim.ml	/^let removedCount = ref 0$/;"	v
removedLocals	cil/src/rmtmps.ml	/^      let removedLocals = removeUnmarked file in$/;"	v
renameInlineVisitorClass	cil/src/mergecil.ml	/^class renameInlineVisitorClass = object (self)$/;"	c
renameInlinesVisitor	cil/src/mergecil.ml	/^let renameInlinesVisitor = new renameInlineVisitorClass$/;"	v
renameOne	cil/src/mergecil.ml	/^              let renameOne (v: varinfo) = $/;"	v
renameVisitor	cil/src/mergecil.ml	/^let renameVisitor = new renameVisitorClass$/;"	v
renameVisitorClass	cil/src/mergecil.ml	/^class renameVisitorClass = object (self)$/;"	c
rep	cil/src/mergecil.ml	/^      let rep = find pathcomp nd in$/;"	v
rep	cil/src/mergecil.ml	/^    let rep, norep = (* Choose the representative *)$/;"	v
repeattime	cil/ocamlutil/stats.ml	/^let repeattime limit str f arg = $/;"	v
repeattime	cil/ocamlutil/stats.mli	/^val repeattime : float -> string -> ('a -> 'b) -> 'a -> 'b$/;"	v
replace	cil/ocamlutil/inthash.ml	/^let replace h key info =$/;"	v
replace	cil/ocamlutil/inthash.mli	/^val replace: 'a t -> int -> 'a -> unit$/;"	v
res	cil/obj/x86_LINUX/formatparse.ml	/^                             let res = $/;"	v
res	cil/ocamlutil/pretty.ml	/^  let res = $/;"	v
res	cil/ocamlutil/pretty.ml	/^  let res = gprintf f format in$/;"	v
res	cil/src/cil.ml	/^              let res = $/;"	v
res	cil/src/cil.ml	/^        let res = s :: compress dummyStmt Clist.empty rest in$/;"	v
res	cil/src/cil.ml	/^    let res = $/;"	v
res	cil/src/cil.ml	/^    let res = loop [] a in$/;"	v
res	cil/src/cil.ml	/^  let res = doVisit vis vis#vstmt (childrenStmt toPrepend) s in$/;"	v
res	cil/src/formatcil.ml	/^  let res = makeLocalVar func "res" (TPtr(intType, [])) in$/;"	v
res	cil/src/mergecil.ml	/^              let res = d_global () g' in$/;"	v
res	cil/src/mergecil.ml	/^      let res = combineTypes what oldfidx oldt fidx t.ttype in$/;"	v
res	cil/src/mergecil.ml	/^      let res = combineTypes what oldfidx oldt.ttype fidx t in$/;"	v
res	cil/src/mergecil.ml	/^    let res = find pathcomp nd.nrep in$/;"	v
res	cil/src/mergecil.ml	/^  let res = $/;"	v
reset	cil/ocamlutil/stats.mli	/^val reset: timerModeEnum -> unit$/;"	v
resetSymbols	cil/ocamlutil/util.ml	/^let resetSymbols () = $/;"	v
resetThunk	cil/ocamlutil/util.ml	/^let resetThunk: (unit -> unit) option ref = ref None$/;"	v
reset_max_init_index	cil/ocamlutil/growArray.ml	/^let reset_max_init_index (ga: 'a t) : unit =$/;"	v
reset_max_init_index	cil/ocamlutil/growArray.mli	/^val reset_max_init_index : 'a t -> unit$/;"	v
reset_performance_counters	cil/ocamlutil/perfcount.c	/^value reset_performance_counters() {$/;"	f
resolve_exp	cil/src/ext/pta/ptranal.ml	/^let resolve_exp (e : exp) : varinfo list =$/;"	v
resolve_exp	cil/src/ext/pta/ptranal.mli	/^val resolve_exp : Cil.exp -> (Cil.varinfo list)$/;"	v
resolve_funptr	cil/src/ext/pta/ptranal.ml	/^let resolve_funptr (e : exp) : fundec list =$/;"	v
resolve_funptr	cil/src/ext/pta/ptranal.mli	/^val resolve_funptr : Cil.exp -> (Cil.fundec list)$/;"	v
resolve_lval	cil/src/ext/pta/ptranal.ml	/^let resolve_lval (lv : lval) : varinfo list =$/;"	v
resolve_lval	cil/src/ext/pta/ptranal.mli	/^val resolve_lval : Cil.lval -> (Cil.varinfo list)$/;"	v
rest	cil/obj/x86_LINUX/cparser.ml	/^                                               ( let rest = _3 in$/;"	v
rest	cil/obj/x86_LINUX/cparser.ml	/^                                          ( let rest, isva = _4 in$/;"	v
rest	cil/obj/x86_LINUX/formatparse.ml	/^                        let (rest, isva) = (fst _3) args in$/;"	v
rest	cil/obj/x86_LINUX/formatparse.ml	/^                     let rest = _6 mkTemp loc ((n, Fv v) :: args) in$/;"	v
restoreArray	cil/ocamlutil/util.mli	/^val restoreArray: ?deepCopy:('a -> 'a) -> 'a array -> unit -> unit$/;"	v
restoreGA	cil/ocamlutil/growArray.ml	/^let restoreGA ?deepCopy (ga: 'a t) : (unit -> unit) = $/;"	v
restoreGA	cil/ocamlutil/growArray.mli	/^val restoreGA: ?deepCopy:('a -> 'a) -> 'a t -> unit -> unit$/;"	v
restoreHash	cil/ocamlutil/util.mli	/^val restoreHash: ?deepCopy:('b -> 'b) -> ('a, 'b) Hashtbl.t -> unit -> unit$/;"	v
restoreIntHash	cil/ocamlutil/util.mli	/^val restoreIntHash: ?deepCopy:('b -> 'b) -> 'b Inthash.t -> unit -> unit$/;"	v
restoreRef	cil/ocamlutil/util.mli	/^val restoreRef: ?deepCopy:('a -> 'a) -> 'a ref -> unit -> unit$/;"	v
result	cil/src/ext/pta/steensgaard.ml	/^	let result = ref (C.empty) in$/;"	v
result	cil/src/ext/ssa.ml	/^  let result = Array.create size ([]) in$/;"	v
result	cil/src/ext/ssa.ml	/^  let result = { headers = set2list !headers; backEdges = !backEdges; nodes = nodeList; } in$/;"	v
result	cil/src/ext/ssa.ml	/^ let result: cfgInfo = $/;"	v
result	cil/src/frontc/frontc.ml	/^        let result = (Stats.time "newpatch" (Patch.applyPatch pf) cabs) in$/;"	v
result	cil/src/frontc/patch.ml	/^  let result : definition list =$/;"	v
resultExpr	cil/obj/x86_LINUX/cparser.ml	/^  let resultExpr = CAST (sizeofType, SINGLE_INIT addrExpr) in$/;"	v
ret	cil/src/cil.ml	/^    let ret = (func () obj) in    (* call underlying printer *)$/;"	v
ret'	cil/src/ext/dataslicing.ml	/^      let ret', set =$/;"	v
retPreds	cil/src/ext/predabst.ml	/^      let retPreds = $/;"	v
retPreds	cil/src/ext/predabst.ml	/^      let retPreds = makeFormalPreds localsNoRet preds in$/;"	v
retPreds'	cil/src/ext/predabst.ml	/^      let retPreds' = List.filter $/;"	v
retStmt	cil/src/ext/oneret.ml	/^  let retStmt : stmt ref = ref dummyStmt in$/;"	v
return	cil/src/ext/partial.ml	/^  let return r fd =$/;"	v
return	cil/src/ext/pta/golf.ml	/^let return (t : tau) (t' : tau) =$/;"	v
return	cil/src/ext/pta/golf.mli	/^val return : tau -> tau -> unit$/;"	v
return	cil/src/ext/pta/olf.ml	/^let return (t : tau) (t' : tau) =$/;"	v
return	cil/src/ext/pta/olf.mli	/^val return : tau -> tau -> unit$/;"	v
return	cil/src/ext/pta/steensgaard.ml	/^let return (t : tau) (t' : tau) =$/;"	v
return	cil/src/ext/pta/steensgaard.mli	/^val return : tau -> tau -> unit$/;"	v
return_value_	src/base/symbolic_interpreter.h	/^  bool return_value_;$/;"	m	class:crest::SymbolicInterpreter
rev	cil/ocamlutil/clist.ml	/^let rec rev (revelem: 'a -> 'a) = function$/;"	v
rev	cil/ocamlutil/clist.mli	/^val rev: ('a -> 'a) -> 'a clist -> 'a clist$/;"	v
revResult	cil/src/ext/ssa.ml	/^  let revResult = ref ([]) in$/;"	v
revonto	cil/src/mergecil.ml	/^  let rec revonto acc = function$/;"	v
rewriteExp	cil/src/ext/partial.ml	/^  let rewriteExp r (e : exp) : exp * bool =$/;"	v
rewriteExpClass	cil/src/ext/partial.ml	/^  class rewriteExpClass (regFile : t) =$/;"	c
rhs	cil/src/ext/reachingdefs.ml	/^type rhs = RDExp of exp | RDCall of instr$/;"	t
rhsHtbl	cil/src/ext/reachingdefs.ml	/^let rhsHtbl = IH.create 64 (* to avoid recomputation *)$/;"	v
rmUnusedInlines	cil/src/rmtmps.mli	/^val rmUnusedInlines: bool ref (* Delete unused inline funcs in gcc mode? *)$/;"	v
rmem	cil/src/ext/partial.ml	/^    rmem : bool$/;"	r	type:reg
root_fun	cil/src/ext/partial.ml	/^let root_fun = ref "main"$/;"	v
rootsFilter	cil/src/rmtmps.ml	/^type rootsFilter = global -> bool$/;"	t
rootsFilter	cil/src/rmtmps.mli	/^type rootsFilter = Cil.global -> bool$/;"	t
rpreds	cil/src/ext/predabst.ml	/^	  let rpreds =$/;"	v
rt	cil/src/ext/canonicalize.ml	/^	let rt, formals, isva, attrs = splitFunctionType (typeOf f) in$/;"	v
rule7	cil/src/ext/pta/golf.ml	/^    and rule7 p =$/;"	v
runShell	cil/lib/Cilly.pm	/^sub runShell {$/;"	s
runThunks	cil/ocamlutil/util.mli	/^val runThunks: (unit -> unit) list -> unit -> unit$/;"	v
rval	cil/src/ext/partial.ml	/^    rval : exp;$/;"	r	type:reg
rvalue	cil/src/ext/pta/golf.mli	/^val rvalue : lvalue -> tau$/;"	v
rvalue	cil/src/ext/pta/olf.mli	/^val rvalue : lvalue -> tau$/;"	v
rvalue	cil/src/ext/pta/steensgaard.mli	/^val rvalue : lvalue -> tau$/;"	v
rvi	cil/src/ext/partial.ml	/^    rvi : varinfo;$/;"	r	type:reg
s	cil/obj/x86_LINUX/cparser.ml	/^                                        ( let s, d = _3 in$/;"	v
s	cil/ocamlutil/errormsg.ml	/^let s (d : 'a) = raise Error$/;"	v
s	cil/ocamlutil/errormsg.mli	/^val s:             'a -> 'b$/;"	v
s	cil/ocamlutil/util.ml	/^        let s = input_line ic in$/;"	v
s	cil/src/ext/pta/golf.ml	/^          let s = ref ""$/;"	v
s	cil/src/ext/pta/olf.ml	/^          let s = ref ""$/;"	v
s	cil/src/ext/pta/steensgaard.ml	/^	  let s = ref "" in$/;"	v
s	cil/src/ext/ssa.ml	/^      let s = ref(IntSet.empty) in $/;"	v
s	cil/src/ext/ssa.ml	/^  let s = Array.make nrRegs ([start]) in $/;"	v
s	cil/src/testcil.ml	/^            let s = $/;"	v
s	cil/src/testcil.ml	/^      let s = mkStmtOneInstr (Call(None, Lval(var checkSizeOfFun.svar),$/;"	v
s	cil/test/small1/init.c	/^typedef struct s {$/;"	s	file:
s'	cil/src/ext/dataflow.ml	/^            let s' = $/;"	v
s'	cil/src/frontc/cabsvisit.ml	/^      let s' = visitCabsSpecifier vis s in$/;"	v
s0	cil/src/ext/dataflow.ml	/^      let s0 = getStmtStartData s in $/;"	v
s1	cil/test/small1/init1.c	/^  } s1;$/;"	m	struct:__anon7	typeref:struct:__anon7::__anon8	file:
s1'	cil/src/cil.ml	/^        let s1'= fBlock s1 in let s2'= fBlock s2 in$/;"	v
s2	cil/test/small1/init1.c	/^  } s2;$/;"	m	struct:__anon7	typeref:struct:__anon7::__anon9	file:
s2'	cil/src/cil.ml	/^        let s1'= fBlock s1 in let s2'= fBlock s2 in$/;"	v
sAlpha	cil/src/mergecil.ml	/^let sAlpha : (string, location A.alphaTableData ref) H.t $/;"	v
sEq	cil/src/mergecil.ml	/^let sEq: (int * string, compinfo node) H.t = H.create 111 (* Struct + union *)$/;"	v
sSyn	cil/src/mergecil.ml	/^let sSyn: (string, compinfo node) H.t = H.create 111$/;"	v
sallstmts	cil/src/cil.mli	/^      mutable sallstmts: stmt list;  (** After you call {!Cil.computeCFGInfo} $/;"	r	type:fundec
samev	cil/src/mergecil.ml	/^          let samev = $/;"	v
sample_pentium_perfcount_10	cil/ocamlutil/perfcount.c	/^value sample_pentium_perfcount_10()$/;"	f
sample_pentium_perfcount_10	cil/ocamlutil/stats.mli	/^val sample_pentium_perfcount_10: unit -> int$/;"	v
sample_pentium_perfcount_20	cil/ocamlutil/perfcount.c	/^value sample_pentium_perfcount_20()$/;"	f
sample_pentium_perfcount_20	cil/ocamlutil/stats.mli	/^val sample_pentium_perfcount_20: unit -> int$/;"	v
sample_ppc_10	cil/ocamlutil/perfcount.c	/^inline static unsigned long sample_ppc_10()$/;"	f	file:
sample_ppc_20	cil/ocamlutil/perfcount.c	/^static unsigned long sample_ppc_20(void)$/;"	f	file:
saveBinaryFile	cil/src/cil.mli	/^val saveBinaryFile : file -> string -> unit$/;"	v
saveBinaryFileChannel	cil/src/cil.mli	/^val saveBinaryFileChannel : file -> out_channel -> unit$/;"	v
saveConfiguration	cil/ocamlutil/util.ml	/^let saveConfiguration (fname: string) = $/;"	v
savedTheFile	cil/src/mergecil.ml	/^  let savedTheFile = !theFile in$/;"	v
sbody	cil/src/cil.mli	/^      mutable sbody: block;          (** The function body. *)$/;"	r	type:fundec
scan	cil/ocamlutil/pretty.ml	/^let rec scan (abscol: int) (d: doc) : int = $/;"	v
scanBlock	cil/src/ext/oneret.ml	/^  and scanBlock (mainbody: bool) (b: block) = $/;"	v
scanStmts	cil/src/ext/oneret.ml	/^  let rec scanStmts (mainbody: bool) = function$/;"	v
scanUntil	cil/src/mergecil.ml	/^    let rec scanUntil (tail: 'a list) (l: 'a list) = $/;"	v
scan_escape	cil/obj/x86_LINUX/clexer.ml	/^let scan_escape (char: char) : int64 =$/;"	v
sccId	cil/src/ext/ssa.ml	/^  let sccId = Array.make size (-1) in$/;"	v
sccInfo	cil/src/ext/ssa.mli	/^and sccInfo = oneSccInfo list $/;"	t
sccNodes	cil/src/ext/ssa.ml	/^      let sccNodes = ref(IntSet.empty) in$/;"	v
scclist	cil/src/ext/ssa.ml	/^  let scclist = List.map (fun i -> $/;"	v
sccorder	cil/src/ext/ssa.ml	/^  let sccorder = preorderDAG nrScc successors in$/;"	v
sdoms	cil/src/ext/dominators.ml	/^               let sdoms = getStmtDominators DT.stmtStartData s in$/;"	v
search	cil/src/ext/ssa.ml	/^  let rec search (x: int): unit = (* x is a graph node *)$/;"	v
sec-cilly-asm-options	cil/doc/cil.html	/^<A NAME="sec-cilly-asm-options"><\/A><\/P><P>All of the options that start with <TT>--<\/TT> and are not understood by$/;"	a
sec-cilly-asm-options	cil/doc/cil007.html	/^<A NAME="sec-cilly-asm-options"><\/A><\/P><P>All of the options that start with <TT>--<\/TT> and are not understood by$/;"	a
sec-cilly-internal-options	cil/doc/cil.html	/^<A NAME="sec-cilly-internal-options"><\/A><\/P><P>All of the <TT>cilly.asm<\/TT> options described above can be set$/;"	a
sec-cilly-internal-options	cil/doc/cil007.html	/^<A NAME="sec-cilly-internal-options"><\/A><\/P><P>All of the <TT>cilly.asm<\/TT> options described above can be set$/;"	a
separateStorageModifiers	cil/src/cil.mli	/^val separateStorageModifiers: attribute list -> attribute list * attribute list$/;"	v
separateTrueObjects	cil/lib/Cilly.pm	/^sub separateTrueObjects {$/;"	s
separate_loffsets	cil/src/ext/simplemem.ml	/^let rec separate_loffsets lo = $/;"	v
seq	cil/ocamlutil/pretty.ml	/^let seq ~(sep:doc)  ~(doit:'a -> doc) ~(elements: 'a list) = $/;"	v
seq	cil/ocamlutil/pretty.mli	/^val seq: sep:doc -> doit:('a ->doc) -> elements:'a list -> doc$/;"	v	function:++
set	cil/ocamlutil/growArray.ml	/^let set (ga: 'a t) (r: int) (what: 'a) : unit = $/;"	v
set	cil/ocamlutil/growArray.mli	/^val set : 'a t -> int -> 'a -> unit$/;"	v
set	cil/ocamlutil/longarray.mli	/^val set : 'a t -> int -> 'a -> unit$/;"	v
set	cil/src/ext/bitmap.ml	/^let set bmp i tv = $/;"	v
set	cil/src/ext/bitmap.mli	/^val  set : t -> int -> bool -> unit$/;"	v
set	cil/src/ext/deadcodeelim.ml	/^		      let set = IH.find sidUseSetHash i in$/;"	v
set2list	cil/src/ext/ssa.ml	/^let set2list s = $/;"	v
setCurrentFile	cil/ocamlutil/errormsg.mli	/^val setCurrentFile: string -> unit$/;"	v
setCurrentLine	cil/ocamlutil/errormsg.mli	/^val setCurrentLine: int -> unit$/;"	v
setDefaultArguments	cil/lib/Cilly.pm	/^sub setDefaultArguments {$/;"	s
setFinalWhite	cil/src/frontc/whitetrack.ml	/^let setFinalWhite w = finalwhite := w $/;"	v
setFinalWhite	cil/src/frontc/whitetrack.mli	/^val setFinalWhite : string -> unit$/;"	v
setFirstSource	cil/lib/Cilly.pm	/^sub setFirstSource {$/;"	s
setFormals	cil/src/cil.ml	/^let setFormals (f: fundec) (forms: varinfo list) = $/;"	v
setFormals	cil/src/cil.mli	/^val setFormals: fundec -> varinfo list -> unit$/;"	v
setFunctionType	cil/src/cil.ml	/^let setFunctionType (f: fundec) (t: typ) = $/;"	v
setFunctionType	cil/src/cil.mli	/^val setFunctionType: fundec -> typ -> unit$/;"	v
setFunctionTypeMakeFormals	cil/src/cil.mli	/^val setFunctionTypeMakeFormals: fundec -> typ -> unit$/;"	v
setHFile	cil/ocamlutil/errormsg.mli	/^val setHFile: string -> unit$/;"	v
setHLine	cil/ocamlutil/errormsg.mli	/^val setHLine: int -> unit$/;"	v
setLoc	cil/src/frontc/whitetrack.ml	/^let setLoc cabsloc =$/;"	v
setLoc	cil/src/frontc/whitetrack.mli	/^val setLoc : Cabs.cabsloc -> unit$/;"	v
setLv	cil/src/testcil.ml	/^            let setLv (v: exp) = $/;"	v
setMSVCMode	cil/src/frontc/frontc.ml	/^let setMSVCMode () =$/;"	v
setMSVCMode	cil/src/frontc/frontc.mli	/^val setMSVCMode: unit -> unit$/;"	v
setMaxId	cil/src/cil.ml	/^let setMaxId (f: fundec) = $/;"	v
setMaxId	cil/src/cil.mli	/^val setMaxId: fundec -> unit$/;"	v
setMemory	cil/src/ext/partial.ml	/^  let setMemory regFile =$/;"	v
setOutput	cil/src/frontc/whitetrack.mli	/^val setOutput : out_channel -> unit$/;"	v
setReg	cil/ocamlutil/util.ml	/^let setReg (ga: 'a growArray) (r: int) (what: 'a) : unit = $/;"	v
setRegister	cil/src/ext/partial.ml	/^  let setRegister regFile (v : varinfo) ((e, b) : exp * bool) =$/;"	v
setTypeAttrs	cil/src/cil.mli	/^val setTypeAttrs: typ -> attributes -> typ (* Resets the attributes *)$/;"	v
setTypeSigAttrs	cil/src/cil.mli	/^val setTypeSigAttrs: attributes -> typsig -> typsig $/;"	v
setVersion	cil/lib/Cilly.pm	/^sub setVersion {$/;"	s
set_flow_computed	cil/src/ext/pta/olf.ml	/^let set_flow_computed l =$/;"	v
set_global	cil/src/ext/pta/golf.ml	/^let set_global (t : tau) (b : bool) : unit =$/;"	v
set_global_label	cil/src/ext/pta/golf.ml	/^let set_global_label (l : label) (b : bool) : unit =$/;"	v
set_output	cil/src/frontc/frontc.ml	/^let set_output filename =$/;"	v
set_top_c_absloc	cil/src/ext/pta/olf.ml	/^let set_top_c_absloc (l : c_absloc) (b: bool) : unit =$/;"	v
setg	cil/ocamlutil/growArray.ml	/^let setg (ga: 'a t) (r: int) (what: 'a) : unit = $/;"	v
setg	cil/ocamlutil/growArray.mli	/^val setg : 'a t -> int -> 'a -> unit$/;"	v
sfiVisitorClass	cil/src/ext/sfi.ml	/^class sfiVisitorClass : Cil.cilVisitor = object (self)$/;"	c
sformals	cil/src/cil.mli	/^      mutable sformals: varinfo list;   $/;"	r	type:fundec
sg	cil/src/ext/oneret.ml	/^          let sg = mkStmt (Goto (sgref, l)) in$/;"	v
sgAnalyzeVisitor	cil/src/ext/heapify.ml	/^class sgAnalyzeVisitor f push pop get_ra set_ra = object$/;"	c
sgModifyVisitor	cil/src/ext/heapify.ml	/^class sgModifyVisitor restore_ra_stmt = object$/;"	c
sgref	cil/src/ext/oneret.ml	/^          let sgref = ref (getRetStmt ()) in$/;"	v
shallowAlign	cil/ocamlutil/pretty.ml	/^let shallowAlign () = $/;"	v
shiftInBounds	cil/src/cil.ml	/^      let shiftInBounds i2 =$/;"	v
shl_load	cil/libstr/ltconfig	/^shl_load()$/;"	f
shl_load	cil/libstr/ltconfig	/^shl_load();$/;"	f
shouldSkipFunction	cil/src/ext/crestInstrument.ml	/^let shouldSkipFunction f = hasAttribute "crest_skip" f.vattr$/;"	v
showContext	cil/ocamlutil/errormsg.mli	/^val showContext : unit -> unit$/;"	v
show_progress	cil/src/ext/pta/ptranal.mli	/^val show_progress : bool ref $/;"	v
show_progress_fn	cil/src/ext/pta/ptranal.ml	/^  let show_progress_fn (counted : int ref) (total : int) : unit =$/;"	v
si	cil/src/ext/partial.ml	/^                    let si = get_sinfo s in$/;"	v
sid	cil/src/cil.mli	/^    mutable sid: int;                  $/;"	r	type:stmt
sidVisitor	cil/src/ext/ciltools.ml	/^class sidVisitor = object$/;"	c
sid_counter	cil/src/cil.ml	/^let sid_counter = ref 0$/;"	v
sign	cil/src/ext/ciltools.ml	/^type sign = Signed | Unsigned $/;"	t
signed	cil/src/cil.ml	/^  let signed = isSigned k in$/;"	v
simpleOrder	cil/src/ext/ssa.ml	/^  let simpleOrder = Array.init size (fun i -> i) in$/;"	v
simplemem	cil/src/ext/simplemem.ml	/^let simplemem (f : file) =$/;"	v
simplify	cil/src/ext/partial.ml	/^    let simplify file c fd (assumptions : (Cil.lval * Cil.exp) list) =$/;"	v
simplifyOffset	cil/src/ext/simplify.ml	/^and simplifyOffset (setTemp: taExp -> bExp) = function$/;"	v
simulate	cil/src/ext/pta/golf.ml	/^  let rec simulate c l l' =$/;"	v
sinfo	cil/src/ext/partial.ml	/^  type sinfo = { (* statement info *)$/;"	t
sinfo_ht	cil/src/ext/partial.ml	/^  let sinfo_ht = Hashtbl.create 511$/;"	v
single	cil/ocamlutil/clist.ml	/^let single x = CList [x]$/;"	v
single	cil/ocamlutil/clist.mli	/^val single: 'a -> 'a clist        $/;"	v
single_name	cil/src/frontc/cabs.ml	/^and single_name = specifier * name$/;"	t
singleton	cil/src/ext/pta/setp.ml	/^    let singleton x = Node(Empty, x, Empty, 1)$/;"	v
sinkFinder	cil/src/ext/dataflow.ml	/^let sinkFinder = object(self)$/;"	v
sink_stmts	cil/src/ext/dataflow.ml	/^let sink_stmts = ref []$/;"	v
size	cil/ocamlutil/inthash.ml	/^  { mutable size: int;                        (* number of elements *)$/;"	r	type:t
size	cil/src/ext/bitmap.mli	/^val  size : t -> int                    (* How much space it is reserved *)$/;"	v
size	cil/src/ext/heap.ml	/^  mutable size      : int ; (* current number of elements *)$/;"	r	type:t
size	cil/src/ext/ssa.mli	/^    size    : int;    $/;"	r	type:cfgInfo
sizeType	cil/src/cil.ml	/^  let sizeType = !upointType in$/;"	v
size_t	cil/obj/x86_LINUX/machdep.ml	/^  size_t: string;         (* Type of "sizeof(T)" *)$/;"	r	type:mach
sizeofType	cil/obj/x86_LINUX/cparser.ml	/^  let sizeofType = [SpecType Tunsigned], JUSTBASE in$/;"	v
sizeof_double	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_double: int;     (* Size of "double" *)$/;"	r	type:mach
sizeof_enum	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_enum: int;       (* Size of enum types *)$/;"	r	type:mach
sizeof_float	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_float: int;      (* Size of "float" *)$/;"	r	type:mach
sizeof_fun	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_fun: int;        (* Size of function *)$/;"	r	type:mach
sizeof_int	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_int: int;        (* Size of "int" *)$/;"	r	type:mach
sizeof_long	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_long: int ;      (* Size of "long" *)$/;"	r	type:mach
sizeof_longdouble	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_longdouble: int; (* Size of "long double" *)$/;"	r	type:mach
sizeof_longlong	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_longlong: int;   (* Size of "long long" *)$/;"	r	type:mach
sizeof_ptr	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_ptr: int;        (* Size of pointers *)$/;"	r	type:mach
sizeof_short	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_short: int;      (* Size of "short" *)$/;"	r	type:mach
sizeof_void	cil/obj/x86_LINUX/machdep.ml	/^  sizeof_void: int;       (* Size of "void" *)$/;"	r	type:mach
skind	cil/src/cil.mli	/^    mutable skind: stmtkind;           $/;"	r	type:stmt
skind'	cil/src/cil.ml	/^  let skind' = $/;"	v
skipSuffix	cil/ocamlutil/alpha.ml	/^  let rec skipSuffix (i: int) = $/;"	v
skip_args	cil/ocamlutil/pretty.ml	/^  and skip_args j =$/;"	v
sl	cil/ocamlutil/pretty.ml	/^        let sl = String.length s in $/;"	v
sliceFile	cil/src/ext/dataslicing.ml	/^let sliceFile (f : file) : unit =$/;"	v
sliceFundec	cil/src/ext/dataslicing.ml	/^let sliceFundec (fd : fundec) (l : location) : unit =$/;"	v
sliceGlobal	cil/src/cilutil.ml	/^let sliceGlobal = ref false$/;"	v
sliceGlobal	cil/src/ext/dataslicing.ml	/^let sliceGlobal (g : global) : unit =$/;"	v
sliceGlobalVars	cil/src/ext/dataslicing.ml	/^let sliceGlobalVars (g : global) : unit =$/;"	v
sliceInstr	cil/src/ext/dataslicing.ml	/^let sliceInstr (inst : instr) : instr list =$/;"	v
sliceLval	cil/src/ext/dataslicing.ml	/^and sliceLval (i : int) (lv : lval) : lval =$/;"	v
sliceReturnExp	cil/src/ext/dataslicing.ml	/^let sliceReturnExp (eo : exp option) (l : location) : stmtkind =$/;"	v
sliceStmtKind	cil/src/ext/dataslicing.ml	/^let rec sliceStmtKind (sk : stmtkind) : stmtkind =$/;"	v
sliceVar	cil/src/ext/dataslicing.ml	/^let sliceVar (vinfo : varinfo) : unit =$/;"	v
slocals	cil/src/cil.mli	/^      mutable slocals: varinfo list;    $/;"	r	type:fundec
slst	cil/src/ext/predabst.ml	/^	  let slst = fd.sbody.bstmts in$/;"	v
smart_alias_query	cil/src/ext/pta/golf.ml	/^let smart_alias_query (l : label) (l' : label) : bool =$/;"	v
smart_aliases	cil/src/ext/pta/golf.mli	/^val smart_aliases : bool ref$/;"	v
smart_aliases	cil/src/ext/pta/olf.mli	/^val smart_aliases : bool ref$/;"	v
smart_aliases	cil/src/ext/pta/ptranal.mli	/^val smart_aliases : bool ref$/;"	v
smaxid	cil/src/cil.mli	/^      mutable smaxid: int;           (** Max local id. Starts at 0. Used for $/;"	r	type:fundec
smaxstmtid	cil/src/cil.mli	/^      mutable smaxstmtid: int option;  (** max id of a (reachable) statement $/;"	r	type:fundec
snapshotSymbols	cil/ocamlutil/util.ml	/^let snapshotSymbols () : unit -> unit = $/;"	v
snd3	cil/obj/x86_LINUX/cparser.ml	/^let snd3 (_, result, _) = result$/;"	v
snl'	cil/src/frontc/cabsvisit.ml	/^      let snl' = mapNoCopy (childrenSingleName vis NVar) snl in$/;"	v
so	cil/src/ext/pta/steensgaard.ml	/^	  let so : string option ref = ref None in$/;"	v
solve_constraints	cil/src/ext/pta/golf.mli	/^val solve_constraints : unit -> unit$/;"	v
solve_constraints	cil/src/ext/pta/olf.ml	/^let solve_constraints () = () (* only for compatability with Golf *)$/;"	v
solve_constraints	cil/src/ext/pta/olf.mli	/^val solve_constraints : unit -> unit (* only for compatability with Golf *)$/;"	v
solve_constraints	cil/src/ext/pta/steensgaard.ml	/^and solve_constraints () : unit = $/;"	v
solve_constraints	cil/src/ext/pta/steensgaard.mli	/^val solve_constraints : unit -> unit$/;"	v
solve_online	cil/src/ext/pta/steensgaard.mli	/^val solve_online : bool ref$/;"	v
spec_elem	cil/src/frontc/cabs.ml	/^and spec_elem =$/;"	t
specifier	cil/src/frontc/cabs.ml	/^and specifier = spec_elem list$/;"	t
splitFunctionType	cil/src/cil.ml	/^let splitFunctionType (ftype: typ) $/;"	v
splitFunctionType	cil/src/cil.mli	/^val splitFunctionType: $/;"	v
splitFunctionTypeVI	cil/src/cil.ml	/^let splitFunctionTypeVI (fvi: varinfo) $/;"	v
splitFunctionTypeVI	cil/src/cil.mli	/^val splitFunctionTypeVI: $/;"	v
splitNameForAlpha	cil/ocamlutil/alpha.ml	/^and splitNameForAlpha ~(lookupname: string) : (string * string * int) = $/;"	v
splitVarVisitor	cil/src/ext/simplify.ml	/^        let splitVarVisitor = new splitVarVisitorClass (Some fi) in    $/;"	v
splitVarVisitor	cil/src/ext/simplify.ml	/^        let splitVarVisitor = new splitVarVisitorClass None in    $/;"	v
splitVarVisitorClass	cil/src/ext/simplify.ml	/^class splitVarVisitorClass(func:fundec option) : cilVisitor = object (self)$/;"	c
split_offset_and_bitfield	cil/src/ext/sfi.ml	/^    let rec split_offset_and_bitfield lo = match lo with $/;"	v
sprint	cil/ocamlutil/pretty.ml	/^let sprint ~(width : int)  doc : string = $/;"	v
sprint	cil/ocamlutil/pretty.mli	/^val sprint: width:int -> doc -> string$/;"	v
sr	cil/src/ext/oneret.ml	/^      let sr = mkStmt (Return (rv, !lastloc)) in$/;"	v
stackOverflow	cil/src/ext/stackoverflow.ml	/^    let stackOverflow = $/;"	v
stack_	src/base/symbolic_interpreter.h	/^  vector<StackElem> stack_;$/;"	m	class:crest::SymbolicInterpreter
stackguard	cil/src/ext/heapify.ml	/^let stackguard (f : file) (push : exp) (pop : exp) $/;"	v
start	cil/src/cil.ml	/^          let start = addTrailing sofar.oaFirstFree ftypeAlign in    $/;"	v
start	cil/src/cil.ml	/^        let start, width = bitsOffset bt off in$/;"	v
start	cil/src/ext/ssa.mli	/^    start   : int;          $/;"	r	type:cfgInfo
start	cil/src/testcil.ml	/^            let start, width = bitsOffset t off in$/;"	v
startAcc	cil/src/cil.ml	/^      let startAcc = $/;"	v
startAlignDepth	cil/ocamlutil/pretty.ml	/^  let startAlignDepth = !alignDepth in$/;"	v
startEnv	cil/src/check.ml	/^let startEnv () = $/;"	v
startNodeAddrs	cil/src/ext/blockinggraph.ml	/^let startNodeAddrs =$/;"	v
startNodeAddrsArray	cil/src/ext/blockinggraph.ml	/^let startNodeAddrsArray =$/;"	v
startNodeStacks	cil/src/ext/blockinggraph.ml	/^let startNodeStacks =$/;"	v
startNodeStacksArray	cil/src/ext/blockinggraph.ml	/^let startNodeStacksArray =$/;"	v
startNodes	cil/src/ext/blockinggraph.ml	/^let startNodes : node list ref = ref []$/;"	v
startParsing	cil/ocamlutil/errormsg.ml	/^let startParsing ?(useBasename=true) (fname: string) = $/;"	v
startParsing	cil/ocamlutil/errormsg.mli	/^val startParsing:  ?useBasename:bool -> string -> $/;"	v
startParsingFromString	cil/ocamlutil/errormsg.mli	/^val startParsingFromString: ?file:string -> ?line:int -> string$/;"	v
startSuffix	cil/ocamlutil/alpha.ml	/^  let startSuffix = skipSuffix (len - 1) in$/;"	v
start_id	cil/src/ext/cfg.mli	/^val start_id: int ref$/;"	v
start_time_	src/run_crest/concolic_search.h	/^  time_t start_time_;$/;"	m	class:crest::Search
startsWith	cil/src/cil.ml	/^let startsWith (prefix: string) (s: string) : bool =$/;"	v
stat	cil/ocamlutil/stats.ml	/^  let stat : t = $/;"	v
state_id	src/base/symbolic_interpreter.h	/^	int state_id;$/;"	m	class:crest::SymbolicInterpreter
statement	cil/src/frontc/cabs.ml	/^and statement =$/;"	t
statements	cil/src/check.ml	/^let statements: stmt list ref = ref []$/;"	v
statements	cil/src/cil.ml	/^let statements : stmt list ref = ref [] $/;"	v
staticLocals	cil/src/frontc/cabs2cil.ml	/^let staticLocals: (string, varinfo) H.t = H.create 13$/;"	v
step_size_	src/run_crest/concolic_search.h	/^  int step_size_;$/;"	m	class:crest::HybridSearch
stmt	cil/obj/x86_LINUX/formatparse.mli	/^val stmt :$/;"	v
stmt	cil/src/cil.mli	/^and stmt = {$/;"	t
stmtCount	cil/src/ext/crestInstrument.ml	/^let stmtCount = Cfg.start_id$/;"	v
stmtStartData	cil/src/ext/predabst.ml	/^	let stmtStartData = IH.create 100$/;"	v
stmt_list	cil/obj/x86_LINUX/formatparse.mli	/^val stmt_list :$/;"	v
stmtaction	cil/src/ext/dataflow.mli	/^type 't stmtaction = $/;"	t
stmtkind	cil/src/cil.mli	/^and stmtkind = $/;"	t
stmts	cil/obj/x86_LINUX/formatparse.ml	/^                         let stmts = _2 mkTemp loc args in$/;"	v
sto_mod	cil/src/cil.ml	/^        let sto_mod, rest_attr = separateStorageModifiers comp.cattr in$/;"	v
stom	cil/src/cil.ml	/^    let stom, rest = List.partition isstoragemod al in$/;"	v
stom'	cil/src/cil.ml	/^      let stom' = $/;"	v
storage	cil/src/cil.mli	/^and storage = $/;"	t
storage	cil/src/frontc/cabs.ml	/^and storage =$/;"	t
str	cil/src/ext/logwrites.ml	/^        | _ -> let str = Pretty.sprint 80 $/;"	v
str1	cil/test/small1/init.c	/^struct str1 { int a[3]; int b;};$/;"	s	file:
str_H	cil/libstr/src/str.h	23;"	d
straight_compile	cil/lib/Cilly.pm	/^sub straight_compile {$/;"	s
straight_link	cil/lib/Cilly.pm	/^sub straight_link {$/;"	s
straight_linktolib	cil/lib/Cilly.pm	/^sub straight_linktolib {$/;"	s
straight_preprocess	cil/lib/Cilly.pm	/^sub straight_preprocess {$/;"	s
strange	cil/test/small1/init.c	/^char strange[] = { "several" };$/;"	v
strictChecking	cil/src/cilutil.ml	/^let strictChecking= ref false   (* If doCheck is true and warnings are found,$/;"	v
stringLiteralType	cil/src/cil.ml	/^let stringLiteralType = ref charPtrType$/;"	v
stringRegexp	cil/ocamlutil/util.ml	/^let stringRegexp = Str.regexp "\\"\\\\([^\\"]*\\\\)\\""$/;"	v
string_of_args	cil/src/ext/pta/steensgaard.ml	/^		      let rec string_of_args = function$/;"	v
string_of_c_absloc	cil/src/ext/pta/olf.ml	/^let string_of_c_absloc (l : c_absloc) : string =$/;"	v
string_of_configuration	cil/src/ext/pta/golf.ml	/^let string_of_configuration (c, i, i') =$/;"	v
string_of_cycle	cil/src/ext/pta/steensgaard.ml	/^  let rec string_of_cycle = function $/;"	v
string_of_lvalue	cil/src/ext/pta/golf.ml	/^let rec string_of_lvalue (lv : lvalue) : string =$/;"	v
string_of_lvalue	cil/src/ext/pta/golf.mli	/^val string_of_lvalue : lvalue -> string$/;"	v
string_of_lvalue	cil/src/ext/pta/olf.ml	/^let rec string_of_lvalue (lv : lvalue) : string =$/;"	v
string_of_lvalue	cil/src/ext/pta/olf.mli	/^val string_of_lvalue : lvalue -> string$/;"	v
string_of_lvalue	cil/src/ext/pta/steensgaard.ml	/^let rec string_of_lvalue (lv : lvalue) : string =$/;"	v
string_of_lvalue	cil/src/ext/pta/steensgaard.mli	/^val string_of_lvalue : lvalue -> string$/;"	v
string_of_polarity	cil/src/ext/pta/golf.ml	/^let string_of_polarity p =$/;"	v
string_of_polarity	cil/src/ext/pta/steensgaard.ml	/^let string_of_polarity p = $/;"	v
string_of_tau'	cil/src/ext/pta/golf.ml	/^  let rec string_of_tau' t =$/;"	v
string_of_tau'	cil/src/ext/pta/olf.ml	/^  let rec string_of_tau' t =$/;"	v
string_of_tau'	cil/src/ext/pta/steensgaard.ml	/^  let rec string_of_tau' t = $/;"	v
stripCasts	cil/src/cil.ml	/^let rec stripCasts (e: exp) = $/;"	v
stripCasts	cil/src/cil.mli	/^val stripCasts: exp -> exp$/;"	v
stripCastsDeepForPtrArith	cil/src/ext/expcompare.ml	/^let rec stripCastsDeepForPtrArith (e:exp): exp =$/;"	v
stripCastsForPtrArith	cil/src/ext/expcompare.ml	/^let rec stripCastsForPtrArith (e:exp): exp =$/;"	v
stripCastsForPtrArithLval	cil/src/ext/expcompare.ml	/^and stripCastsForPtrArithLval (lv : lval) : lval =$/;"	v
stripNopCasts	cil/src/ext/deadcodeelim.ml	/^let rec stripNopCasts (e:exp): exp =$/;"	v
strip_return	cil/libstr/src/strip_return.c	/^void strip_return (char *string_to_strip)$/;"	f
stronglyConnectedComponents	cil/src/ext/ssa.ml	/^let stronglyConnectedComponents (f: cfgInfo) (debug: bool): sccInfo = $/;"	v
stronglyConnectedComponents	cil/src/ext/ssa.mli	/^val stronglyConnectedComponents: cfgInfo -> bool -> sccInfo $/;"	v
su	cil/src/cil.ml	/^        let su = if comp.cstruct then "struct" else "union" in$/;"	v
su	cil/src/cil.ml	/^        let su, su1, su2 =$/;"	v
sub	cil/ocamlutil/stats.ml	/^           mutable sub  : t list}$/;"	r	type:t
subset	cil/src/ext/pta/setp.ml	/^    let rec subset s1 s2 =$/;"	v
substDefn	cil/src/frontc/patch.ml	/^and substDefn (bindings : binding list) (defn : definition) : definition =$/;"	v
substitutor	cil/src/frontc/patch.ml	/^class substitutor (bindings : binding list) = object(self)$/;"	c
success_ex_	src/run_crest/concolic_search.h	/^  SymbolicExecution success_ex_;$/;"	m	class:crest::CfgBaselineSearch
success_ex_	src/run_crest/concolic_search.h	/^  SymbolicExecution success_ex_;$/;"	m	class:crest::CfgHeuristicSearch
successors	cil/src/ext/ssa.ml	/^  let successors = Array.make nrScc [] in$/;"	v
successors	cil/src/ext/ssa.ml	/^ let successors = Array.init size (fun i -> List.filter (fun s -> reachable.(s)) f.successors.(i)) in$/;"	v
successors	cil/src/ext/ssa.mli	/^    successors: int list array; (* block indices *)$/;"	r	type:cfgInfo
succpred_stmt	cil/src/cil.ml	/^and succpred_stmt s fallthrough = $/;"	v
succs	cil/src/cil.mli	/^    mutable succs: stmt list;          $/;"	r	type:stmt
succsToReach	cil/src/ext/dataflow.ml	/^          let succsToReach = match s.skind with$/;"	v
suffixlen	cil/src/cil.ml	/^  let suffixlen, kinds = $/;"	v
suppress	cil/src/cil.ml	/^        let suppress =$/;"	v
svar	cil/src/cil.mli	/^    { mutable svar:     varinfo;        $/;"	r	type:fundec
svc	cil/Makefile	/^	echo "let msvc = {" >>$@$/;"	m
switch_count	cil/src/cil.ml	/^let switch_count = ref (-1) $/;"	v
switch_label	cil/src/cil.ml	/^let switch_label = ref (-1)$/;"	v
sy	cil/src/ext/ssa.ml	/^	  let sy = sccId.(y) in$/;"	v
symbol	cil/ocamlutil/util.ml	/^type symbol = int$/;"	t
symbolName	cil/ocamlutil/util.ml	/^let symbolName (id: symbol) : string = $/;"	v
symbolNames	cil/ocamlutil/util.ml	/^let symbolNames: string IH.t = IH.create 113 $/;"	v
symbolRangeNaming	cil/ocamlutil/util.ml	/^let symbolRangeNaming: (int * int * (int -> string)) list ref = ref []$/;"	v
symbolic_banana	test/structure_return.c	/^struct banana symbolic_banana() {$/;"	f
sz	cil/src/ext/ssa.ml	/^	  let sz = sccId.(z) in$/;"	v
t	cil/obj/x86_LINUX/formatparse.ml	/^                              let t = (fst _2) args in$/;"	v
t	cil/ocamlutil/growArray.mli	/^type 'a t$/;"	t
t	cil/ocamlutil/inthash.ml	/^type 'a t =$/;"	t
t	cil/ocamlutil/inthash.mli	/^type 'a t$/;"	t
t	cil/ocamlutil/intmap.ml	/^type 'a t =$/;"	t
t	cil/ocamlutil/intmap.mli	/^type (+'a) t$/;"	t
t	cil/ocamlutil/longarray.mli	/^type 'a t$/;"	t
t	cil/ocamlutil/stats.ml	/^type t = { name : string;$/;"	t
t	cil/ocamlutil/util.mli	/^  type 'a t$/;"	t	Module:STACK
t	cil/src/check.ml	/^          let t = checkExp true l in$/;"	v
t	cil/src/ext/bitmap.ml	/^type t = { mutable nrWords  : int;$/;"	t
t	cil/src/ext/bitmap.mli	/^type t$/;"	t
t	cil/src/ext/dataslicing.ml	/^      let t = typeOfLval lv in$/;"	v
t	cil/src/ext/heap.ml	/^type ('a) t = {$/;"	t
t	cil/src/ext/partial.ml	/^  type t = reg IntMap.t$/;"	t
t'	cil/obj/x86_LINUX/formatparse.ml	/^                              let t', e' = $/;"	v
t'	cil/src/cil.ml	/^        let t' = fTyp t in$/;"	v
t'	cil/src/cil.ml	/^      let e1' = vExp e1 in let e2' = vExp e2 in let t' = vTyp t in$/;"	v
t'	cil/src/cil.ml	/^      let e1' = vExp e1 in let t' = vTyp t in$/;"	v
t'	cil/src/cil.ml	/^      let t' = vTyp t in let e1' = vExp e1 in$/;"	v
t'	cil/src/cil.ml	/^      let t' = vTyp t in$/;"	v
t'	cil/src/ext/dataslicing.ml	/^    let t' =$/;"	v
t'	cil/src/ext/pta/steensgaard.ml	/^      let t' = fresh_var_i () in$/;"	v
t1	cil/obj/x86_LINUX/formatparse.ml	/^                               let t1 = typeOf e1 in$/;"	v
t1	cil/src/check.ml	/^          let t1 = checkExp isconst e1 in$/;"	v
t2	cil/src/check.ml	/^          let t2 = checkExp isconst e2 in$/;"	v
tEq	cil/src/mergecil.ml	/^let tEq: (int * string, typeinfo node) H.t = H.create 111 (* Type names*)$/;"	v
tSyn	cil/src/mergecil.ml	/^let tSyn: (string, typeinfo node) H.t = H.create 111$/;"	v
takenref	cil/ocamlutil/pretty.ml	/^      let takenref = ref false in$/;"	v
tal	cil/obj/x86_LINUX/formatparse.ml	/^                        let tal = (fst _2) args in$/;"	v
tal	cil/obj/x86_LINUX/formatparse.ml	/^                     let tal = (fst _2) args in$/;"	v
tau	cil/src/ext/pta/golf.mli	/^type tau$/;"	t
tau	cil/src/ext/pta/olf.mli	/^type tau$/;"	t
tau	cil/src/ext/pta/steensgaard.mli	/^type tau$/;"	t
tauPointsTo	cil/src/ext/pta/golf.ml	/^let rec tauPointsTo (l : tau) : absloc list =$/;"	v
te	cil/src/check.ml	/^          let te = checkExp false e in$/;"	v
te	cil/src/check.ml	/^          let te = checkExp false e' in$/;"	v
te	cil/src/check.ml	/^          let te = checkExp isconst e in$/;"	v
telem	cil/src/ext/simplify.ml	/^        let telem = match unrollType t with $/;"	v
term	cil/src/cil.ml	/^          let term, bodystmts =$/;"	v
terms	src/base/symbolic_expression.h	/^  const map<var_t,value_t>& terms() const { return coeff_; }$/;"	f	class:crest::SymbolicExpr
test	cil/src/ext/deadcodeelim.ml	/^    let test (i,(_,s,iosh)) =$/;"	v
test	cil/src/formatcil.ml	/^let test () = $/;"	v
test	cil/src/formatcil.mli	/^val test: unit -> unit$/;"	v
testcil	cil/src/cilutil.ml	/^let testcil = ref ""$/;"	v
testf	cil/test/small1/func.c	/^int testf(int k) {$/;"	f
text	cil/ocamlutil/pretty.ml	/^let text s        = breakString nil s$/;"	v
text	cil/ocamlutil/pretty.mli	/^val text         : string -> doc$/;"	v	function:++
tgt'	cil/src/frontc/patch.ml	/^  let tgt' = (List.stable_sort compare tgt) in$/;"	v
theFile	cil/src/frontc/cabs2cil.ml	/^let theFile : global list ref = ref []$/;"	v
theFile	cil/src/mergecil.ml	/^let theFile      = ref []$/;"	v
theFileTypes	cil/src/frontc/cabs2cil.ml	/^let theFileTypes : global list ref = ref []$/;"	v
theFileTypes	cil/src/mergecil.ml	/^let theFileTypes = ref []$/;"	v
theGain	cil/ocamlutil/pretty.ml	/^          let theGain = breakingAlign.gainBreak in$/;"	v
theLexbuf	cil/ocamlutil/errormsg.ml	/^let theLexbuf = ref (Lexing.from_string "")$/;"	v
theMain	cil/src/main.ml	/^let theMain () =$/;"	v
thefunc	cil/src/ext/simplemem.ml	/^let thefunc = ref None $/;"	v
thenewone	cil/src/cil.ml	/^  let thenewone = ref fdec.svar in (* Just a placeholder *)$/;"	v
theseGlobals	cil/src/mergecil.ml	/^    let theseGlobals : global list ref = ref [] in$/;"	v
this	cil/obj/x86_LINUX/formatparse.ml	/^                                      let this = (fst _1) args in$/;"	v
this	cil/obj/x86_LINUX/formatparse.ml	/^                        let this = (fst _1) args in$/;"	v
this	cil/obj/x86_LINUX/formatparse.ml	/^                      let this = (fst _1) loc args in$/;"	v
this	cil/obj/x86_LINUX/formatparse.ml	/^                      let this = _1 mkTemp loc args in$/;"	v
this_stmt	cil/src/cil.ml	/^          let this_stmt = mkStmt $/;"	v
ti	cil/src/mergecil.ml	/^    let ti = tnode.ndata in$/;"	v
time	cil/ocamlutil/stats.ml	/^           mutable time : float; (* In seconds *)$/;"	r	type:t
time	cil/ocamlutil/stats.ml	/^let time str f arg =$/;"	v
time	cil/ocamlutil/stats.mli	/^val time : string -> ('a -> 'b) -> 'a -> 'b $/;"	v
time	cil/src/ext/deadcodeelim.ml	/^let time s f a =$/;"	v
timerMode	cil/ocamlutil/stats.ml	/^let timerMode = ref Disabled$/;"	v
timerModeEnum	cil/ocamlutil/stats.ml	/^type timerModeEnum =$/;"	t
timerModeEnum	cil/ocamlutil/stats.mli	/^type timerModeEnum =$/;"	t
times	cil/src/formatcil.ml	/^  let times = 100000 in$/;"	v
timethis	cil/ocamlutil/stats.ml	/^let timethis (f: 'a -> 'b) (arg: 'a) : 'b = $/;"	v
timethis	cil/ocamlutil/stats.mli	/^val timethis: ('a -> 'b) -> 'a -> 'b$/;"	v
tlv	cil/src/check.ml	/^          let tlv = checkLval isconst true lv in$/;"	v
tname	cil/src/cil.mli	/^    mutable tname: string;              $/;"	r	type:typeinfo
tnode	cil/src/mergecil.ml	/^  let    tnode = getNode tEq tSyn    fidx ti.tname    ti None in$/;"	v
toInt	cil/src/cil.ml	/^  let rec toInt (base: int64) (acc: int64) (idx: int) : int64 = $/;"	v
toList	cil/ocamlutil/clist.ml	/^let toList l = listifyOnto [] l$/;"	v
toList	cil/ocamlutil/clist.mli	/^val toList: 'a clist -> 'a list$/;"	v
toList	cil/src/ext/bitmap.mli	/^val  toList : t -> int list$/;"	v
toc1	cil/doc/cil002.html	/^platform, please send us a patch.<\/P><H3 CLASS="subsection"><A NAME="toc1"><\/A><A NAME="htoc3">2.1<\/A>&#XA0;&#XA0;Building CIL on Windows with Microsoft Visual C<\/H3><P>Some users might want to build a standalone CIL executable on Windows (an$/;"	a
toc10	cil/doc/cil007.html	/^<TT>src\/ext\/simplemem.ml<\/TT>. <P>For an up-to-date list of available options, run <TT>cilly.asm --help<\/TT>. <\/P><\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc10"><\/A><A NAME="htoc18">7.3<\/A>&#XA0;&#XA0;Internal Options<\/H3><P>$/;"	a
toc11	cil/doc/ext.html	/^(<A HREF="..\/ccured\/index.html"><TT>..\/ccured\/index.html<\/TT><\/A>).<\/P><H3 CLASS="subsection"><A NAME="toc11"><\/A><A NAME="htoc20">8.1<\/A>&#XA0;&#XA0;Control-Flow Graphs<\/H3><P> <A NAME="sec-cfg"><\/A><\/P><P>The <A HREF="api\/Cil.html#TYPEstmt">Cil.stmt<\/A> datatype includes fields for intraprocedural$/;"	a
toc12	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc12"><\/A><A NAME="htoc23">8.2<\/A>&#XA0;&#XA0;Data flow analysis framework<\/H3><P>The <A HREF="api\/Dataflow.html">Dataflow<\/A> module (click for the ocamldoc) contains a$/;"	a
toc13	cil/doc/ext.html	/^before invoking the Dataflow module.<\/P><H3 CLASS="subsection"><A NAME="toc13"><\/A><A NAME="htoc24">8.3<\/A>&#XA0;&#XA0;Dominators<\/H3><P>The module <A HREF="api\/Dominators.html">Dominators<\/A> contains the computation of immediate$/;"	a
toc14	cil/doc/ext.html	/^dominators. It uses the <A HREF="api\/Dataflow.html">Dataflow<\/A> module. <\/P><H3 CLASS="subsection"><A NAME="toc14"><\/A><A NAME="htoc25">8.4<\/A>&#XA0;&#XA0;Points-to Analysis<\/H3><P>The module <TT>ptranal.ml<\/TT> contains two interprocedural points-to$/;"	a
toc15	cil/doc/ext.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc15"><\/A><A NAME="htoc26">8.5<\/A>&#XA0;&#XA0;StackGuard<\/H3><P>The module <TT>heapify.ml<\/TT> contains a transformation similar to the one$/;"	a
toc16	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc16"><\/A><A NAME="htoc27">8.6<\/A>&#XA0;&#XA0;Heapify<\/H3><P>The module <TT>heapify.ml<\/TT> also contains a transformation that moves all$/;"	a
toc17	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc17"><\/A><A NAME="htoc28">8.7<\/A>&#XA0;&#XA0;One Return<\/H3><P>The module <TT>oneret.ml<\/TT> contains a transformation the ensures that all$/;"	a
toc18	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc18"><\/A><A NAME="htoc29">8.8<\/A>&#XA0;&#XA0;Partial Evaluation and Constant Folding<\/H3><P>The <TT>partial.ml<\/TT> module provides a simple interprocedural partial$/;"	a
toc19	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc19"><\/A><A NAME="htoc30">8.9<\/A>&#XA0;&#XA0;Reaching Definitions<\/H3><P>The <TT>reachingdefs.ml<\/TT> module uses the dataflow framework and CFG$/;"	a
toc2	cil/doc/cilly.html	/^library. We highly recommend that you use <TT>cilly<\/TT>, our driver. <\/P><H3 CLASS="subsection"><A NAME="toc2"><\/A><A NAME="htoc7">5.1<\/A>&#XA0;&#XA0;Using <TT>cilly<\/TT>, the CIL driver<\/H3><P>The most common way to use CIL is to write an Ocaml module containing your$/;"	a
toc20	cil/doc/ext.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc20"><\/A><A NAME="htoc31">8.10<\/A>&#XA0;&#XA0;Available Expressions<\/H3><P>The <TT>availexps.ml<\/TT> module uses the dataflow framework and CFG$/;"	a
toc21	cil/doc/ext.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc21"><\/A><A NAME="htoc32">8.11<\/A>&#XA0;&#XA0;Liveness Analysis<\/H3><P>The <TT>liveness.ml<\/TT> module uses the dataflow framework and$/;"	a
toc22	cil/doc/ext.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc22"><\/A><A NAME="htoc33">8.12<\/A>&#XA0;&#XA0;Dead Code Elimination<\/H3><P>The module <TT>deadcodeelim.ml<\/TT> uses the reaching definitions$/;"	a
toc23	cil/doc/ext.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc23"><\/A><A NAME="htoc34">8.13<\/A>&#XA0;&#XA0;Simple Memory Operations<\/H3><P>The <TT>simplemem.ml<\/TT> module allows CIL lvalues that contain memory$/;"	a
toc24	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc24"><\/A><A NAME="htoc35">8.14<\/A>&#XA0;&#XA0;Simple Three-Address Code<\/H3><P>The <TT>simplify.ml<\/TT> module further reduces the complexity of program$/;"	a
toc25	cil/doc/ext.html	/^code fragment<\/P><H3 CLASS="subsection"><A NAME="toc25"><\/A><A NAME="htoc36">8.15<\/A>&#XA0;&#XA0;Converting C to C++<\/H3><P>The module canonicalize.ml performs several transformations to correct$/;"	a
toc26	cil/doc/cil016.html	/^use CIL and let CIL translate them into clean C code. <\/P><H3 CLASS="subsection"><A NAME="toc26"><\/A><A NAME="htoc45">16.1<\/A>&#XA0;&#XA0;Standard C<\/H3><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Why does the following code return 0 for most values of <TT>x<\/TT>? (This$/;"	a
toc27	cil/doc/cil016.html	/^is 0. <\/P><\/LI><\/OL><H3 CLASS="subsection"><A NAME="toc27"><\/A><A NAME="htoc46">16.2<\/A>&#XA0;&#XA0;GCC ugliness<\/H3><P><A NAME="sec-ugly-gcc"><\/A><\/P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">GCC has generalized lvalues. You can take the address of a lot of$/;"	a
toc28	cil/doc/cil016.html	/^code fragment<\/LI><\/OL><H3 CLASS="subsection"><A NAME="toc28"><\/A><A NAME="htoc47">16.3<\/A>&#XA0;&#XA0;Microsoft VC ugliness<\/H3><P>This compiler has few extensions, so there is not much to say here.<\/P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">$/;"	a
toc3	cil/doc/cilly.html	/^<TT>--dologwrites<\/TT>). <\/LI><\/OL><H3 CLASS="subsection"><A NAME="toc3"><\/A><A NAME="htoc8">5.2<\/A>&#XA0;&#XA0;Using CIL as a library<\/H3><P>CIL can also be built as a library that is called from your stand-alone$/;"	a
toc4	cil/doc/attributes.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc4"><\/A><A NAME="htoc10">6.1<\/A>&#XA0;&#XA0;Using the visitor<\/H3><P><A NAME="sec-visitor"><\/A><\/P><P>One of the most useful tools exported by the CIL API is an implementation of$/;"	a
toc5	cil/doc/attributes.html	/^should not normally be called by the user. <\/P><H3 CLASS="subsection"><A NAME="toc5"><\/A><A NAME="htoc11">6.2<\/A>&#XA0;&#XA0;Interpreted Constructors and Deconstructors<\/H3><P>Interpreted constructors and deconstructors are a facility for constructing$/;"	a
toc6	cil/doc/attributes.html	/^when performance is not paramount (e.g. prototyping).<\/P><H3 CLASS="subsection"><A NAME="toc6"><\/A><A NAME="htoc13">6.3<\/A>&#XA0;&#XA0;Printing and Debugging support<\/H3><P>The Modules <A HREF="api\/Pretty.html">Pretty<\/A> and <A HREF="api\/Errormsg.html">Errormsg<\/A> contain respectively$/;"	a
toc7	cil/doc/attributes.html	/^is run after each transformation. <\/P><H3 CLASS="subsection"><A NAME="toc7"><\/A><A NAME="htoc14">6.4<\/A>&#XA0;&#XA0;Attributes<\/H3><P><A NAME="sec-attrib"><\/A><\/P><P>In CIL you can attach attributes to types and to names (variables, functions$/;"	a
toc8	cil/doc/cil007.html	/^Section&#XA0;<A HREF="patcher.html#sec-patcher">14<\/A>).<\/P><H3 CLASS="subsection"><A NAME="toc8"><\/A><A NAME="htoc16">7.1<\/A>&#XA0;&#XA0;<TT>cilly<\/TT> Options<\/H3><P>Among the options for the <TT>cilly<\/TT> you can put anything that can normally$/;"	a
toc9	cil/doc/cil007.html	/^<\/LI><\/UL><H3 CLASS="subsection"><A NAME="toc9"><\/A><A NAME="htoc17">7.2<\/A>&#XA0;&#XA0;<TT>cilly.asm<\/TT> Options<\/H3><P>$/;"	a
token	cil/obj/x86_LINUX/cparser.ml	/^type token =$/;"	t
token	cil/obj/x86_LINUX/cparser.mli	/^type token =$/;"	t
token	cil/obj/x86_LINUX/formatparse.ml	/^type token =$/;"	t
token	cil/obj/x86_LINUX/formatparse.mli	/^type token =$/;"	t
tokenmap	cil/src/frontc/whitetrack.ml	/^let tokenmap : ((string * int),int) Hashtbl.t = Hashtbl.create 1000$/;"	v
tokens	cil/src/frontc/whitetrack.ml	/^let tokens = GrowArray.make 0 (GrowArray.Elem  ("",""))$/;"	v
tolist	cil/ocamlutil/inthash.ml	/^let tolist (h: 'a t) : (int * 'a) list = $/;"	v
tolist	cil/ocamlutil/inthash.mli	/^val tolist: 'a t -> (int * 'a) list$/;"	v
top	cil/ocamlutil/stats.ml	/^let top = { name = "TOTAL";$/;"	v
top	cil/ocamlutil/util.mli	/^  val top : 'a t -> 'a$/;"	v	Module:STACK
top_c_absloc	cil/src/ext/pta/olf.ml	/^let top_c_absloc l =$/;"	v
top_tau	cil/src/ext/pta/olf.ml	/^let rec top_tau (t : tau) =$/;"	v
topalign	cil/ocamlutil/pretty.ml	/^          let topalign = List.hd !aligns in$/;"	v
topalign	cil/ocamlutil/pretty.ml	/^      let topalign = List.hd !aligns in (* aligns is never empty *)$/;"	v
total_covered_	src/run_crest/concolic_search.h	/^  vector<bool> total_covered_;$/;"	m	class:crest::Search
total_num_covered_	src/run_crest/concolic_search.h	/^  unsigned int total_num_covered_;$/;"	m	class:crest::Search
trace	cil/ocamlutil/trace.ml	/^let trace$/;"	v
trace	cil/ocamlutil/trace.mli	/^val trace : string -> Pretty.doc -> unit$/;"	v
traceActive	cil/ocamlutil/trace.mli	/^val traceActive : string -> bool$/;"	v
traceAddMulti	cil/ocamlutil/trace.ml	/^let traceAddMulti (systems : string) : unit =$/;"	v
traceAddMulti	cil/ocamlutil/trace.mli	/^val traceAddMulti : string -> unit$/;"	v
traceAddSys	cil/ocamlutil/trace.mli	/^val traceAddSys : string -> unit$/;"	v
traceIndent	cil/ocamlutil/trace.mli	/^val traceIndent : string -> unit$/;"	v
traceIndentLevel	cil/ocamlutil/trace.ml	/^let traceIndentLevel : int ref = ref 0;;$/;"	v
traceIndentLevel	cil/ocamlutil/trace.mli	/^val traceIndentLevel : int ref$/;"	v
traceNonRoot	cil/src/rmtmps.ml	/^let traceNonRoot reason global =$/;"	v
traceOutdent	cil/ocamlutil/trace.mli	/^val traceOutdent : string -> unit$/;"	v
traceRoot	cil/src/rmtmps.ml	/^let traceRoot reason global =$/;"	v
traceSubsystems	cil/ocamlutil/trace.ml	/^let traceSubsystems : string list ref = ref [];;$/;"	v
traceSubsystems	cil/ocamlutil/trace.mli	/^val traceSubsystems : string list ref$/;"	v
traceTag	cil/ocamlutil/trace.ml	/^let traceTag (sys : string) : Pretty.doc =$/;"	v
tracei	cil/ocamlutil/trace.ml	/^let tracei (sys : string) (d : Pretty.doc) : unit =$/;"	v
tracei	cil/ocamlutil/trace.mli	/^val tracei : string -> Pretty.doc -> unit$/;"	v
traceu	cil/ocamlutil/trace.ml	/^let traceu (sys : string) (d : Pretty.doc) : unit =$/;"	v
traceu	cil/ocamlutil/trace.mli	/^val traceu : string -> Pretty.doc -> unit$/;"	v
transformOffsetOf	cil/obj/x86_LINUX/cparser.ml	/^let transformOffsetOf (speclist, dtype) member =$/;"	v
transparentUnionArgs	cil/src/frontc/cabs2cil.ml	/^let transparentUnionArgs : (int * typ) list ref = ref []$/;"	v
traverse_expr	cil/src/ext/pta/ptranal.ml	/^let rec traverse_expr (e : exp) : A.tau =$/;"	v
trd3	cil/obj/x86_LINUX/cparser.ml	/^let trd3 (_, _, result) = result$/;"	v
tree	cil/src/ext/dominators.ml	/^type tree = stmt option * BS.t IH.t$/;"	t
tree	cil/src/ext/dominators.mli	/^type tree$/;"	t
treeData	cil/src/ext/dominators.ml	/^  let treeData: BS.t IH.t = IH.create 64 in$/;"	v
treferenced	cil/src/cil.mli	/^    mutable treferenced: bool;         $/;"	r	type:typeinfo
tres	cil/src/ext/simplify.ml	/^  let tres = TPtr(typeOfLval lv, []) in$/;"	v
trimSpaces	cil/bin/patcher	/^sub trimSpaces {$/;"	s
truncate	cil/src/ext/pta/steensgaard.ml	/^let truncate l elt = $/;"	v
truncated	cil/src/cil.ml	/^    let truncated =$/;"	v
tryAgain	cil/ocamlutil/pretty.ml	/^  let rec tryAgain abscol = $/;"	v
tryFinally	cil/ocamlutil/util.ml	/^let tryFinally $/;"	v
tryFinally	cil/ocamlutil/util.mli	/^val tryFinally: $/;"	v
tryfind	cil/ocamlutil/inthash.ml	/^let tryfind h key =$/;"	v
tryfind	cil/ocamlutil/inthash.mli	/^val tryfind: 'a t -> int -> 'a option$/;"	v
trylink	cil/src/cil.ml	/^let trylink source dest_option = match dest_option with$/;"	v
ts	cil/obj/x86_LINUX/formatparse.ml	/^                        let ts = (fst _1) tal args in$/;"	v
ts	cil/obj/x86_LINUX/formatparse.ml	/^                     let ts  = (fst _1) tal args in$/;"	v
ts	cil/src/ext/dataslicing.ml	/^  let ts = typeSig t in$/;"	v
ttype	cil/src/cil.mli	/^    mutable ttype: typ;$/;"	r	type:typeinfo
typ	cil/src/cil.mli	/^and typ =$/;"	t
typ_vol	cil/src/ext/ciltools.ml	/^  let typ_vol = is_volatile_tp vi.vtype in$/;"	v
typeAddAttributes	cil/src/cil.mli	/^val typeAddAttributes: attribute list -> typ -> typ$/;"	v
typeAttrs	cil/src/cil.mli	/^val typeAttrs: typ -> attribute list$/;"	v
typeForCast	cil/src/ext/simplify.ml	/^  let typeForCast restOff: typ =$/;"	v
typeForCombinedArg	cil/src/frontc/cabs2cil.mli	/^val typeForCombinedArg: ((string, string) Hashtbl.t -> Cil.typ -> Cil.typ) ref$/;"	v
typeForInsertedCast	cil/src/frontc/cabs2cil.mli	/^val typeForInsertedCast: (Cil.typ -> Cil.typ) ref$/;"	v
typeForInsertedVar	cil/src/frontc/cabs2cil.mli	/^val typeForInsertedVar: (Cil.typ -> Cil.typ) ref$/;"	v
typeOf	cil/src/cil.mli	/^val typeOf: exp -> typ$/;"	v
typeOfDest	cil/src/ext/canonicalize.ml	/^	let typeOfDest = typeOfLval dest in$/;"	v
typeOfLval	cil/src/cil.mli	/^val typeOfLval: lval -> typ$/;"	v
typeOfSizeOf	cil/src/cil.ml	/^let typeOfSizeOf = ref voidType$/;"	v
typeOfSizeOf	cil/src/cil.mli	/^val typeOfSizeOf: typ ref$/;"	v
typeOffset	cil/src/cil.mli	/^val typeOffset: typ -> offset -> typ $/;"	v
typeRemoveAttributes	cil/src/cil.ml	/^let typeRemoveAttributes (anl: string list) t = $/;"	v
typeRemoveAttributes	cil/src/cil.mli	/^val typeRemoveAttributes: string list -> typ -> typ$/;"	v
typeSig	cil/src/cil.ml	/^let typeSig t = $/;"	v
typeSig	cil/src/cil.mli	/^val typeSig: typ -> typsig$/;"	v
typeSigAddAttrs	cil/src/cil.ml	/^let typeSigAddAttrs a0 t = $/;"	v
typeSigAttrs	cil/src/cil.ml	/^let typeSigAttrs = function$/;"	v
typeSigAttrs	cil/src/cil.mli	/^val typeSigAttrs: typsig -> attributes$/;"	v
typeSigWithAttrs	cil/src/cil.mli	/^val typeSigWithAttrs: ?ignoreSign:bool -> (attributes -> attributes) -> typ -> typsig$/;"	v
typeSpecifier	cil/src/frontc/cabs.ml	/^type typeSpecifier = (* Merge all specifiers into one type *)$/;"	t
type_t	src/base/basic_types.h	/^enum type_t { U_CHAR = 0,       CHAR = 1,$/;"	g	namespace:crest::types
typedec	cil/src/ext/heapify.ml	/^	let typedec = (GCompTag(ci,funloc)) in (* declare the big struct *)$/;"	v
typedefs	cil/src/frontc/cabs2cil.ml	/^let typedefs: (string, typeinfo) H.t = H.create 13$/;"	v
typeinfo	cil/src/cil.mli	/^and typeinfo = {$/;"	t
typename	cil/obj/x86_LINUX/formatparse.mli	/^val typename :$/;"	v
types	src/base/basic_types.h	/^namespace types {$/;"	n	namespace:crest
typsig	cil/src/cil.mli	/^and typsig = $/;"	t
u	cil/src/ext/deadcodeelim.ml	/^	  let u = UD.computeUseExp e in$/;"	v
u	cil/src/ext/deadcodeelim.ml	/^	let u,d = UD.computeUseDefInstr i in$/;"	v
u	cil/src/ext/ssa.ml	/^      let u = eval v in$/;"	v
u1	cil/test/small1/init.c	/^  } u1;$/;"	m	union:__anon4	typeref:struct:__anon4::__anon5	file:
uarray	cil/test/small1/init.c	/^} uarray[] = { 1, 0, 2, 0, 3, 0 };$/;"	v	typeref:union:__anon4
ucharPtrType	cil/src/testcil.ml	/^            let ucharPtrType = TPtr(TInt(IUChar, []), []) in$/;"	v
ue	cil/src/frontc/patch.ml	/^  let ue = unifyExpr in$/;"	v
uintPtrType	cil/src/cil.ml	/^let uintPtrType = TPtr(uintType, [])$/;"	v
uintPtrType	cil/src/cil.mli	/^val uintPtrType: typ$/;"	v
uintType	cil/src/cil.ml	/^let uintType = TInt(IUInt,[])$/;"	v
uintType	cil/src/cil.mli	/^val uintType: typ$/;"	v
ulongLongType	cil/src/cil.ml	/^  let ulongLongType = TInt(IULongLong, []) in$/;"	v
ulongType	cil/src/cil.ml	/^let ulongType = TInt(IULong,[])$/;"	v
ulongType	cil/src/cil.mli	/^val ulongType: typ$/;"	v
unalign	cil/ocamlutil/pretty.ml	/^let unalign       = Unalign$/;"	v
unalign	cil/ocamlutil/pretty.mli	/^val unalign: doc$/;"	v	function:++
unary_op_t	src/base/basic_types.h	/^enum unary_op_t { NEGATE, LOGICAL_NOT, BITWISE_NOT };$/;"	g	namespace:crest::ops
unary_operator	cil/src/frontc/cabs.ml	/^and unary_operator =$/;"	t
unassign	cil/src/ext/partial.ml	/^  let unassign r l =$/;"	v
unbox_int_exp	cil/src/ext/ciltools.ml	/^let unbox_int_exp (e : exp) : int64 = $/;"	v
unbox_int_type	cil/src/ext/ciltools.ml	/^let unbox_int_type (ye : typ) : (int * sign) =$/;"	v
underscore_name	cil/Makefile	/^	echo "	 underscore_name = false ;" >> $@$/;"	m
underscore_name	cil/Makefile	/^	echo "	 underscore_name = true ;" >> $@$/;"	m
underscore_name	cil/obj/x86_LINUX/machdep.ml	/^  underscore_name: bool;  (* If assembly names have leading underscore *)$/;"	r	type:mach
undoAlphaChanges	cil/ocamlutil/alpha.ml	/^let undoAlphaChanges ~(alphaTable: (string, 'a alphaTableData ref) H.t) $/;"	v
undoAlphaChanges	cil/ocamlutil/alpha.mli	/^val undoAlphaChanges: alphaTable:(string, 'a alphaTableData ref) Hashtbl.t -> $/;"	v
undoAlphaElement	cil/ocamlutil/alpha.mli	/^type 'a undoAlphaElement$/;"	t
undoReadIncludeLine	cil/bin/patcher	/^sub undoReadIncludeLine {$/;"	s
undoRenameOne	cil/src/mergecil.ml	/^              let undoRenameOne (v: varinfo) = $/;"	v
undolist	cil/src/cil.ml	/^          let undolist = ref [] in$/;"	v
unify	cil/src/ext/pta/uref.ml	/^let unify f (p,q) = $/;"	v
unify	cil/src/ext/pta/uref.mli	/^val unify: ('a * 'a -> 'a) -> 'a uref * 'a uref -> unit$/;"	v
unifyDeclType	cil/src/frontc/patch.ml	/^and unifyDeclType (pat : decl_type) (tgt : decl_type) : binding list =$/;"	v
unifyDeclarators	cil/src/frontc/patch.ml	/^and unifyDeclarators (pat : name list) (tgt : name list) : binding list =$/;"	v
unifyDefn	cil/src/frontc/patch.ml	/^and unifyDefn (pat : definition) (tgt : definition) : binding list =$/;"	v
unifyExpr	cil/src/frontc/patch.ml	/^and unifyExpr (pat : expression) (tgt : expression) : binding list =$/;"	v
unifyExprFwd	cil/src/frontc/patch.ml	/^let unifyExprFwd : (expression -> expression -> binding list) ref$/;"	v
unifyExprs	cil/src/frontc/patch.ml	/^and unifyExprs (pat : expression list) (tgt : expression list) : binding list =$/;"	v
unifyField	cil/src/frontc/patch.ml	/^and unifyField (pat : field_group) (tgt : field_group) : binding list =$/;"	v
unifyInitExpr	cil/src/frontc/patch.ml	/^and unifyInitExpr (pat : init_expression) (tgt : init_expression) : binding list =$/;"	v
unifyList	cil/src/frontc/patch.ml	/^let unifyList (pat : 'a list) (tgt : 'a list)$/;"	v
unifySingleNames	cil/src/frontc/patch.ml	/^and unifySingleNames (pat : single_name list) (tgt : single_name list) : binding list =$/;"	v
unifySpecifiers	cil/src/frontc/patch.ml	/^and unifySpecifiers (pat : spec_elem list) (tgt : spec_elem list) : binding list =$/;"	v
unifyString	cil/src/frontc/patch.ml	/^and unifyString (pat : string) (tgt : string) : binding list =$/;"	v
unifyTypeSpecifier	cil/src/frontc/patch.ml	/^and unifyTypeSpecifier (pat: typeSpecifier) (tgt: typeSpecifier) : binding list =$/;"	v
unify_fun	cil/src/ext/pta/steensgaard.ml	/^and unify_fun (li,li' : finfo * finfo) : unit = $/;"	v
unify_int	cil/src/ext/pta/golf.ml	/^let rec unify_int (t, t' : tau * tau) : unit =$/;"	v
unify_int	cil/src/ext/pta/steensgaard.ml	/^and unify_int (t,t' : tau * tau) : unit = $/;"	v
unify_label	cil/src/ext/pta/steensgaard.ml	/^and unify_label (l,l' : label * label) : unit =$/;"	v
unify_ref	cil/src/ext/pta/steensgaard.ml	/^and unify_ref (ri,ri' : rinfo * rinfo) : unit =$/;"	v
unimp	cil/ocamlutil/errormsg.ml	/^let unimp (fmt : ('a,unit,doc,unit) format4) : 'a = $/;"	v
unimp	cil/ocamlutil/errormsg.mli	/^val unimp:         ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
unimp	cil/src/cil.ml	/^let unimp (fmt : ('a,unit,doc) format) : 'a = $/;"	v
uninteresting	cil/src/rmtmps.ml	/^let uninteresting =$/;"	v
union	cil/src/ext/bitmap.mli	/^val  union  : t -> t -> bool$/;"	v
union	cil/src/ext/pta/setp.ml	/^    let rec union s1 s2 =$/;"	v
union	cil/src/ext/pta/uref.ml	/^let union (p,q) = $/;"	v
union	cil/src/ext/pta/uref.mli	/^val union: 'a uref * 'a uref -> unit$/;"	v
union	cil/src/mergecil.ml	/^let union (nd1: 'a node) (nd2: 'a node) : 'a node * (unit -> unit) = $/;"	v
unmark	cil/ocamlutil/pretty.ml	/^let unmark        = Unmark$/;"	v
unmark	cil/ocamlutil/pretty.mli	/^val unmark: doc$/;"	v	function:++
unop	cil/src/cil.mli	/^and unop =$/;"	t
unrollType	cil/src/cil.ml	/^let unrollType (t: typ) : typ = $/;"	v
unrollType	cil/src/cil.mli	/^val unrollType: typ -> typ  $/;"	v
unrollTypeDeep	cil/src/cil.ml	/^let rec unrollTypeDeep (t: typ) : typ = $/;"	v
unrollTypeDeep	cil/src/cil.mli	/^val unrollTypeDeep: typ -> typ $/;"	v
unrollVisitor	cil/src/libmaincil.ml	/^let unrollVisitor = new unrollVisitorClass;;$/;"	v
unrollVisitorClass	cil/src/libmaincil.ml	/^class unrollVisitorClass = object (self)$/;"	c
unsignedVersionOf	cil/src/cil.ml	/^let unsignedVersionOf (ik:ikind): ikind =$/;"	v
unstore	cil/src/ext/pta/steensgaard.ml	/^and unstore (t,i : tau * int) =$/;"	v
update	cil/src/ext/astslicer.ml	/^let update ht elt =$/;"	v
update	cil/src/ext/pta/uref.ml	/^let update (p,x) = $/;"	v
update	cil/src/ext/pta/uref.mli	/^val update: 'a uref * 'a -> unit$/;"	v
update	cil/src/ext/ssa.ml	/^    let update y = if idom.(y) <> x then df.(x) <- y::df.(x) in$/;"	v
upointType	cil/src/cil.ml	/^let upointType = ref voidType $/;"	v
upointType	cil/src/cil.mli	/^val upointType: typ ref$/;"	v
uppercase	cil/libstr/src/case.c	/^void uppercase (char str[])$/;"	f
uref	cil/src/ext/pta/uref.ml	/^and 'a uref = 'a urefC ref$/;"	t
uref	cil/src/ext/pta/uref.ml	/^let uref x = ref (Ecr(x,0))$/;"	v
uref	cil/src/ext/pta/uref.mli	/^type 'a uref$/;"	t
uref	cil/src/ext/pta/uref.mli	/^val uref: 'a -> 'a uref $/;"	v
urefC	cil/src/ext/pta/uref.ml	/^type 'a urefC =$/;"	t
usage	cil/bin/cilly	/^sub usage {$/;"	s
usage	cil/lib/Cilly.pm	/^sub usage {$/;"	s
usageescape	cil/test/small1/init.c	/^static char usageescape = 'C';$/;"	v	file:
usagep	cil/test/small1/init.c	/^char *usagep = "Usage non-local";$/;"	v
usagep1	cil/test/small1/init.c	/^char *usagep1 = { "Usage in a brace" };$/;"	v
usageplocal	cil/test/small1/init.c	/^static char *usageplocal = "Usage";$/;"	v	file:
usages	cil/test/small1/init.c	/^char usages[] = ("Usage string");$/;"	v
useAlignDepth	cil/ocamlutil/pretty.ml	/^let useAlignDepth = true$/;"	v
useConfigurationBool	cil/ocamlutil/util.ml	/^let useConfigurationBool (key: string) (f: bool -> unit) = $/;"	v
useConfigurationInt	cil/ocamlutil/util.ml	/^let useConfigurationInt (key: string) (f: int -> unit) = $/;"	v
useConfigurationList	cil/ocamlutil/util.ml	/^let useConfigurationList (key: string) (f: configData list -> unit) = $/;"	v
useConfigurationString	cil/ocamlutil/util.ml	/^let useConfigurationString (key: string) (f: string -> unit) = $/;"	v
useDefVisitor	cil/src/ext/usedef.ml	/^let useDefVisitor = new useDefVisitorClass $/;"	v
usedLabels	cil/src/rmtmps.ml	/^        let usedLabels:(string, unit) H.t = H.create 13 in$/;"	v
uselessInstrElim	cil/src/ext/deadcodeelim.ml	/^class uselessInstrElim : cilVisitor = object(self)$/;"	c
uses	cil/src/ext/deadcodeelim.ml	/^	    let uses, defd = UD.computeUseDefInstr i in$/;"	v
uses	cil/src/ext/deadcodeelim.ml	/^	  let uses, defd = UD.computeUseDefInstr i in$/;"	v
v	cil/obj/x86_LINUX/formatparse.ml	/^                              let v = (fst _1) args in$/;"	v
v	cil/obj/x86_LINUX/formatparse.ml	/^                     let v = mkTemp n t in$/;"	v
v	cil/src/ext/ssa.ml	/^      let v =$/;"	v
v'	cil/src/cil.ml	/^      let v' = {v with vid = newVID () } in$/;"	v
vEnv	cil/src/mergecil.ml	/^let vEnv : (string, varinfo node) H.t = H.create 111$/;"	v
vEq	cil/src/mergecil.ml	/^let vEq: (int * string, varinfo node) H.t = H.create 111 (* Vars *)$/;"	v
vSyn	cil/src/mergecil.ml	/^let vSyn: (string, varinfo node) H.t = H.create 111 (* Not actually used *)$/;"	v
vaddrof	cil/src/cil.mli	/^    mutable vaddrof: bool;              $/;"	r	type:varinfo
valOf	cil/ocamlutil/util.mli	/^val valOf : 'a option -> 'a$/;"	v
valType	cil/src/ext/crestInstrument.ml	/^let valType  = TInt (ILongLong, [])$/;"	v
valueOfDigit	cil/src/frontc/cabshelper.ml	/^let valueOfDigit chr =$/;"	v
value_t	src/base/basic_types.h	/^typedef long long int value_t;$/;"	t	namespace:crest
var	cil/src/cil.ml	/^let var vi : lval = (Var vi, NoOffset)$/;"	v
var	cil/src/cil.mli	/^val var: varinfo -> lval$/;"	v
varHash	cil/src/ext/availexps.ml	/^let varHash = IH.create 32$/;"	v
varHashMaker	cil/src/ext/availexps.ml	/^let varHashMaker = new varHashMakerClass$/;"	v
varUsedAlready	cil/src/mergecil.ml	/^let varUsedAlready: (string, unit) H.t = H.create 111$/;"	v
var_t	src/base/basic_types.h	/^typedef unsigned int var_t;$/;"	t	namespace:crest
vararg_average	cil/test/small1/vararg1.c	/^union vararg_average {$/;"	u	file:
varinfo	cil/src/cil.mli	/^and varinfo = { $/;"	t
varname	cil/src/frontc/patch.ml	/^    let varname = (extractPatternVar pat) in$/;"	v
vars	src/base/symbolic_execution.h	/^  const map<var_t,type_t>& vars() const { return vars_; }$/;"	f	class:crest::SymbolicExecution
vars4v	cil/src/ext/simplify.ml	/^          let vars4v = H.find newvars v.vname in$/;"	v
vars_	src/base/symbolic_execution.h	/^  map<var_t,type_t>  vars_;$/;"	m	class:crest::SymbolicExecution
vattr	cil/src/cil.mli	/^    mutable vattr: attributes;          $/;"	r	type:varinfo
vattr	cil/src/ext/ciltools.ml	/^  method vattr (Attr(name,params)) =$/;"	m
vblock	cil/src/cil.ml	/^  method vblock (b: block) = $/;"	m
vdecl	cil/src/cil.mli	/^    mutable vdecl: location;            $/;"	r	type:varinfo
vdescr	cil/src/cil.mli	/^    mutable vdescr: Pretty.doc;$/;"	r	type:varinfo
vdescrpure	cil/src/cil.mli	/^    mutable vdescrpure: bool;$/;"	r	type:varinfo
verbose	cil/src/frontc/patch.ml	/^let verbose : bool = true$/;"	v
verboseFlag	cil/ocamlutil/errormsg.ml	/^let verboseFlag = ref false$/;"	v
verboseFlag	cil/ocamlutil/errormsg.mli	/^val verboseFlag : bool ref$/;"	v
version	cil/obj/x86_LINUX/machdep.ml	/^  version: string;        (* version number *)$/;"	r	type:mach
version	cil/src/frontc/cprint.ml	/^let version = "Cprint 2.1e 9.1.99 Hugues Cass"$/;"	v
version_major	cil/obj/x86_LINUX/machdep.ml	/^  version_major: int;     (* Major version number *)$/;"	r	type:mach
version_minor	cil/obj/x86_LINUX/machdep.ml	/^  version_minor: int;     (* Minor version number *)$/;"	r	type:mach
vexpr	cil/src/cil.ml	/^  method vexpr _ = SkipChildren$/;"	m
vexpr	cil/src/ext/ciltools.ml	/^  method vexpr _ = SkipChildren$/;"	m
vexpr	cil/src/ext/deadcodeelim.ml	/^  method vexpr e =$/;"	m
vexpr	cil/src/ext/partial.ml	/^  method vexpr _ = SkipChildren$/;"	m
vexpr	cil/src/ext/simplify.ml	/^  method vexpr (e: exp) = $/;"	m
vexpr	cil/src/ext/usedef.ml	/^  method vexpr (e:exp) =$/;"	m
vexpr	cil/src/frontc/patch.ml	/^  method vexpr (e:expression) : expression visitAction =$/;"	m
vexpr	cil/src/rmtmps.ml	/^  method vexpr (e: exp) = $/;"	m
vfunc	cil/src/ext/partial.ml	/^    method vfunc f =$/;"	m
vfunc	cil/src/ext/sfi.ml	/^  method vfunc (fdec: fundec) = $/;"	m
vfunc	cil/src/ext/simplify.ml	/^  method vfunc (func: fundec) : fundec visitAction = $/;"	m
vglob	cil/src/cil.mli	/^    mutable vglob: bool;	        $/;"	r	type:varinfo
vglob	cil/src/libmaincil.ml	/^  method vglob (g : global) : global list visitAction =$/;"	m
vglob	cil/src/mergecil.ml	/^  method vglob = function$/;"	m
vi	cil/src/check.ml	/^      let vi = fd.svar in$/;"	v
vi	cil/src/cil.ml	/^  let vi = $/;"	v
vi	cil/src/cil.ml	/^  let vi = makeLocalVar fdec name typ in$/;"	v
vi	cil/src/ext/heapify.ml	/^        let vi = makeLocalVar fundec name (TPtr(TComp(ci,[]),[])) in$/;"	v
vi'	cil/src/mergecil.ml	/^          let vi' = processVarinfo vi l in$/;"	v
viFinderClass	cil/src/ext/availexps.ml	/^class viFinderClass vi br = object(self)$/;"	c
viFinderClass	cil/src/ext/predabst.ml	/^    class viFinderClass vi br = object(self)$/;"	c
vid	cil/src/cil.mli	/^    mutable vid: int;  $/;"	r	type:varinfo
vidVisitor	cil/src/ext/ciltools.ml	/^class vidVisitor = object$/;"	c
vidVisitor	cil/src/ext/partial.ml	/^class vidVisitor = object$/;"	c
vinit	cil/src/ext/canonicalize.ml	/^  method vinit (forg: varinfo) (off: offset) i = $/;"	m
vinitoffs	cil/src/mergecil.ml	/^  method vinitoffs o =$/;"	m
vinline	cil/src/cil.mli	/^    mutable vinline: bool;$/;"	r	type:varinfo
vinode	cil/src/mergecil.ml	/^    let vinode = mkSelfNode vEq vSyn !currentFidx vi.vname vi (Some l) in$/;"	v
vinst	cil/src/cil.ml	/^  method vinst _ = SkipChildren$/;"	m
vinst	cil/src/ext/callgraph.ml	/^  method vinst (i:instr) : instr list visitAction = begin $/;"	m
vinst	cil/src/ext/canonicalize.ml	/^  method vinst i = $/;"	m
vinst	cil/src/ext/deadcodeelim.ml	/^  method vinst i =$/;"	m
vinst	cil/src/ext/predabst.ml	/^      method vinst i =$/;"	m
vinst	cil/src/ext/simplify.ml	/^  method vinst (i: instr) =$/;"	m
vinst	cil/src/ext/usedef.ml	/^  method vinst i = match i with$/;"	m
vis	cil/src/ext/availexpslv.ml	/^  let vis = new viFinderClass vi br in$/;"	v
vis	cil/src/ext/blockinggraph.ml	/^          let vis = new findCallsVisitor curNode in$/;"	v
vis	cil/src/ext/stackoverflow.ml	/^          let vis = new findCallsVisitor fdec.svar.vname in$/;"	v
visit	cil/src/ext/ssa.ml	/^  let visit = Array.make nrNodes (false) in$/;"	v
visitAction	cil/src/cil.mli	/^type 'a visitAction = $/;"	t
visitAction	cil/src/frontc/cabsvisit.mli	/^type 'a visitAction = $/;"	t
visitCabsBlock	cil/src/frontc/cabsvisit.ml	/^and visitCabsBlock vis (b: block) : block = $/;"	v
visitCabsTypeSpecifier	cil/src/frontc/cabsvisit.ml	/^let rec visitCabsTypeSpecifier (vis: cabsVisitor) (ts: typeSpecifier) = $/;"	v
visitCilBlock	cil/src/cil.ml	/^and visitCilBlock (vis: cilVisitor) (b: block) : block = $/;"	v
visitCilExpr	cil/src/cil.ml	/^let rec visitCilExpr (vis: cilVisitor) (e: exp) : exp = $/;"	v
visitCilFileSameGlobals	cil/src/cil.ml	/^let visitCilFileSameGlobals (vis : cilVisitor) (f : file) : unit =$/;"	v
visitCilInit	cil/src/cil.ml	/^and visitCilInit (vis: cilVisitor) (forglob: varinfo) $/;"	v
visitCilInitOffset	cil/src/cil.ml	/^and visitCilInitOffset (vis: cilVisitor) (off: offset) : offset =$/;"	v
visitCilLval	cil/src/cil.ml	/^and visitCilLval (vis: cilVisitor) (lv: lval) : lval =$/;"	v
visitCilOffset	cil/src/cil.ml	/^and visitCilOffset (vis: cilVisitor) (off: offset) : offset =$/;"	v
visitCilStmt	cil/src/cil.ml	/^and visitCilStmt (vis: cilVisitor) (s: stmt) : stmt =$/;"	v
visitIfRoot	cil/src/rmtmps.ml	/^  let visitIfRoot global =$/;"	v
visitor	cil/src/ext/astslicer.ml	/^  let visitor = (new dropVisitor ws wi wt wc we wv) in $/;"	v
visitor	cil/src/ext/astslicer.ml	/^  let visitor = (new transVisitor ws wi wt wc we wv) in $/;"	v
visitor	cil/src/rmtmps.ml	/^  let visitor = new markReachableVisitor (globalMap, currentFunc) in$/;"	v
visitorLocation	cil/src/frontc/cabsvisit.ml	/^let visitorLocation = ref { filename = ""; $/;"	v
vlval	cil/src/ext/ciltools.ml	/^  method vlval _ = SkipChildren$/;"	m
vlval	cil/src/ext/partial.ml	/^  method vlval _ = SkipChildren$/;"	m
vname	cil/src/cil.mli	/^    mutable vname: string;		$/;"	r	type:varinfo
voidConstPtrType	cil/src/cil.ml	/^  let voidConstPtrType = TPtr(TVoid [Attr ("const", [])], []) in$/;"	v
voidPtrType	cil/src/cil.ml	/^let voidPtrType = TPtr(voidType, [])$/;"	v
voidPtrType	cil/src/cil.mli	/^val voidPtrType: typ$/;"	v
voidType	cil/src/cil.ml	/^let voidType = TVoid([])$/;"	v
voidType	cil/src/cil.mli	/^val voidType: typ$/;"	v
volatileFinderClass	cil/src/ext/availexps.ml	/^class volatileFinderClass br = object(self)$/;"	c
volatileFinderClass	cil/src/ext/availexpslv.ml	/^class volatileFinderClass br = object(self)$/;"	c
volatileFinderClass	cil/src/ext/expcompare.ml	/^class volatileFinderClass br = object(self)$/;"	c	value:stripCastsForPtrArith
vreferenced	cil/src/cil.mli	/^    mutable vreferenced: bool;          $/;"	r	type:varinfo
vstmt	cil/src/ext/astslicer.ml	/^  method vstmt s = $/;"	m
vstmt	cil/src/ext/blockinggraph.ml	/^  method vstmt (s: stmt) : stmt visitAction = begin$/;"	m
vstmt	cil/src/ext/canonicalize.ml	/^  method vstmt stmt = $/;"	m
vstmt	cil/src/ext/dataflow.ml	/^  method vstmt s =$/;"	m	value:sinkFinder
vstmt	cil/src/ext/deadcodeelim.ml	/^  method vstmt s =$/;"	m
vstmt	cil/src/ext/logcalls.ml	/^  method vstmt (s : stmt) = begin$/;"	m
vstorage	cil/src/cil.mli	/^    mutable vstorage: storage;          $/;"	r	type:varinfo
vtAlpha	cil/src/mergecil.ml	/^let vtAlpha : (string, location A.alphaTableData ref) H.t $/;"	v
vtype	cil/src/cil.ml	/^  method vtype _ = SkipChildren$/;"	m
vtype	cil/src/cil.mli	/^    mutable vtype: typ;                 $/;"	r	type:varinfo
vtype	cil/src/ext/astslicer.ml	/^  method vtype t = begin$/;"	m
vtype	cil/src/ext/ciltools.ml	/^  method vtype _ = SkipChildren$/;"	m
vtype	cil/src/ext/partial.ml	/^  method vtype _ = SkipChildren$/;"	m
vtype	cil/src/mergecil.ml	/^  method vtype (t: typ) = $/;"	m
vtype	cil/src/rmtmps.ml	/^  method vtype typ =$/;"	m
vvar	cil/src/frontc/patch.ml	/^  method vvar (s:string) : string =$/;"	m
vvdec	cil/src/ext/canonicalize.ml	/^  method vvdec v = $/;"	m
vvdec	cil/src/ext/ciltools.ml	/^  method vvdec _ = SkipChildren$/;"	m
vvdec	cil/src/ext/partial.ml	/^  method vvdec _ = SkipChildren$/;"	m
vvrbl	cil/src/cil.ml	/^  method vvrbl (v: varinfo) = $/;"	m
vvrbl	cil/src/ext/availexps.ml	/^  method vvrbl vi =$/;"	m
vvrbl	cil/src/ext/availexpslv.ml	/^  method vvrbl vi =$/;"	m
w	cil/src/ext/ssa.ml	/^    let w = ndfs.(i) in$/;"	v
w	cil/src/ext/ssa.ml	/^  let w = ref ([]) in $/;"	v
w	cil/test/small1/init.c	/^struct str1 w[] =$/;"	v	typeref:struct:str1
wantIndent	cil/ocamlutil/pretty.ml	/^  let wantIndent = ref false in$/;"	v
warn	cil/ocamlutil/errormsg.ml	/^let warn (fmt : ('a,unit,doc,unit) format4) : 'a = $/;"	v
warn	cil/ocamlutil/errormsg.mli	/^val warn:    ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
warn	cil/src/cil.ml	/^let warn (fmt : ('a,unit,doc) format) : 'a = $/;"	v
warnContext	cil/src/cil.ml	/^let warnContext (fmt : ('a,unit,doc) format) : 'a = $/;"	v
warnContextOpt	cil/src/cil.ml	/^let warnContextOpt (fmt : ('a,unit,doc) format) : 'a = $/;"	v
warnFlag	cil/ocamlutil/errormsg.ml	/^let warnFlag = ref false$/;"	v
warnFlag	cil/ocamlutil/errormsg.mli	/^val warnFlag: bool ref$/;"	v
warnLoc	cil/src/cil.ml	/^let warnLoc (loc: location) (fmt : ('a,unit,doc) format) : 'a = $/;"	v
warnOpt	cil/ocamlutil/errormsg.ml	/^let warnOpt (fmt : ('a,unit,doc,unit) format4) : 'a = $/;"	v
warnOpt	cil/ocamlutil/errormsg.mli	/^val warnOpt: ('a,unit,Pretty.doc,unit) format4 -> 'a$/;"	v
warnOpt	cil/src/cil.ml	/^let warnOpt (fmt : ('a,unit,doc) format) : 'a = $/;"	v
wchar	cil/src/escape.ml	/^type wchar = int64$/;"	t
wchar	cil/src/escape.mli	/^type wchar = int64$/;"	t
wcharKind	cil/src/cil.ml	/^let wcharKind = ref IChar$/;"	v
wcharKind	cil/src/cil.mli	/^val wcharKind: ikind ref$/;"	v
wcharType	cil/src/cil.ml	/^let wcharType = ref voidType $/;"	v
wcharType	cil/src/cil.mli	/^val wcharType: typ ref $/;"	v
wchar_t	cil/obj/x86_LINUX/machdep.ml	/^  wchar_t: string;        (* Type of "wchar_t" *)$/;"	r	type:mach
weakestPrecondition	cil/src/ext/predabst.ml	/^    let weakestPrecondition (i : instr) $/;"	v
weight	test/structure_return.c	/^  int weight;$/;"	m	struct:banana	file:
wild	cil/src/ext/pta/steensgaard.ml	/^let wild () : tau =$/;"	v
wild_val	cil/src/ext/pta/steensgaard.ml	/^let wild_val = U.uref Wild$/;"	v
withContext	cil/ocamlutil/errormsg.ml	/^let withContext ctx f x = $/;"	v
withContext	cil/ocamlutil/errormsg.mli	/^val withContext  : (unit -> Pretty.doc) -> ('a -> 'b) -> 'a -> 'b$/;"	v
withPrintDepth	cil/ocamlutil/pretty.ml	/^let withPrintDepth dp thunk = $/;"	v
withPrintDepth	cil/ocamlutil/pretty.mli	/^val withPrintDepth : int -> (unit -> unit) -> unit$/;"	v
withTimeout	cil/ocamlutil/util.mli	/^val withTimeout : float -> (* Seconds for timeout *)$/;"	v
work	cil/src/ext/ssa.ml	/^  let work = Array.create size 0 in $/;"	v
workList	cil/src/ext/ssa.ml	/^      let workList = ref([u]) in$/;"	v
workList	cil/src/ext/ssa.ml	/^  let workList = ref ([]) in (* to iterate in a bottom-up traversal of the dominator tree *)$/;"	v
workList	cil/src/ext/ssa.ml	/^  let workList = ref([]) in$/;"	v
worklist	cil/src/ext/blockinggraph.ml	/^  let worklist = Queue.create () in$/;"	v
worklist	cil/src/ext/partial.ml	/^          let worklist = Heap.create !num_stmts in$/;"	v
wp	cil/src/ext/predabst.ml	/^	let wp = $/;"	v
wraplexer	cil/src/frontc/whitetrack.ml	/^let wraplexer lexer =$/;"	v
wraplexer	cil/src/frontc/whitetrack.mli	/^val wraplexer : (Lexing.lexbuf -> (string * string * 'a * Cabs.cabsloc)) $/;"	v
wraplexer_disabled	cil/src/frontc/whitetrack.ml	/^let wraplexer_disabled lexer lexbuf = $/;"	v
wraplexer_enabled	cil/src/frontc/whitetrack.ml	/^let wraplexer_enabled lexer lexbuf = $/;"	v
writeBranches	cil/src/ext/crestInstrument.ml	/^let writeBranches () =$/;"	v
writeCfg	cil/src/ext/crestInstrument.ml	/^let writeCfg cilFile firstStmtIdMap =$/;"	v
writeCfgVisitor	cil/src/ext/crestInstrument.ml	/^class writeCfgVisitor out firstStmtIdMap =$/;"	c
writeCounter	cil/src/ext/crestInstrument.ml	/^let writeCounter fname (cnt : int) =$/;"	v
writeFirstStmtIdMap	cil/src/ext/crestInstrument.ml	/^let writeFirstStmtIdMap firstStmtIdMap =$/;"	v
writeFunCount	cil/src/ext/crestInstrument.ml	/^let writeFunCount () = writeCounter "funcount" !funCount$/;"	v
writeIdCount	cil/src/ext/crestInstrument.ml	/^let writeIdCount () = writeCounter "idcount" !idCount$/;"	v
writeStmtCount	cil/src/ext/crestInstrument.ml	/^let writeStmtCount () = writeCounter "stmtcount" !stmtCount$/;"	v
wstring	cil/src/escape.ml	/^type wstring = wchar list$/;"	t
wstring	cil/src/escape.mli	/^type wstring = wchar list$/;"	t
x	cil/src/ext/ssa.ml	/^    let x = List.hd !workList in$/;"	v
x	test/structure_test.c	/^  int x;$/;"	m	struct:bar	file:
x	test/structure_test.c	/^  int x;$/;"	m	struct:foo	file:
xform_switch_block	cil/src/cil.ml	/^end and xform_switch_block b break_dest cont_dest label_index = $/;"	v
xform_switch_stmt	cil/src/cil.ml	/^let rec xform_switch_stmt s break_dest cont_dest label_index = begin$/;"	v
y	test/structure_test.c	/^  int y;$/;"	m	struct:bar	file:
y	test/structure_test.c	/^  int y;$/;"	m	struct:foo	file:
yyact	cil/obj/x86_LINUX/cparser.ml	/^let yyact = [|$/;"	v
yycheck	cil/obj/x86_LINUX/cparser.ml	/^let yycheck = "\\021\\000\\$/;"	v
yydefred	cil/obj/x86_LINUX/cparser.ml	/^let yydefred = "\\000\\000\\$/;"	v
yydgoto	cil/obj/x86_LINUX/cparser.ml	/^let yydgoto = "\\003\\000\\$/;"	v
yygindex	cil/obj/x86_LINUX/cparser.ml	/^let yygindex = "\\000\\000\\$/;"	v
yylen	cil/obj/x86_LINUX/cparser.ml	/^let yylen = "\\002\\000\\$/;"	v
yylhs	cil/obj/x86_LINUX/cparser.ml	/^let yylhs = "\\255\\255\\$/;"	v
yynames_block	cil/obj/x86_LINUX/cparser.ml	/^let yynames_block = "\\$/;"	v
yynames_const	cil/obj/x86_LINUX/cparser.ml	/^let yynames_const = "\\$/;"	v
yyrindex	cil/obj/x86_LINUX/cparser.ml	/^let yyrindex = "\\000\\000\\$/;"	v
yysindex	cil/obj/x86_LINUX/cparser.ml	/^let yysindex = "\\153\\000\\$/;"	v
yytable	cil/obj/x86_LINUX/cparser.ml	/^let yytable = "\\077\\000\\$/;"	v
yytables	cil/obj/x86_LINUX/cparser.ml	/^let yytables =$/;"	v
yytables	cil/obj/x86_LINUX/formatparse.ml	/^let yytables =$/;"	v
yytablesize	cil/obj/x86_LINUX/cparser.ml	/^let yytablesize = 6670$/;"	v
yytransl_block	cil/obj/x86_LINUX/cparser.ml	/^let yytransl_block = [|$/;"	v
yytransl_const	cil/obj/x86_LINUX/cparser.ml	/^let yytransl_const = [|$/;"	v
z	cil/test/small1/init.c	/^int z[4][3] =$/;"	v
zero	cil/src/cil.ml	/^let zero      = integer 0$/;"	v
zero	cil/src/cil.mli	/^val zero: exp$/;"	v
~BoundedDepthFirstSearch	src/run_crest/concolic_search.cc	/^BoundedDepthFirstSearch::~BoundedDepthFirstSearch() { }$/;"	f	class:crest::BoundedDepthFirstSearch
~CfgBaselineSearch	src/run_crest/concolic_search.cc	/^CfgBaselineSearch::~CfgBaselineSearch() { }$/;"	f	class:crest::CfgBaselineSearch
~CfgHeuristicSearch	src/run_crest/concolic_search.cc	/^CfgHeuristicSearch::~CfgHeuristicSearch() { }$/;"	f	class:crest::CfgHeuristicSearch
~HybridSearch	src/run_crest/concolic_search.cc	/^HybridSearch::~HybridSearch() { }$/;"	f	class:crest::HybridSearch
~RandomInputSearch	src/run_crest/concolic_search.cc	/^RandomInputSearch::~RandomInputSearch() { }$/;"	f	class:crest::RandomInputSearch
~RandomSearch	src/run_crest/concolic_search.cc	/^RandomSearch::~RandomSearch() { }$/;"	f	class:crest::RandomSearch
~Search	src/run_crest/concolic_search.cc	/^Search::~Search() { }$/;"	f	class:crest::Search
~SymbolicExecution	src/base/symbolic_execution.cc	/^SymbolicExecution::~SymbolicExecution() { }$/;"	f	class:crest::SymbolicExecution
~SymbolicExpr	src/base/symbolic_expression.cc	/^SymbolicExpr::~SymbolicExpr() { }$/;"	f	class:crest::SymbolicExpr
~SymbolicPath	src/base/symbolic_path.cc	/^SymbolicPath::~SymbolicPath() {$/;"	f	class:crest::SymbolicPath
~SymbolicPred	src/base/symbolic_predicate.cc	/^SymbolicPred::~SymbolicPred() {$/;"	f	class:crest::SymbolicPred
~UniformRandomSearch	src/run_crest/concolic_search.cc	/^UniformRandomSearch::~UniformRandomSearch() { }$/;"	f	class:crest::UniformRandomSearch
